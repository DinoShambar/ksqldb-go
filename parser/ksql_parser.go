// Code generated from KSql.g4 by ANTLR 4.7.1. DO NOT EDIT.

package parser // KSql

import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 177, 1141,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 3, 2, 7, 2, 126, 10, 2, 12, 2, 14, 2, 129,
	11, 2, 3, 2, 3, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 5, 3, 140,
	10, 3, 3, 3, 5, 3, 143, 10, 3, 3, 4, 3, 4, 3, 4, 3, 5, 3, 5, 3, 5, 3, 6,
	3, 6, 3, 6, 3, 6, 3, 6, 5, 6, 156, 10, 6, 3, 6, 3, 6, 5, 6, 160, 10, 6,
	3, 6, 3, 6, 3, 6, 5, 6, 165, 10, 6, 3, 6, 3, 6, 3, 6, 5, 6, 170, 10, 6,
	3, 6, 3, 6, 3, 6, 3, 6, 5, 6, 176, 10, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6,
	3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 5, 6, 189, 10, 6, 3, 6, 3, 6, 3, 6,
	5, 6, 194, 10, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6,
	5, 6, 205, 10, 6, 3, 6, 3, 6, 3, 6, 3, 6, 5, 6, 211, 10, 6, 3, 6, 3, 6,
	3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6,
	3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 5, 6, 233, 10, 6, 3, 6, 5, 6, 236,
	10, 6, 3, 6, 3, 6, 3, 6, 3, 6, 5, 6, 242, 10, 6, 3, 6, 3, 6, 5, 6, 246,
	10, 6, 3, 6, 3, 6, 5, 6, 250, 10, 6, 3, 6, 3, 6, 3, 6, 5, 6, 255, 10, 6,
	3, 6, 3, 6, 3, 6, 3, 6, 5, 6, 261, 10, 6, 3, 6, 3, 6, 3, 6, 5, 6, 266,
	10, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 5, 6, 274, 10, 6, 3, 6, 5, 6,
	277, 10, 6, 3, 6, 3, 6, 3, 6, 3, 6, 5, 6, 283, 10, 6, 3, 6, 3, 6, 5, 6,
	287, 10, 6, 3, 6, 3, 6, 5, 6, 291, 10, 6, 3, 6, 3, 6, 3, 6, 5, 6, 296,
	10, 6, 3, 6, 3, 6, 3, 6, 3, 6, 5, 6, 302, 10, 6, 3, 6, 3, 6, 3, 6, 5, 6,
	307, 10, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 5, 6,
	318, 10, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 5, 6,
	329, 10, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 5, 6, 337, 10, 6, 3, 6,
	3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 5, 6, 346, 10, 6, 3, 6, 3, 6, 3, 6,
	5, 6, 351, 10, 6, 3, 6, 3, 6, 3, 6, 3, 6, 5, 6, 357, 10, 6, 3, 6, 3, 6,
	3, 6, 5, 6, 362, 10, 6, 3, 6, 3, 6, 3, 6, 3, 6, 5, 6, 368, 10, 6, 3, 6,
	3, 6, 3, 6, 3, 6, 5, 6, 374, 10, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 5, 6,
	381, 10, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 5, 6, 391,
	10, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 3, 6, 7, 6, 400, 10, 6, 12,
	6, 14, 6, 403, 11, 6, 5, 6, 405, 10, 6, 3, 7, 3, 7, 3, 7, 3, 7, 5, 7, 411,
	10, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 5, 7, 421, 10, 7,
	3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 3, 7, 5, 7, 430, 10, 7, 3, 7, 3, 7,
	5, 7, 434, 10, 7, 3, 7, 3, 7, 3, 7, 3, 7, 5, 7, 440, 10, 7, 3, 7, 3, 7,
	5, 7, 444, 10, 7, 5, 7, 446, 10, 7, 3, 8, 3, 8, 3, 8, 3, 8, 3, 9, 3, 9,
	3, 9, 3, 9, 7, 9, 456, 10, 9, 12, 9, 14, 9, 459, 11, 9, 3, 9, 3, 9, 3,
	9, 3, 9, 5, 9, 465, 10, 9, 3, 9, 3, 9, 5, 9, 469, 10, 9, 3, 9, 3, 9, 3,
	9, 5, 9, 474, 10, 9, 3, 9, 3, 9, 3, 9, 5, 9, 479, 10, 9, 3, 9, 3, 9, 5,
	9, 483, 10, 9, 3, 9, 3, 9, 5, 9, 487, 10, 9, 3, 9, 5, 9, 490, 10, 9, 3,
	10, 3, 10, 3, 11, 3, 11, 5, 11, 496, 10, 11, 3, 11, 3, 11, 3, 11, 3, 12,
	3, 12, 3, 12, 3, 12, 7, 12, 505, 10, 12, 12, 12, 14, 12, 508, 11, 12, 3,
	12, 3, 12, 3, 13, 3, 13, 3, 13, 5, 13, 515, 10, 13, 3, 14, 5, 14, 518,
	10, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 5, 14, 526, 10, 14, 3,
	15, 3, 15, 3, 15, 3, 15, 7, 15, 532, 10, 15, 12, 15, 14, 15, 535, 11, 15,
	3, 15, 3, 15, 3, 16, 3, 16, 5, 16, 541, 10, 16, 3, 16, 3, 16, 3, 16, 3,
	17, 3, 17, 5, 17, 548, 10, 17, 3, 17, 5, 17, 551, 10, 17, 3, 17, 5, 17,
	554, 10, 17, 3, 18, 3, 18, 3, 18, 3, 19, 3, 19, 3, 19, 3, 20, 3, 20, 3,
	20, 3, 20, 3, 21, 3, 21, 3, 21, 3, 21, 3, 21, 3, 22, 5, 22, 572, 10, 22,
	3, 22, 3, 22, 3, 22, 5, 22, 577, 10, 22, 3, 23, 3, 23, 3, 23, 3, 23, 3,
	23, 3, 23, 3, 23, 5, 23, 586, 10, 23, 3, 23, 3, 23, 5, 23, 590, 10, 23,
	3, 23, 3, 23, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 3,
	24, 3, 24, 3, 24, 3, 24, 5, 24, 606, 10, 24, 3, 24, 3, 24, 5, 24, 610,
	10, 24, 3, 24, 3, 24, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 3, 25, 5, 25,
	620, 10, 25, 3, 25, 3, 25, 5, 25, 624, 10, 25, 3, 25, 3, 25, 3, 26, 3,
	26, 3, 27, 3, 27, 3, 27, 7, 27, 633, 10, 27, 12, 27, 14, 27, 636, 11, 27,
	3, 27, 3, 27, 3, 27, 3, 27, 7, 27, 642, 10, 27, 12, 27, 14, 27, 645, 11,
	27, 5, 27, 647, 10, 27, 3, 27, 5, 27, 650, 10, 27, 3, 28, 3, 28, 3, 28,
	7, 28, 655, 10, 28, 12, 28, 14, 28, 658, 11, 28, 3, 28, 3, 28, 3, 28, 3,
	28, 7, 28, 664, 10, 28, 12, 28, 14, 28, 667, 11, 28, 5, 28, 669, 10, 28,
	3, 28, 5, 28, 672, 10, 28, 3, 29, 3, 29, 3, 29, 3, 29, 7, 29, 678, 10,
	29, 12, 29, 14, 29, 681, 11, 29, 5, 29, 683, 10, 29, 3, 29, 3, 29, 3, 30,
	3, 30, 5, 30, 689, 10, 30, 3, 30, 5, 30, 692, 10, 30, 3, 30, 3, 30, 3,
	30, 3, 30, 3, 30, 5, 30, 699, 10, 30, 3, 31, 3, 31, 6, 31, 703, 10, 31,
	13, 31, 14, 31, 704, 3, 31, 5, 31, 708, 10, 31, 3, 32, 3, 32, 3, 32, 3,
	32, 5, 32, 714, 10, 32, 3, 32, 3, 32, 3, 33, 5, 33, 719, 10, 33, 3, 33,
	3, 33, 5, 33, 723, 10, 33, 3, 33, 3, 33, 5, 33, 727, 10, 33, 5, 33, 729,
	10, 33, 3, 34, 3, 34, 3, 34, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35,
	5, 35, 740, 10, 35, 3, 35, 3, 35, 5, 35, 744, 10, 35, 5, 35, 746, 10, 35,
	3, 36, 3, 36, 3, 36, 3, 37, 3, 37, 3, 37, 3, 38, 3, 38, 5, 38, 756, 10,
	38, 3, 38, 5, 38, 759, 10, 38, 3, 39, 3, 39, 3, 39, 3, 39, 7, 39, 765,
	10, 39, 12, 39, 14, 39, 768, 11, 39, 3, 39, 3, 39, 3, 40, 3, 40, 3, 41,
	3, 41, 3, 42, 3, 42, 3, 42, 3, 42, 5, 42, 780, 10, 42, 3, 42, 3, 42, 3,
	42, 3, 42, 3, 42, 3, 42, 7, 42, 788, 10, 42, 12, 42, 14, 42, 791, 11, 42,
	3, 43, 3, 43, 5, 43, 795, 10, 43, 3, 44, 3, 44, 3, 44, 3, 44, 5, 44, 801,
	10, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 3, 44, 5, 44, 809, 10, 44, 3,
	44, 3, 44, 3, 44, 3, 44, 3, 44, 7, 44, 816, 10, 44, 12, 44, 14, 44, 819,
	11, 44, 3, 44, 3, 44, 3, 44, 5, 44, 824, 10, 44, 3, 44, 3, 44, 3, 44, 3,
	44, 5, 44, 830, 10, 44, 3, 44, 3, 44, 5, 44, 834, 10, 44, 3, 44, 3, 44,
	3, 44, 5, 44, 839, 10, 44, 3, 44, 3, 44, 3, 44, 5, 44, 844, 10, 44, 3,
	45, 3, 45, 3, 45, 3, 45, 5, 45, 850, 10, 45, 3, 45, 3, 45, 3, 45, 3, 45,
	3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 3, 45, 7, 45, 864, 10,
	45, 12, 45, 14, 45, 867, 11, 45, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3,
	46, 3, 46, 3, 46, 6, 46, 877, 10, 46, 13, 46, 14, 46, 878, 3, 46, 3, 46,
	5, 46, 883, 10, 46, 3, 46, 3, 46, 3, 46, 3, 46, 6, 46, 889, 10, 46, 13,
	46, 14, 46, 890, 3, 46, 3, 46, 5, 46, 895, 10, 46, 3, 46, 3, 46, 3, 46,
	3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3,
	46, 7, 46, 911, 10, 46, 12, 46, 14, 46, 914, 11, 46, 5, 46, 916, 10, 46,
	3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3,
	46, 7, 46, 929, 10, 46, 12, 46, 14, 46, 932, 11, 46, 5, 46, 934, 10, 46,
	3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3,
	46, 7, 46, 947, 10, 46, 12, 46, 14, 46, 950, 11, 46, 5, 46, 952, 10, 46,
	3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3,
	46, 7, 46, 965, 10, 46, 12, 46, 14, 46, 968, 11, 46, 3, 46, 3, 46, 7, 46,
	972, 10, 46, 12, 46, 14, 46, 975, 11, 46, 5, 46, 977, 10, 46, 3, 46, 3,
	46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 5, 46,
	990, 10, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 7,
	46, 1000, 10, 46, 12, 46, 14, 46, 1003, 11, 46, 3, 47, 3, 47, 5, 47, 1007,
	10, 47, 3, 48, 3, 48, 3, 48, 3, 48, 3, 49, 3, 49, 3, 50, 3, 50, 3, 51,
	3, 51, 3, 51, 3, 51, 3, 51, 3, 51, 3, 51, 3, 51, 3, 51, 3, 51, 3, 51, 3,
	51, 3, 51, 3, 51, 3, 51, 3, 51, 3, 51, 3, 51, 3, 51, 3, 51, 3, 51, 7, 51,
	1038, 10, 51, 12, 51, 14, 51, 1041, 11, 51, 5, 51, 1043, 10, 51, 3, 51,
	3, 51, 3, 51, 3, 51, 3, 51, 3, 51, 3, 51, 3, 51, 3, 51, 3, 51, 3, 51, 3,
	51, 3, 51, 7, 51, 1058, 10, 51, 12, 51, 14, 51, 1061, 11, 51, 3, 51, 3,
	51, 5, 51, 1065, 10, 51, 5, 51, 1067, 10, 51, 3, 51, 3, 51, 7, 51, 1071,
	10, 51, 12, 51, 14, 51, 1074, 11, 51, 3, 52, 3, 52, 3, 53, 3, 53, 3, 54,
	3, 54, 3, 54, 3, 54, 3, 54, 3, 55, 3, 55, 3, 55, 3, 55, 3, 55, 3, 55, 5,
	55, 1091, 10, 55, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56,
	7, 56, 1101, 10, 56, 12, 56, 14, 56, 1104, 11, 56, 3, 56, 3, 56, 3, 56,
	3, 56, 5, 56, 1110, 10, 56, 3, 57, 3, 57, 3, 58, 3, 58, 3, 59, 3, 59, 3,
	60, 5, 60, 1119, 10, 60, 3, 60, 3, 60, 5, 60, 1123, 10, 60, 3, 60, 3, 60,
	5, 60, 1127, 10, 60, 3, 60, 5, 60, 1130, 10, 60, 3, 61, 3, 61, 3, 61, 3,
	61, 3, 61, 5, 61, 1137, 10, 61, 3, 62, 3, 62, 3, 62, 2, 6, 82, 88, 90,
	100, 63, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34,
	36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70,
	72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104,
	106, 108, 110, 112, 114, 116, 118, 120, 122, 2, 14, 3, 2, 98, 99, 3, 2,
	133, 134, 4, 2, 83, 83, 85, 85, 3, 2, 12, 13, 4, 2, 43, 43, 121, 121, 4,
	2, 46, 50, 53, 57, 3, 2, 154, 155, 3, 2, 156, 158, 3, 2, 148, 153, 3, 2,
	37, 38, 4, 2, 10, 10, 164, 164, 17, 2, 10, 13, 34, 34, 39, 49, 58, 58,
	78, 79, 93, 96, 98, 98, 100, 100, 106, 110, 114, 116, 119, 120, 130, 130,
	133, 134, 138, 142, 147, 147, 2, 1294, 2, 127, 3, 2, 2, 2, 4, 139, 3, 2,
	2, 2, 6, 144, 3, 2, 2, 2, 8, 147, 3, 2, 2, 2, 10, 404, 3, 2, 2, 2, 12,
	445, 3, 2, 2, 2, 14, 447, 3, 2, 2, 2, 16, 451, 3, 2, 2, 2, 18, 491, 3,
	2, 2, 2, 20, 493, 3, 2, 2, 2, 22, 500, 3, 2, 2, 2, 24, 511, 3, 2, 2, 2,
	26, 525, 3, 2, 2, 2, 28, 527, 3, 2, 2, 2, 30, 540, 3, 2, 2, 2, 32, 547,
	3, 2, 2, 2, 34, 555, 3, 2, 2, 2, 36, 558, 3, 2, 2, 2, 38, 561, 3, 2, 2,
	2, 40, 565, 3, 2, 2, 2, 42, 571, 3, 2, 2, 2, 44, 578, 3, 2, 2, 2, 46, 593,
	3, 2, 2, 2, 48, 613, 3, 2, 2, 2, 50, 627, 3, 2, 2, 2, 52, 649, 3, 2, 2,
	2, 54, 671, 3, 2, 2, 2, 56, 673, 3, 2, 2, 2, 58, 698, 3, 2, 2, 2, 60, 707,
	3, 2, 2, 2, 62, 709, 3, 2, 2, 2, 64, 728, 3, 2, 2, 2, 66, 730, 3, 2, 2,
	2, 68, 745, 3, 2, 2, 2, 70, 747, 3, 2, 2, 2, 72, 750, 3, 2, 2, 2, 74, 753,
	3, 2, 2, 2, 76, 760, 3, 2, 2, 2, 78, 771, 3, 2, 2, 2, 80, 773, 3, 2, 2,
	2, 82, 779, 3, 2, 2, 2, 84, 792, 3, 2, 2, 2, 86, 843, 3, 2, 2, 2, 88, 849,
	3, 2, 2, 2, 90, 989, 3, 2, 2, 2, 92, 1006, 3, 2, 2, 2, 94, 1008, 3, 2,
	2, 2, 96, 1012, 3, 2, 2, 2, 98, 1014, 3, 2, 2, 2, 100, 1066, 3, 2, 2, 2,
	102, 1075, 3, 2, 2, 2, 104, 1077, 3, 2, 2, 2, 106, 1079, 3, 2, 2, 2, 108,
	1090, 3, 2, 2, 2, 110, 1109, 3, 2, 2, 2, 112, 1111, 3, 2, 2, 2, 114, 1113,
	3, 2, 2, 2, 116, 1115, 3, 2, 2, 2, 118, 1129, 3, 2, 2, 2, 120, 1136, 3,
	2, 2, 2, 122, 1138, 3, 2, 2, 2, 124, 126, 5, 6, 4, 2, 125, 124, 3, 2, 2,
	2, 126, 129, 3, 2, 2, 2, 127, 125, 3, 2, 2, 2, 127, 128, 3, 2, 2, 2, 128,
	130, 3, 2, 2, 2, 129, 127, 3, 2, 2, 2, 130, 131, 7, 2, 2, 3, 131, 3, 3,
	2, 2, 2, 132, 140, 5, 6, 4, 2, 133, 134, 5, 12, 7, 2, 134, 135, 7, 3, 2,
	2, 135, 140, 3, 2, 2, 2, 136, 137, 5, 14, 8, 2, 137, 138, 7, 3, 2, 2, 138,
	140, 3, 2, 2, 2, 139, 132, 3, 2, 2, 2, 139, 133, 3, 2, 2, 2, 139, 136,
	3, 2, 2, 2, 140, 142, 3, 2, 2, 2, 141, 143, 7, 2, 2, 3, 142, 141, 3, 2,
	2, 2, 142, 143, 3, 2, 2, 2, 143, 5, 3, 2, 2, 2, 144, 145, 5, 10, 6, 2,
	145, 146, 7, 3, 2, 2, 146, 7, 3, 2, 2, 2, 147, 148, 5, 80, 41, 2, 148,
	149, 7, 2, 2, 3, 149, 9, 3, 2, 2, 2, 150, 405, 5, 16, 9, 2, 151, 152, 9,
	2, 2, 2, 152, 405, 7, 124, 2, 2, 153, 155, 9, 2, 2, 2, 154, 156, 7, 17,
	2, 2, 155, 154, 3, 2, 2, 2, 155, 156, 3, 2, 2, 2, 156, 157, 3, 2, 2, 2,
	157, 159, 7, 101, 2, 2, 158, 160, 7, 91, 2, 2, 159, 158, 3, 2, 2, 2, 159,
	160, 3, 2, 2, 2, 160, 405, 3, 2, 2, 2, 161, 162, 9, 2, 2, 2, 162, 164,
	7, 86, 2, 2, 163, 165, 7, 91, 2, 2, 164, 163, 3, 2, 2, 2, 164, 165, 3,
	2, 2, 2, 165, 405, 3, 2, 2, 2, 166, 167, 9, 2, 2, 2, 167, 169, 7, 100,
	2, 2, 168, 170, 7, 91, 2, 2, 169, 168, 3, 2, 2, 2, 169, 170, 3, 2, 2, 2,
	170, 405, 3, 2, 2, 2, 171, 172, 9, 2, 2, 2, 172, 405, 7, 109, 2, 2, 173,
	175, 9, 2, 2, 2, 174, 176, 9, 3, 2, 2, 175, 174, 3, 2, 2, 2, 175, 176,
	3, 2, 2, 2, 176, 177, 3, 2, 2, 2, 177, 405, 7, 132, 2, 2, 178, 179, 9,
	2, 2, 2, 179, 180, 7, 131, 2, 2, 180, 405, 7, 144, 2, 2, 181, 182, 9, 2,
	2, 2, 182, 405, 7, 96, 2, 2, 183, 184, 9, 2, 2, 2, 184, 405, 7, 143, 2,
	2, 185, 186, 7, 90, 2, 2, 186, 188, 5, 116, 59, 2, 187, 189, 7, 91, 2,
	2, 188, 187, 3, 2, 2, 2, 188, 189, 3, 2, 2, 2, 189, 405, 3, 2, 2, 2, 190,
	191, 7, 90, 2, 2, 191, 193, 7, 86, 2, 2, 192, 194, 7, 91, 2, 2, 193, 192,
	3, 2, 2, 2, 193, 194, 3, 2, 2, 2, 194, 405, 3, 2, 2, 2, 195, 196, 7, 90,
	2, 2, 196, 197, 7, 110, 2, 2, 197, 405, 5, 108, 55, 2, 198, 199, 7, 90,
	2, 2, 199, 200, 7, 131, 2, 2, 200, 405, 5, 108, 55, 2, 201, 204, 7, 92,
	2, 2, 202, 205, 5, 108, 55, 2, 203, 205, 7, 163, 2, 2, 204, 202, 3, 2,
	2, 2, 204, 203, 3, 2, 2, 2, 205, 206, 3, 2, 2, 2, 206, 405, 5, 32, 17,
	2, 207, 208, 9, 2, 2, 2, 208, 210, 7, 103, 2, 2, 209, 211, 7, 91, 2, 2,
	210, 209, 3, 2, 2, 2, 210, 211, 3, 2, 2, 2, 211, 405, 3, 2, 2, 2, 212,
	213, 7, 104, 2, 2, 213, 405, 5, 108, 55, 2, 214, 215, 7, 104, 2, 2, 215,
	405, 7, 17, 2, 2, 216, 217, 7, 116, 2, 2, 217, 218, 7, 163, 2, 2, 218,
	219, 7, 148, 2, 2, 219, 405, 7, 163, 2, 2, 220, 221, 7, 126, 2, 2, 221,
	405, 7, 163, 2, 2, 222, 223, 7, 117, 2, 2, 223, 224, 5, 112, 57, 2, 224,
	225, 7, 148, 2, 2, 225, 226, 5, 114, 58, 2, 226, 405, 3, 2, 2, 2, 227,
	228, 7, 118, 2, 2, 228, 405, 5, 112, 57, 2, 229, 232, 7, 82, 2, 2, 230,
	231, 7, 27, 2, 2, 231, 233, 7, 139, 2, 2, 232, 230, 3, 2, 2, 2, 232, 233,
	3, 2, 2, 2, 233, 235, 3, 2, 2, 2, 234, 236, 7, 134, 2, 2, 235, 234, 3,
	2, 2, 2, 235, 236, 3, 2, 2, 2, 236, 237, 3, 2, 2, 2, 237, 241, 7, 85, 2,
	2, 238, 239, 7, 147, 2, 2, 239, 240, 7, 30, 2, 2, 240, 242, 7, 31, 2, 2,
	241, 238, 3, 2, 2, 2, 241, 242, 3, 2, 2, 2, 242, 243, 3, 2, 2, 2, 243,
	245, 5, 116, 59, 2, 244, 246, 5, 22, 12, 2, 245, 244, 3, 2, 2, 2, 245,
	246, 3, 2, 2, 2, 246, 249, 3, 2, 2, 2, 247, 248, 7, 80, 2, 2, 248, 250,
	5, 28, 15, 2, 249, 247, 3, 2, 2, 2, 249, 250, 3, 2, 2, 2, 250, 405, 3,
	2, 2, 2, 251, 254, 7, 82, 2, 2, 252, 253, 7, 27, 2, 2, 253, 255, 7, 139,
	2, 2, 254, 252, 3, 2, 2, 2, 254, 255, 3, 2, 2, 2, 255, 256, 3, 2, 2, 2,
	256, 260, 7, 85, 2, 2, 257, 258, 7, 147, 2, 2, 258, 259, 7, 30, 2, 2, 259,
	261, 7, 31, 2, 2, 260, 257, 3, 2, 2, 2, 260, 261, 3, 2, 2, 2, 261, 262,
	3, 2, 2, 2, 262, 265, 5, 116, 59, 2, 263, 264, 7, 80, 2, 2, 264, 266, 5,
	28, 15, 2, 265, 263, 3, 2, 2, 2, 265, 266, 3, 2, 2, 2, 266, 267, 3, 2,
	2, 2, 267, 268, 7, 16, 2, 2, 268, 269, 5, 16, 9, 2, 269, 405, 3, 2, 2,
	2, 270, 273, 7, 82, 2, 2, 271, 272, 7, 27, 2, 2, 272, 274, 7, 139, 2, 2,
	273, 271, 3, 2, 2, 2, 273, 274, 3, 2, 2, 2, 274, 276, 3, 2, 2, 2, 275,
	277, 7, 134, 2, 2, 276, 275, 3, 2, 2, 2, 276, 277, 3, 2, 2, 2, 277, 278,
	3, 2, 2, 2, 278, 282, 7, 83, 2, 2, 279, 280, 7, 147, 2, 2, 280, 281, 7,
	30, 2, 2, 281, 283, 7, 31, 2, 2, 282, 279, 3, 2, 2, 2, 282, 283, 3, 2,
	2, 2, 283, 284, 3, 2, 2, 2, 284, 286, 5, 116, 59, 2, 285, 287, 5, 22, 12,
	2, 286, 285, 3, 2, 2, 2, 286, 287, 3, 2, 2, 2, 287, 290, 3, 2, 2, 2, 288,
	289, 7, 80, 2, 2, 289, 291, 5, 28, 15, 2, 290, 288, 3, 2, 2, 2, 290, 291,
	3, 2, 2, 2, 291, 405, 3, 2, 2, 2, 292, 295, 7, 82, 2, 2, 293, 294, 7, 27,
	2, 2, 294, 296, 7, 139, 2, 2, 295, 293, 3, 2, 2, 2, 295, 296, 3, 2, 2,
	2, 296, 297, 3, 2, 2, 2, 297, 301, 7, 83, 2, 2, 298, 299, 7, 147, 2, 2,
	299, 300, 7, 30, 2, 2, 300, 302, 7, 31, 2, 2, 301, 298, 3, 2, 2, 2, 301,
	302, 3, 2, 2, 2, 302, 303, 3, 2, 2, 2, 303, 306, 5, 116, 59, 2, 304, 305,
	7, 80, 2, 2, 305, 307, 5, 28, 15, 2, 306, 304, 3, 2, 2, 2, 306, 307, 3,
	2, 2, 2, 307, 308, 3, 2, 2, 2, 308, 309, 7, 16, 2, 2, 309, 310, 5, 16,
	9, 2, 310, 405, 3, 2, 2, 2, 311, 312, 7, 82, 2, 2, 312, 313, 9, 3, 2, 2,
	313, 317, 7, 131, 2, 2, 314, 315, 7, 147, 2, 2, 315, 316, 7, 30, 2, 2,
	316, 318, 7, 31, 2, 2, 317, 314, 3, 2, 2, 2, 317, 318, 3, 2, 2, 2, 318,
	319, 3, 2, 2, 2, 319, 320, 5, 108, 55, 2, 320, 321, 7, 80, 2, 2, 321, 322,
	5, 28, 15, 2, 322, 405, 3, 2, 2, 2, 323, 324, 7, 87, 2, 2, 324, 325, 7,
	89, 2, 2, 325, 328, 5, 116, 59, 2, 326, 327, 7, 80, 2, 2, 327, 329, 5,
	28, 15, 2, 328, 326, 3, 2, 2, 2, 328, 329, 3, 2, 2, 2, 329, 330, 3, 2,
	2, 2, 330, 331, 5, 16, 9, 2, 331, 405, 3, 2, 2, 2, 332, 333, 7, 87, 2,
	2, 333, 334, 7, 89, 2, 2, 334, 336, 5, 116, 59, 2, 335, 337, 5, 76, 39,
	2, 336, 335, 3, 2, 2, 2, 336, 337, 3, 2, 2, 2, 337, 338, 3, 2, 2, 2, 338,
	339, 7, 81, 2, 2, 339, 340, 5, 56, 29, 2, 340, 405, 3, 2, 2, 2, 341, 342,
	7, 111, 2, 2, 342, 345, 7, 85, 2, 2, 343, 344, 7, 147, 2, 2, 344, 346,
	7, 31, 2, 2, 345, 343, 3, 2, 2, 2, 345, 346, 3, 2, 2, 2, 346, 347, 3, 2,
	2, 2, 347, 350, 5, 116, 59, 2, 348, 349, 7, 88, 2, 2, 349, 351, 7, 84,
	2, 2, 350, 348, 3, 2, 2, 2, 350, 351, 3, 2, 2, 2, 351, 405, 3, 2, 2, 2,
	352, 353, 7, 111, 2, 2, 353, 356, 7, 83, 2, 2, 354, 355, 7, 147, 2, 2,
	355, 357, 7, 31, 2, 2, 356, 354, 3, 2, 2, 2, 356, 357, 3, 2, 2, 2, 357,
	358, 3, 2, 2, 2, 358, 361, 5, 116, 59, 2, 359, 360, 7, 88, 2, 2, 360, 362,
	7, 84, 2, 2, 361, 359, 3, 2, 2, 2, 361, 362, 3, 2, 2, 2, 362, 405, 3, 2,
	2, 2, 363, 364, 7, 111, 2, 2, 364, 367, 7, 131, 2, 2, 365, 366, 7, 147,
	2, 2, 366, 368, 7, 31, 2, 2, 367, 365, 3, 2, 2, 2, 367, 368, 3, 2, 2, 2,
	368, 369, 3, 2, 2, 2, 369, 405, 5, 108, 55, 2, 370, 373, 7, 93, 2, 2, 371,
	374, 5, 10, 6, 2, 372, 374, 5, 108, 55, 2, 373, 371, 3, 2, 2, 2, 373, 372,
	3, 2, 2, 2, 374, 405, 3, 2, 2, 2, 375, 376, 7, 82, 2, 2, 376, 380, 7, 95,
	2, 2, 377, 378, 7, 147, 2, 2, 378, 379, 7, 30, 2, 2, 379, 381, 7, 31, 2,
	2, 380, 377, 3, 2, 2, 2, 380, 381, 3, 2, 2, 2, 381, 382, 3, 2, 2, 2, 382,
	383, 5, 108, 55, 2, 383, 384, 7, 16, 2, 2, 384, 385, 5, 100, 51, 2, 385,
	405, 3, 2, 2, 2, 386, 387, 7, 111, 2, 2, 387, 390, 7, 95, 2, 2, 388, 389,
	7, 147, 2, 2, 389, 391, 7, 31, 2, 2, 390, 388, 3, 2, 2, 2, 390, 391, 3,
	2, 2, 2, 391, 392, 3, 2, 2, 2, 392, 405, 5, 108, 55, 2, 393, 394, 7, 142,
	2, 2, 394, 395, 9, 4, 2, 2, 395, 396, 5, 116, 59, 2, 396, 401, 5, 20, 11,
	2, 397, 398, 7, 4, 2, 2, 398, 400, 5, 20, 11, 2, 399, 397, 3, 2, 2, 2,
	400, 403, 3, 2, 2, 2, 401, 399, 3, 2, 2, 2, 401, 402, 3, 2, 2, 2, 402,
	405, 3, 2, 2, 2, 403, 401, 3, 2, 2, 2, 404, 150, 3, 2, 2, 2, 404, 151,
	3, 2, 2, 2, 404, 153, 3, 2, 2, 2, 404, 161, 3, 2, 2, 2, 404, 166, 3, 2,
	2, 2, 404, 171, 3, 2, 2, 2, 404, 173, 3, 2, 2, 2, 404, 178, 3, 2, 2, 2,
	404, 181, 3, 2, 2, 2, 404, 183, 3, 2, 2, 2, 404, 185, 3, 2, 2, 2, 404,
	190, 3, 2, 2, 2, 404, 195, 3, 2, 2, 2, 404, 198, 3, 2, 2, 2, 404, 201,
	3, 2, 2, 2, 404, 207, 3, 2, 2, 2, 404, 212, 3, 2, 2, 2, 404, 214, 3, 2,
	2, 2, 404, 216, 3, 2, 2, 2, 404, 220, 3, 2, 2, 2, 404, 222, 3, 2, 2, 2,
	404, 227, 3, 2, 2, 2, 404, 229, 3, 2, 2, 2, 404, 251, 3, 2, 2, 2, 404,
	270, 3, 2, 2, 2, 404, 292, 3, 2, 2, 2, 404, 311, 3, 2, 2, 2, 404, 323,
	3, 2, 2, 2, 404, 332, 3, 2, 2, 2, 404, 341, 3, 2, 2, 2, 404, 352, 3, 2,
	2, 2, 404, 363, 3, 2, 2, 2, 404, 370, 3, 2, 2, 2, 404, 375, 3, 2, 2, 2,
	404, 386, 3, 2, 2, 2, 404, 393, 3, 2, 2, 2, 405, 11, 3, 2, 2, 2, 406, 407,
	7, 140, 2, 2, 407, 408, 7, 81, 2, 2, 408, 410, 5, 116, 59, 2, 409, 411,
	5, 76, 39, 2, 410, 409, 3, 2, 2, 2, 410, 411, 3, 2, 2, 2, 411, 412, 3,
	2, 2, 2, 412, 413, 7, 81, 2, 2, 413, 414, 5, 56, 29, 2, 414, 446, 3, 2,
	2, 2, 415, 416, 7, 140, 2, 2, 416, 417, 7, 36, 2, 2, 417, 418, 7, 81, 2,
	2, 418, 420, 5, 116, 59, 2, 419, 421, 5, 76, 39, 2, 420, 419, 3, 2, 2,
	2, 420, 421, 3, 2, 2, 2, 421, 422, 3, 2, 2, 2, 422, 423, 7, 130, 2, 2,
	423, 424, 5, 56, 29, 2, 424, 446, 3, 2, 2, 2, 425, 426, 7, 140, 2, 2, 426,
	427, 7, 85, 2, 2, 427, 429, 5, 116, 59, 2, 428, 430, 5, 22, 12, 2, 429,
	428, 3, 2, 2, 2, 429, 430, 3, 2, 2, 2, 430, 433, 3, 2, 2, 2, 431, 432,
	7, 80, 2, 2, 432, 434, 5, 28, 15, 2, 433, 431, 3, 2, 2, 2, 433, 434, 3,
	2, 2, 2, 434, 446, 3, 2, 2, 2, 435, 436, 7, 140, 2, 2, 436, 437, 7, 83,
	2, 2, 437, 439, 5, 116, 59, 2, 438, 440, 5, 22, 12, 2, 439, 438, 3, 2,
	2, 2, 439, 440, 3, 2, 2, 2, 440, 443, 3, 2, 2, 2, 441, 442, 7, 80, 2, 2,
	442, 444, 5, 28, 15, 2, 443, 441, 3, 2, 2, 2, 443, 444, 3, 2, 2, 2, 444,
	446, 3, 2, 2, 2, 445, 406, 3, 2, 2, 2, 445, 415, 3, 2, 2, 2, 445, 425,
	3, 2, 2, 2, 445, 435, 3, 2, 2, 2, 446, 13, 3, 2, 2, 2, 447, 448, 7, 127,
	2, 2, 448, 449, 7, 128, 2, 2, 449, 450, 7, 163, 2, 2, 450, 15, 3, 2, 2,
	2, 451, 452, 7, 14, 2, 2, 452, 457, 5, 58, 30, 2, 453, 454, 7, 4, 2, 2,
	454, 456, 5, 58, 30, 2, 455, 453, 3, 2, 2, 2, 456, 459, 3, 2, 2, 2, 457,
	455, 3, 2, 2, 2, 457, 458, 3, 2, 2, 2, 458, 460, 3, 2, 2, 2, 459, 457,
	3, 2, 2, 2, 460, 461, 7, 15, 2, 2, 461, 464, 5, 60, 31, 2, 462, 463, 7,
	21, 2, 2, 463, 465, 5, 42, 22, 2, 464, 462, 3, 2, 2, 2, 464, 465, 3, 2,
	2, 2, 465, 468, 3, 2, 2, 2, 466, 467, 7, 19, 2, 2, 467, 469, 5, 82, 42,
	2, 468, 466, 3, 2, 2, 2, 468, 469, 3, 2, 2, 2, 469, 473, 3, 2, 2, 2, 470,
	471, 7, 22, 2, 2, 471, 472, 7, 23, 2, 2, 472, 474, 5, 52, 27, 2, 473, 470,
	3, 2, 2, 2, 473, 474, 3, 2, 2, 2, 474, 478, 3, 2, 2, 2, 475, 476, 7, 78,
	2, 2, 476, 477, 7, 23, 2, 2, 477, 479, 5, 54, 28, 2, 478, 475, 3, 2, 2,
	2, 478, 479, 3, 2, 2, 2, 479, 482, 3, 2, 2, 2, 480, 481, 7, 24, 2, 2, 481,
	483, 5, 82, 42, 2, 482, 480, 3, 2, 2, 2, 482, 483, 3, 2, 2, 2, 483, 486,
	3, 2, 2, 2, 484, 485, 7, 11, 2, 2, 485, 487, 5, 18, 10, 2, 486, 484, 3,
	2, 2, 2, 486, 487, 3, 2, 2, 2, 487, 489, 3, 2, 2, 2, 488, 490, 5, 36, 19,
	2, 489, 488, 3, 2, 2, 2, 489, 490, 3, 2, 2, 2, 490, 17, 3, 2, 2, 2, 491,
	492, 9, 5, 2, 2, 492, 19, 3, 2, 2, 2, 493, 495, 7, 141, 2, 2, 494, 496,
	7, 107, 2, 2, 495, 494, 3, 2, 2, 2, 495, 496, 3, 2, 2, 2, 496, 497, 3,
	2, 2, 2, 497, 498, 5, 108, 55, 2, 498, 499, 5, 100, 51, 2, 499, 21, 3,
	2, 2, 2, 500, 501, 7, 5, 2, 2, 501, 506, 5, 24, 13, 2, 502, 503, 7, 4,
	2, 2, 503, 505, 5, 24, 13, 2, 504, 502, 3, 2, 2, 2, 505, 508, 3, 2, 2,
	2, 506, 504, 3, 2, 2, 2, 506, 507, 3, 2, 2, 2, 507, 509, 3, 2, 2, 2, 508,
	506, 3, 2, 2, 2, 509, 510, 7, 6, 2, 2, 510, 23, 3, 2, 2, 2, 511, 512, 5,
	108, 55, 2, 512, 514, 5, 100, 51, 2, 513, 515, 5, 26, 14, 2, 514, 513,
	3, 2, 2, 2, 514, 515, 3, 2, 2, 2, 515, 25, 3, 2, 2, 2, 516, 518, 7, 138,
	2, 2, 517, 516, 3, 2, 2, 2, 517, 518, 3, 2, 2, 2, 518, 519, 3, 2, 2, 2,
	519, 526, 7, 130, 2, 2, 520, 526, 7, 145, 2, 2, 521, 522, 7, 146, 2, 2,
	522, 523, 7, 5, 2, 2, 523, 524, 7, 163, 2, 2, 524, 526, 7, 6, 2, 2, 525,
	517, 3, 2, 2, 2, 525, 520, 3, 2, 2, 2, 525, 521, 3, 2, 2, 2, 526, 27, 3,
	2, 2, 2, 527, 528, 7, 5, 2, 2, 528, 533, 5, 30, 16, 2, 529, 530, 7, 4,
	2, 2, 530, 532, 5, 30, 16, 2, 531, 529, 3, 2, 2, 2, 532, 535, 3, 2, 2,
	2, 533, 531, 3, 2, 2, 2, 533, 534, 3, 2, 2, 2, 534, 536, 3, 2, 2, 2, 535,
	533, 3, 2, 2, 2, 536, 537, 7, 6, 2, 2, 537, 29, 3, 2, 2, 2, 538, 541, 5,
	108, 55, 2, 539, 541, 7, 163, 2, 2, 540, 538, 3, 2, 2, 2, 540, 539, 3,
	2, 2, 2, 541, 542, 3, 2, 2, 2, 542, 543, 7, 148, 2, 2, 543, 544, 5, 120,
	61, 2, 544, 31, 3, 2, 2, 2, 545, 546, 7, 15, 2, 2, 546, 548, 7, 125, 2,
	2, 547, 545, 3, 2, 2, 2, 547, 548, 3, 2, 2, 2, 548, 550, 3, 2, 2, 2, 549,
	551, 5, 34, 18, 2, 550, 549, 3, 2, 2, 2, 550, 551, 3, 2, 2, 2, 551, 553,
	3, 2, 2, 2, 552, 554, 5, 36, 19, 2, 553, 552, 3, 2, 2, 2, 553, 554, 3,
	2, 2, 2, 554, 33, 3, 2, 2, 2, 555, 556, 9, 6, 2, 2, 556, 557, 5, 118, 60,
	2, 557, 35, 3, 2, 2, 2, 558, 559, 7, 25, 2, 2, 559, 560, 5, 118, 60, 2,
	560, 37, 3, 2, 2, 2, 561, 562, 7, 63, 2, 2, 562, 563, 5, 118, 60, 2, 563,
	564, 5, 50, 26, 2, 564, 39, 3, 2, 2, 2, 565, 566, 7, 64, 2, 2, 566, 567,
	7, 65, 2, 2, 567, 568, 5, 118, 60, 2, 568, 569, 5, 50, 26, 2, 569, 41,
	3, 2, 2, 2, 570, 572, 7, 167, 2, 2, 571, 570, 3, 2, 2, 2, 571, 572, 3,
	2, 2, 2, 572, 576, 3, 2, 2, 2, 573, 577, 5, 44, 23, 2, 574, 577, 5, 46,
	24, 2, 575, 577, 5, 48, 25, 2, 576, 573, 3, 2, 2, 2, 576, 574, 3, 2, 2,
	2, 576, 575, 3, 2, 2, 2, 577, 43, 3, 2, 2, 2, 578, 579, 7, 59, 2, 2, 579,
	580, 7, 5, 2, 2, 580, 581, 7, 61, 2, 2, 581, 582, 5, 118, 60, 2, 582, 585,
	5, 50, 26, 2, 583, 584, 7, 4, 2, 2, 584, 586, 5, 38, 20, 2, 585, 583, 3,
	2, 2, 2, 585, 586, 3, 2, 2, 2, 586, 589, 3, 2, 2, 2, 587, 588, 7, 4, 2,
	2, 588, 590, 5, 40, 21, 2, 589, 587, 3, 2, 2, 2, 589, 590, 3, 2, 2, 2,
	590, 591, 3, 2, 2, 2, 591, 592, 7, 6, 2, 2, 592, 45, 3, 2, 2, 2, 593, 594,
	7, 60, 2, 2, 594, 595, 7, 5, 2, 2, 595, 596, 7, 61, 2, 2, 596, 597, 5,
	118, 60, 2, 597, 598, 5, 50, 26, 2, 598, 599, 7, 4, 2, 2, 599, 600, 7,
	62, 2, 2, 600, 601, 7, 23, 2, 2, 601, 602, 5, 118, 60, 2, 602, 605, 5,
	50, 26, 2, 603, 604, 7, 4, 2, 2, 604, 606, 5, 38, 20, 2, 605, 603, 3, 2,
	2, 2, 605, 606, 3, 2, 2, 2, 606, 609, 3, 2, 2, 2, 607, 608, 7, 4, 2, 2,
	608, 610, 5, 40, 21, 2, 609, 607, 3, 2, 2, 2, 609, 610, 3, 2, 2, 2, 610,
	611, 3, 2, 2, 2, 611, 612, 7, 6, 2, 2, 612, 47, 3, 2, 2, 2, 613, 614, 7,
	120, 2, 2, 614, 615, 7, 5, 2, 2, 615, 616, 5, 118, 60, 2, 616, 619, 5,
	50, 26, 2, 617, 618, 7, 4, 2, 2, 618, 620, 5, 38, 20, 2, 619, 617, 3, 2,
	2, 2, 619, 620, 3, 2, 2, 2, 620, 623, 3, 2, 2, 2, 621, 622, 7, 4, 2, 2,
	622, 624, 5, 40, 21, 2, 623, 621, 3, 2, 2, 2, 623, 624, 3, 2, 2, 2, 624,
	625, 3, 2, 2, 2, 625, 626, 7, 6, 2, 2, 626, 49, 3, 2, 2, 2, 627, 628, 9,
	7, 2, 2, 628, 51, 3, 2, 2, 2, 629, 634, 5, 88, 45, 2, 630, 631, 7, 4, 2,
	2, 631, 633, 5, 88, 45, 2, 632, 630, 3, 2, 2, 2, 633, 636, 3, 2, 2, 2,
	634, 632, 3, 2, 2, 2, 634, 635, 3, 2, 2, 2, 635, 650, 3, 2, 2, 2, 636,
	634, 3, 2, 2, 2, 637, 646, 7, 5, 2, 2, 638, 643, 5, 88, 45, 2, 639, 640,
	7, 4, 2, 2, 640, 642, 5, 88, 45, 2, 641, 639, 3, 2, 2, 2, 642, 645, 3,
	2, 2, 2, 643, 641, 3, 2, 2, 2, 643, 644, 3, 2, 2, 2, 644, 647, 3, 2, 2,
	2, 645, 643, 3, 2, 2, 2, 646, 638, 3, 2, 2, 2, 646, 647, 3, 2, 2, 2, 647,
	648, 3, 2, 2, 2, 648, 650, 7, 6, 2, 2, 649, 629, 3, 2, 2, 2, 649, 637,
	3, 2, 2, 2, 650, 53, 3, 2, 2, 2, 651, 656, 5, 88, 45, 2, 652, 653, 7, 4,
	2, 2, 653, 655, 5, 88, 45, 2, 654, 652, 3, 2, 2, 2, 655, 658, 3, 2, 2,
	2, 656, 654, 3, 2, 2, 2, 656, 657, 3, 2, 2, 2, 657, 672, 3, 2, 2, 2, 658,
	656, 3, 2, 2, 2, 659, 668, 7, 5, 2, 2, 660, 665, 5, 88, 45, 2, 661, 662,
	7, 4, 2, 2, 662, 664, 5, 88, 45, 2, 663, 661, 3, 2, 2, 2, 664, 667, 3,
	2, 2, 2, 665, 663, 3, 2, 2, 2, 665, 666, 3, 2, 2, 2, 666, 669, 3, 2, 2,
	2, 667, 665, 3, 2, 2, 2, 668, 660, 3, 2, 2, 2, 668, 669, 3, 2, 2, 2, 669,
	670, 3, 2, 2, 2, 670, 672, 7, 6, 2, 2, 671, 651, 3, 2, 2, 2, 671, 659,
	3, 2, 2, 2, 672, 55, 3, 2, 2, 2, 673, 682, 7, 5, 2, 2, 674, 679, 5, 88,
	45, 2, 675, 676, 7, 4, 2, 2, 676, 678, 5, 88, 45, 2, 677, 675, 3, 2, 2,
	2, 678, 681, 3, 2, 2, 2, 679, 677, 3, 2, 2, 2, 679, 680, 3, 2, 2, 2, 680,
	683, 3, 2, 2, 2, 681, 679, 3, 2, 2, 2, 682, 674, 3, 2, 2, 2, 682, 683,
	3, 2, 2, 2, 683, 684, 3, 2, 2, 2, 684, 685, 7, 6, 2, 2, 685, 57, 3, 2,
	2, 2, 686, 691, 5, 80, 41, 2, 687, 689, 7, 16, 2, 2, 688, 687, 3, 2, 2,
	2, 688, 689, 3, 2, 2, 2, 689, 690, 3, 2, 2, 2, 690, 692, 5, 108, 55, 2,
	691, 688, 3, 2, 2, 2, 691, 692, 3, 2, 2, 2, 692, 699, 3, 2, 2, 2, 693,
	694, 5, 108, 55, 2, 694, 695, 7, 7, 2, 2, 695, 696, 7, 156, 2, 2, 696,
	699, 3, 2, 2, 2, 697, 699, 7, 156, 2, 2, 698, 686, 3, 2, 2, 2, 698, 693,
	3, 2, 2, 2, 698, 697, 3, 2, 2, 2, 699, 59, 3, 2, 2, 2, 700, 702, 5, 74,
	38, 2, 701, 703, 5, 62, 32, 2, 702, 701, 3, 2, 2, 2, 703, 704, 3, 2, 2,
	2, 704, 702, 3, 2, 2, 2, 704, 705, 3, 2, 2, 2, 705, 708, 3, 2, 2, 2, 706,
	708, 5, 74, 38, 2, 707, 700, 3, 2, 2, 2, 707, 706, 3, 2, 2, 2, 708, 61,
	3, 2, 2, 2, 709, 710, 5, 64, 33, 2, 710, 711, 7, 71, 2, 2, 711, 713, 5,
	74, 38, 2, 712, 714, 5, 66, 34, 2, 713, 712, 3, 2, 2, 2, 713, 714, 3, 2,
	2, 2, 714, 715, 3, 2, 2, 2, 715, 716, 5, 72, 37, 2, 716, 63, 3, 2, 2, 2,
	717, 719, 7, 74, 2, 2, 718, 717, 3, 2, 2, 2, 718, 719, 3, 2, 2, 2, 719,
	729, 3, 2, 2, 2, 720, 722, 7, 72, 2, 2, 721, 723, 7, 73, 2, 2, 722, 721,
	3, 2, 2, 2, 722, 723, 3, 2, 2, 2, 723, 729, 3, 2, 2, 2, 724, 726, 7, 75,
	2, 2, 725, 727, 7, 73, 2, 2, 726, 725, 3, 2, 2, 2, 726, 727, 3, 2, 2, 2,
	727, 729, 3, 2, 2, 2, 728, 718, 3, 2, 2, 2, 728, 720, 3, 2, 2, 2, 728,
	724, 3, 2, 2, 2, 729, 65, 3, 2, 2, 2, 730, 731, 7, 20, 2, 2, 731, 732,
	5, 68, 35, 2, 732, 67, 3, 2, 2, 2, 733, 734, 7, 5, 2, 2, 734, 735, 5, 70,
	36, 2, 735, 736, 7, 4, 2, 2, 736, 737, 5, 70, 36, 2, 737, 739, 7, 6, 2,
	2, 738, 740, 5, 40, 21, 2, 739, 738, 3, 2, 2, 2, 739, 740, 3, 2, 2, 2,
	740, 746, 3, 2, 2, 2, 741, 743, 5, 70, 36, 2, 742, 744, 5, 40, 21, 2, 743,
	742, 3, 2, 2, 2, 743, 744, 3, 2, 2, 2, 744, 746, 3, 2, 2, 2, 745, 733,
	3, 2, 2, 2, 745, 741, 3, 2, 2, 2, 746, 69, 3, 2, 2, 2, 747, 748, 5, 118,
	60, 2, 748, 749, 5, 50, 26, 2, 749, 71, 3, 2, 2, 2, 750, 751, 7, 77, 2,
	2, 751, 752, 5, 82, 42, 2, 752, 73, 3, 2, 2, 2, 753, 758, 5, 78, 40, 2,
	754, 756, 7, 16, 2, 2, 755, 754, 3, 2, 2, 2, 755, 756, 3, 2, 2, 2, 756,
	757, 3, 2, 2, 2, 757, 759, 5, 116, 59, 2, 758, 755, 3, 2, 2, 2, 758, 759,
	3, 2, 2, 2, 759, 75, 3, 2, 2, 2, 760, 761, 7, 5, 2, 2, 761, 766, 5, 108,
	55, 2, 762, 763, 7, 4, 2, 2, 763, 765, 5, 108, 55, 2, 764, 762, 3, 2, 2,
	2, 765, 768, 3, 2, 2, 2, 766, 764, 3, 2, 2, 2, 766, 767, 3, 2, 2, 2, 767,
	769, 3, 2, 2, 2, 768, 766, 3, 2, 2, 2, 769, 770, 7, 6, 2, 2, 770, 77, 3,
	2, 2, 2, 771, 772, 5, 116, 59, 2, 772, 79, 3, 2, 2, 2, 773, 774, 5, 82,
	42, 2, 774, 81, 3, 2, 2, 2, 775, 776, 8, 42, 1, 2, 776, 780, 5, 84, 43,
	2, 777, 778, 7, 30, 2, 2, 778, 780, 5, 82, 42, 5, 779, 775, 3, 2, 2, 2,
	779, 777, 3, 2, 2, 2, 780, 789, 3, 2, 2, 2, 781, 782, 12, 4, 2, 2, 782,
	783, 7, 28, 2, 2, 783, 788, 5, 82, 42, 5, 784, 785, 12, 3, 2, 2, 785, 786,
	7, 27, 2, 2, 786, 788, 5, 82, 42, 4, 787, 781, 3, 2, 2, 2, 787, 784, 3,
	2, 2, 2, 788, 791, 3, 2, 2, 2, 789, 787, 3, 2, 2, 2, 789, 790, 3, 2, 2,
	2, 790, 83, 3, 2, 2, 2, 791, 789, 3, 2, 2, 2, 792, 794, 5, 88, 45, 2, 793,
	795, 5, 86, 44, 2, 794, 793, 3, 2, 2, 2, 794, 795, 3, 2, 2, 2, 795, 85,
	3, 2, 2, 2, 796, 797, 5, 96, 49, 2, 797, 798, 5, 88, 45, 2, 798, 844, 3,
	2, 2, 2, 799, 801, 7, 30, 2, 2, 800, 799, 3, 2, 2, 2, 800, 801, 3, 2, 2,
	2, 801, 802, 3, 2, 2, 2, 802, 803, 7, 32, 2, 2, 803, 804, 5, 88, 45, 2,
	804, 805, 7, 28, 2, 2, 805, 806, 5, 88, 45, 2, 806, 844, 3, 2, 2, 2, 807,
	809, 7, 30, 2, 2, 808, 807, 3, 2, 2, 2, 808, 809, 3, 2, 2, 2, 809, 810,
	3, 2, 2, 2, 810, 811, 7, 29, 2, 2, 811, 812, 7, 5, 2, 2, 812, 817, 5, 80,
	41, 2, 813, 814, 7, 4, 2, 2, 814, 816, 5, 80, 41, 2, 815, 813, 3, 2, 2,
	2, 816, 819, 3, 2, 2, 2, 817, 815, 3, 2, 2, 2, 817, 818, 3, 2, 2, 2, 818,
	820, 3, 2, 2, 2, 819, 817, 3, 2, 2, 2, 820, 821, 7, 6, 2, 2, 821, 844,
	3, 2, 2, 2, 822, 824, 7, 30, 2, 2, 823, 822, 3, 2, 2, 2, 823, 824, 3, 2,
	2, 2, 824, 825, 3, 2, 2, 2, 825, 826, 7, 33, 2, 2, 826, 829, 5, 88, 45,
	2, 827, 828, 7, 34, 2, 2, 828, 830, 7, 163, 2, 2, 829, 827, 3, 2, 2, 2,
	829, 830, 3, 2, 2, 2, 830, 844, 3, 2, 2, 2, 831, 833, 7, 35, 2, 2, 832,
	834, 7, 30, 2, 2, 833, 832, 3, 2, 2, 2, 833, 834, 3, 2, 2, 2, 834, 835,
	3, 2, 2, 2, 835, 844, 7, 36, 2, 2, 836, 838, 7, 35, 2, 2, 837, 839, 7,
	30, 2, 2, 838, 837, 3, 2, 2, 2, 838, 839, 3, 2, 2, 2, 839, 840, 3, 2, 2,
	2, 840, 841, 7, 18, 2, 2, 841, 842, 7, 15, 2, 2, 842, 844, 5, 88, 45, 2,
	843, 796, 3, 2, 2, 2, 843, 800, 3, 2, 2, 2, 843, 808, 3, 2, 2, 2, 843,
	823, 3, 2, 2, 2, 843, 831, 3, 2, 2, 2, 843, 836, 3, 2, 2, 2, 844, 87, 3,
	2, 2, 2, 845, 846, 8, 45, 1, 2, 846, 850, 5, 90, 46, 2, 847, 848, 9, 8,
	2, 2, 848, 850, 5, 88, 45, 6, 849, 845, 3, 2, 2, 2, 849, 847, 3, 2, 2,
	2, 850, 865, 3, 2, 2, 2, 851, 852, 12, 5, 2, 2, 852, 853, 9, 9, 2, 2, 853,
	864, 5, 88, 45, 6, 854, 855, 12, 4, 2, 2, 855, 856, 9, 8, 2, 2, 856, 864,
	5, 88, 45, 5, 857, 858, 12, 3, 2, 2, 858, 859, 7, 159, 2, 2, 859, 864,
	5, 88, 45, 4, 860, 861, 12, 7, 2, 2, 861, 862, 7, 26, 2, 2, 862, 864, 5,
	94, 48, 2, 863, 851, 3, 2, 2, 2, 863, 854, 3, 2, 2, 2, 863, 857, 3, 2,
	2, 2, 863, 860, 3, 2, 2, 2, 864, 867, 3, 2, 2, 2, 865, 863, 3, 2, 2, 2,
	865, 866, 3, 2, 2, 2, 866, 89, 3, 2, 2, 2, 867, 865, 3, 2, 2, 2, 868, 869,
	8, 46, 1, 2, 869, 990, 5, 120, 61, 2, 870, 871, 5, 108, 55, 2, 871, 872,
	7, 163, 2, 2, 872, 990, 3, 2, 2, 2, 873, 874, 7, 66, 2, 2, 874, 876, 5,
	88, 45, 2, 875, 877, 5, 106, 54, 2, 876, 875, 3, 2, 2, 2, 877, 878, 3,
	2, 2, 2, 878, 876, 3, 2, 2, 2, 878, 879, 3, 2, 2, 2, 879, 882, 3, 2, 2,
	2, 880, 881, 7, 69, 2, 2, 881, 883, 5, 80, 41, 2, 882, 880, 3, 2, 2, 2,
	882, 883, 3, 2, 2, 2, 883, 884, 3, 2, 2, 2, 884, 885, 7, 70, 2, 2, 885,
	990, 3, 2, 2, 2, 886, 888, 7, 66, 2, 2, 887, 889, 5, 106, 54, 2, 888, 887,
	3, 2, 2, 2, 889, 890, 3, 2, 2, 2, 890, 888, 3, 2, 2, 2, 890, 891, 3, 2,
	2, 2, 891, 894, 3, 2, 2, 2, 892, 893, 7, 69, 2, 2, 893, 895, 5, 80, 41,
	2, 894, 892, 3, 2, 2, 2, 894, 895, 3, 2, 2, 2, 895, 896, 3, 2, 2, 2, 896,
	897, 7, 70, 2, 2, 897, 990, 3, 2, 2, 2, 898, 899, 7, 97, 2, 2, 899, 900,
	7, 5, 2, 2, 900, 901, 5, 80, 41, 2, 901, 902, 7, 16, 2, 2, 902, 903, 5,
	100, 51, 2, 903, 904, 7, 6, 2, 2, 904, 990, 3, 2, 2, 2, 905, 906, 7, 114,
	2, 2, 906, 915, 7, 8, 2, 2, 907, 912, 5, 80, 41, 2, 908, 909, 7, 4, 2,
	2, 909, 911, 5, 80, 41, 2, 910, 908, 3, 2, 2, 2, 911, 914, 3, 2, 2, 2,
	912, 910, 3, 2, 2, 2, 912, 913, 3, 2, 2, 2, 913, 916, 3, 2, 2, 2, 914,
	912, 3, 2, 2, 2, 915, 907, 3, 2, 2, 2, 915, 916, 3, 2, 2, 2, 916, 917,
	3, 2, 2, 2, 917, 990, 7, 9, 2, 2, 918, 919, 7, 115, 2, 2, 919, 933, 7,
	5, 2, 2, 920, 921, 5, 80, 41, 2, 921, 922, 7, 160, 2, 2, 922, 930, 5, 80,
	41, 2, 923, 924, 7, 4, 2, 2, 924, 925, 5, 80, 41, 2, 925, 926, 7, 160,
	2, 2, 926, 927, 5, 80, 41, 2, 927, 929, 3, 2, 2, 2, 928, 923, 3, 2, 2,
	2, 929, 932, 3, 2, 2, 2, 930, 928, 3, 2, 2, 2, 930, 931, 3, 2, 2, 2, 931,
	934, 3, 2, 2, 2, 932, 930, 3, 2, 2, 2, 933, 920, 3, 2, 2, 2, 933, 934,
	3, 2, 2, 2, 934, 935, 3, 2, 2, 2, 935, 990, 7, 6, 2, 2, 936, 937, 7, 79,
	2, 2, 937, 951, 7, 5, 2, 2, 938, 939, 5, 108, 55, 2, 939, 940, 7, 160,
	2, 2, 940, 948, 5, 80, 41, 2, 941, 942, 7, 4, 2, 2, 942, 943, 5, 108, 55,
	2, 943, 944, 7, 160, 2, 2, 944, 945, 5, 80, 41, 2, 945, 947, 3, 2, 2, 2,
	946, 941, 3, 2, 2, 2, 947, 950, 3, 2, 2, 2, 948, 946, 3, 2, 2, 2, 948,
	949, 3, 2, 2, 2, 949, 952, 3, 2, 2, 2, 950, 948, 3, 2, 2, 2, 951, 938,
	3, 2, 2, 2, 951, 952, 3, 2, 2, 2, 952, 953, 3, 2, 2, 2, 953, 990, 7, 6,
	2, 2, 954, 955, 5, 108, 55, 2, 955, 956, 7, 5, 2, 2, 956, 957, 7, 156,
	2, 2, 957, 958, 7, 6, 2, 2, 958, 990, 3, 2, 2, 2, 959, 960, 5, 108, 55,
	2, 960, 976, 7, 5, 2, 2, 961, 966, 5, 92, 47, 2, 962, 963, 7, 4, 2, 2,
	963, 965, 5, 92, 47, 2, 964, 962, 3, 2, 2, 2, 965, 968, 3, 2, 2, 2, 966,
	964, 3, 2, 2, 2, 966, 967, 3, 2, 2, 2, 967, 973, 3, 2, 2, 2, 968, 966,
	3, 2, 2, 2, 969, 970, 7, 4, 2, 2, 970, 972, 5, 110, 56, 2, 971, 969, 3,
	2, 2, 2, 972, 975, 3, 2, 2, 2, 973, 971, 3, 2, 2, 2, 973, 974, 3, 2, 2,
	2, 974, 977, 3, 2, 2, 2, 975, 973, 3, 2, 2, 2, 976, 961, 3, 2, 2, 2, 976,
	977, 3, 2, 2, 2, 977, 978, 3, 2, 2, 2, 978, 979, 7, 6, 2, 2, 979, 990,
	3, 2, 2, 2, 980, 990, 5, 108, 55, 2, 981, 982, 5, 108, 55, 2, 982, 983,
	7, 7, 2, 2, 983, 984, 5, 108, 55, 2, 984, 990, 3, 2, 2, 2, 985, 986, 7,
	5, 2, 2, 986, 987, 5, 80, 41, 2, 987, 988, 7, 6, 2, 2, 988, 990, 3, 2,
	2, 2, 989, 868, 3, 2, 2, 2, 989, 870, 3, 2, 2, 2, 989, 873, 3, 2, 2, 2,
	989, 886, 3, 2, 2, 2, 989, 898, 3, 2, 2, 2, 989, 905, 3, 2, 2, 2, 989,
	918, 3, 2, 2, 2, 989, 936, 3, 2, 2, 2, 989, 954, 3, 2, 2, 2, 989, 959,
	3, 2, 2, 2, 989, 980, 3, 2, 2, 2, 989, 981, 3, 2, 2, 2, 989, 985, 3, 2,
	2, 2, 990, 1001, 3, 2, 2, 2, 991, 992, 12, 7, 2, 2, 992, 993, 7, 8, 2,
	2, 993, 994, 5, 88, 45, 2, 994, 995, 7, 9, 2, 2, 995, 1000, 3, 2, 2, 2,
	996, 997, 12, 4, 2, 2, 997, 998, 7, 161, 2, 2, 998, 1000, 5, 108, 55, 2,
	999, 991, 3, 2, 2, 2, 999, 996, 3, 2, 2, 2, 1000, 1003, 3, 2, 2, 2, 1001,
	999, 3, 2, 2, 2, 1001, 1002, 3, 2, 2, 2, 1002, 91, 3, 2, 2, 2, 1003, 1001,
	3, 2, 2, 2, 1004, 1007, 5, 80, 41, 2, 1005, 1007, 5, 50, 26, 2, 1006, 1004,
	3, 2, 2, 2, 1006, 1005, 3, 2, 2, 2, 1007, 93, 3, 2, 2, 2, 1008, 1009, 7,
	41, 2, 2, 1009, 1010, 7, 58, 2, 2, 1010, 1011, 7, 163, 2, 2, 1011, 95,
	3, 2, 2, 2, 1012, 1013, 9, 10, 2, 2, 1013, 97, 3, 2, 2, 2, 1014, 1015,
	9, 11, 2, 2, 1015, 99, 3, 2, 2, 2, 1016, 1017, 8, 51, 1, 2, 1017, 1018,
	7, 114, 2, 2, 1018, 1019, 7, 150, 2, 2, 1019, 1020, 5, 100, 51, 2, 1020,
	1021, 7, 152, 2, 2, 1021, 1067, 3, 2, 2, 2, 1022, 1023, 7, 115, 2, 2, 1023,
	1024, 7, 150, 2, 2, 1024, 1025, 5, 100, 51, 2, 1025, 1026, 7, 4, 2, 2,
	1026, 1027, 5, 100, 51, 2, 1027, 1028, 7, 152, 2, 2, 1028, 1067, 3, 2,
	2, 2, 1029, 1030, 7, 79, 2, 2, 1030, 1042, 7, 150, 2, 2, 1031, 1032, 5,
	108, 55, 2, 1032, 1039, 5, 100, 51, 2, 1033, 1034, 7, 4, 2, 2, 1034, 1035,
	5, 108, 55, 2, 1035, 1036, 5, 100, 51, 2, 1036, 1038, 3, 2, 2, 2, 1037,
	1033, 3, 2, 2, 2, 1038, 1041, 3, 2, 2, 2, 1039, 1037, 3, 2, 2, 2, 1039,
	1040, 3, 2, 2, 2, 1040, 1043, 3, 2, 2, 2, 1041, 1039, 3, 2, 2, 2, 1042,
	1031, 3, 2, 2, 2, 1042, 1043, 3, 2, 2, 2, 1043, 1044, 3, 2, 2, 2, 1044,
	1067, 7, 152, 2, 2, 1045, 1046, 7, 129, 2, 2, 1046, 1047, 7, 5, 2, 2, 1047,
	1048, 5, 118, 60, 2, 1048, 1049, 7, 4, 2, 2, 1049, 1050, 5, 118, 60, 2,
	1050, 1051, 7, 6, 2, 2, 1051, 1067, 3, 2, 2, 2, 1052, 1064, 5, 104, 53,
	2, 1053, 1054, 7, 5, 2, 2, 1054, 1059, 5, 102, 52, 2, 1055, 1056, 7, 4,
	2, 2, 1056, 1058, 5, 102, 52, 2, 1057, 1055, 3, 2, 2, 2, 1058, 1061, 3,
	2, 2, 2, 1059, 1057, 3, 2, 2, 2, 1059, 1060, 3, 2, 2, 2, 1060, 1062, 3,
	2, 2, 2, 1061, 1059, 3, 2, 2, 2, 1062, 1063, 7, 6, 2, 2, 1063, 1065, 3,
	2, 2, 2, 1064, 1053, 3, 2, 2, 2, 1064, 1065, 3, 2, 2, 2, 1065, 1067, 3,
	2, 2, 2, 1066, 1016, 3, 2, 2, 2, 1066, 1022, 3, 2, 2, 2, 1066, 1029, 3,
	2, 2, 2, 1066, 1045, 3, 2, 2, 2, 1066, 1052, 3, 2, 2, 2, 1067, 1072, 3,
	2, 2, 2, 1068, 1069, 12, 8, 2, 2, 1069, 1071, 7, 114, 2, 2, 1070, 1068,
	3, 2, 2, 2, 1071, 1074, 3, 2, 2, 2, 1072, 1070, 3, 2, 2, 2, 1072, 1073,
	3, 2, 2, 2, 1073, 101, 3, 2, 2, 2, 1074, 1072, 3, 2, 2, 2, 1075, 1076,
	9, 12, 2, 2, 1076, 103, 3, 2, 2, 2, 1077, 1078, 5, 108, 55, 2, 1078, 105,
	3, 2, 2, 2, 1079, 1080, 7, 67, 2, 2, 1080, 1081, 5, 80, 41, 2, 1081, 1082,
	7, 68, 2, 2, 1082, 1083, 5, 80, 41, 2, 1083, 107, 3, 2, 2, 2, 1084, 1091,
	7, 171, 2, 2, 1085, 1091, 7, 167, 2, 2, 1086, 1091, 7, 169, 2, 2, 1087,
	1091, 5, 122, 62, 2, 1088, 1091, 7, 170, 2, 2, 1089, 1091, 7, 168, 2, 2,
	1090, 1084, 3, 2, 2, 2, 1090, 1085, 3, 2, 2, 2, 1090, 1086, 3, 2, 2, 2,
	1090, 1087, 3, 2, 2, 2, 1090, 1088, 3, 2, 2, 2, 1090, 1089, 3, 2, 2, 2,
	1091, 109, 3, 2, 2, 2, 1092, 1093, 5, 108, 55, 2, 1093, 1094, 7, 162, 2,
	2, 1094, 1095, 5, 80, 41, 2, 1095, 1110, 3, 2, 2, 2, 1096, 1097, 7, 5,
	2, 2, 1097, 1102, 5, 108, 55, 2, 1098, 1099, 7, 4, 2, 2, 1099, 1101, 5,
	108, 55, 2, 1100, 1098, 3, 2, 2, 2, 1101, 1104, 3, 2, 2, 2, 1102, 1100,
	3, 2, 2, 2, 1102, 1103, 3, 2, 2, 2, 1103, 1105, 3, 2, 2, 2, 1104, 1102,
	3, 2, 2, 2, 1105, 1106, 7, 6, 2, 2, 1106, 1107, 7, 162, 2, 2, 1107, 1108,
	5, 80, 41, 2, 1108, 1110, 3, 2, 2, 2, 1109, 1092, 3, 2, 2, 2, 1109, 1096,
	3, 2, 2, 2, 1110, 111, 3, 2, 2, 2, 1111, 1112, 7, 167, 2, 2, 1112, 113,
	3, 2, 2, 2, 1113, 1114, 7, 163, 2, 2, 1114, 115, 3, 2, 2, 2, 1115, 1116,
	5, 108, 55, 2, 1116, 117, 3, 2, 2, 2, 1117, 1119, 7, 155, 2, 2, 1118, 1117,
	3, 2, 2, 2, 1118, 1119, 3, 2, 2, 2, 1119, 1120, 3, 2, 2, 2, 1120, 1130,
	7, 165, 2, 2, 1121, 1123, 7, 155, 2, 2, 1122, 1121, 3, 2, 2, 2, 1122, 1123,
	3, 2, 2, 2, 1123, 1124, 3, 2, 2, 2, 1124, 1130, 7, 166, 2, 2, 1125, 1127,
	7, 155, 2, 2, 1126, 1125, 3, 2, 2, 2, 1126, 1127, 3, 2, 2, 2, 1127, 1128,
	3, 2, 2, 2, 1128, 1130, 7, 164, 2, 2, 1129, 1118, 3, 2, 2, 2, 1129, 1122,
	3, 2, 2, 2, 1129, 1126, 3, 2, 2, 2, 1130, 119, 3, 2, 2, 2, 1131, 1137,
	7, 36, 2, 2, 1132, 1137, 5, 118, 60, 2, 1133, 1137, 5, 98, 50, 2, 1134,
	1137, 7, 163, 2, 2, 1135, 1137, 7, 171, 2, 2, 1136, 1131, 3, 2, 2, 2, 1136,
	1132, 3, 2, 2, 2, 1136, 1133, 3, 2, 2, 2, 1136, 1134, 3, 2, 2, 2, 1136,
	1135, 3, 2, 2, 2, 1137, 121, 3, 2, 2, 2, 1138, 1139, 9, 13, 2, 2, 1139,
	123, 3, 2, 2, 2, 148, 127, 139, 142, 155, 159, 164, 169, 175, 188, 193,
	204, 210, 232, 235, 241, 245, 249, 254, 260, 265, 273, 276, 282, 286, 290,
	295, 301, 306, 317, 328, 336, 345, 350, 356, 361, 367, 373, 380, 390, 401,
	404, 410, 420, 429, 433, 439, 443, 445, 457, 464, 468, 473, 478, 482, 486,
	489, 495, 506, 514, 517, 525, 533, 540, 547, 550, 553, 571, 576, 585, 589,
	605, 609, 619, 623, 634, 643, 646, 649, 656, 665, 668, 671, 679, 682, 688,
	691, 698, 704, 707, 713, 718, 722, 726, 728, 739, 743, 745, 755, 758, 766,
	779, 787, 789, 794, 800, 808, 817, 823, 829, 833, 838, 843, 849, 863, 865,
	878, 882, 890, 894, 912, 915, 930, 933, 948, 951, 966, 973, 976, 989, 999,
	1001, 1006, 1039, 1042, 1059, 1064, 1066, 1072, 1090, 1102, 1109, 1118,
	1122, 1126, 1129, 1136,
}
var deserializer = antlr.NewATNDeserializer(nil)
var deserializedATN = deserializer.DeserializeFromUInt16(parserATN)

var literalNames = []string{
	"", "';'", "','", "'('", "')'", "'.'", "'['", "']'", "'STRING'", "'EMIT'",
	"'CHANGES'", "'FINAL'", "'SELECT'", "'FROM'", "'AS'", "'ALL'", "'DISTINCT'",
	"'WHERE'", "'WITHIN'", "'WINDOW'", "'GROUP'", "'BY'", "'HAVING'", "'LIMIT'",
	"'AT'", "'OR'", "'AND'", "'IN'", "'NOT'", "'EXISTS'", "'BETWEEN'", "'LIKE'",
	"'ESCAPE'", "'IS'", "'NULL'", "'TRUE'", "'FALSE'", "'INTEGER'", "'DATE'",
	"'TIME'", "'TIMESTAMP'", "'INTERVAL'", "'YEAR'", "'MONTH'", "'DAY'", "'HOUR'",
	"'MINUTE'", "'SECOND'", "'MILLISECOND'", "'YEARS'", "'MONTHS'", "'DAYS'",
	"'HOURS'", "'MINUTES'", "'SECONDS'", "'MILLISECONDS'", "'ZONE'", "'TUMBLING'",
	"'HOPPING'", "'SIZE'", "'ADVANCE'", "'RETENTION'", "'GRACE'", "'PERIOD'",
	"'CASE'", "'WHEN'", "'THEN'", "'ELSE'", "'END'", "'JOIN'", "'FULL'", "'OUTER'",
	"'INNER'", "'LEFT'", "'RIGHT'", "'ON'", "'PARTITION'", "'STRUCT'", "'WITH'",
	"'VALUES'", "'CREATE'", "'TABLE'", "'TOPIC'", "'STREAM'", "'STREAMS'",
	"'INSERT'", "'DELETE'", "'INTO'", "'DESCRIBE'", "'EXTENDED'", "'PRINT'",
	"'EXPLAIN'", "'ANALYZE'", "'TYPE'", "'TYPES'", "'CAST'", "'SHOW'", "'LIST'",
	"'TABLES'", "'TOPICS'", "'QUERY'", "'QUERIES'", "'TERMINATE'", "'LOAD'",
	"'COLUMNS'", "'COLUMN'", "'PARTITIONS'", "'FUNCTIONS'", "'FUNCTION'", "'DROP'",
	"'TO'", "'RENAME'", "'ARRAY'", "'MAP'", "'SET'", "'DEFINE'", "'UNDEFINE'",
	"'RESET'", "'SESSION'", "'SAMPLE'", "'EXPORT'", "'CATALOG'", "'PROPERTIES'",
	"'BEGINNING'", "'UNSET'", "'RUN'", "'SCRIPT'", "'DECIMAL'", "'KEY'", "'CONNECTOR'",
	"'CONNECTORS'", "'SINK'", "'SOURCE'", "'NAMESPACE'", "'MATERIALIZED'",
	"'VIEW'", "'PRIMARY'", "'REPLACE'", "'ASSERT'", "'ADD'", "'ALTER'", "'VARIABLES'",
	"'PLUGINS'", "'HEADERS'", "'HEADER'", "'IF'", "'='", "", "'<'", "'<='",
	"'>'", "'>='", "'+'", "'-'", "'*'", "'/'", "'%'", "'||'", "':='", "'->'",
	"'=>'",
}
var symbolicNames = []string{
	"", "", "", "", "", "", "", "", "", "EMIT", "CHANGES", "FINAL", "SELECT",
	"FROM", "AS", "ALL", "DISTINCT", "WHERE", "WITHIN", "WINDOW", "GROUP",
	"BY", "HAVING", "LIMIT", "AT", "OR", "AND", "IN", "NOT", "EXISTS", "BETWEEN",
	"LIKE", "ESCAPE", "IS", "NULL", "TRUE", "FALSE", "INTEGER", "DATE", "TIME",
	"TIMESTAMP", "INTERVAL", "YEAR", "MONTH", "DAY", "HOUR", "MINUTE", "SECOND",
	"MILLISECOND", "YEARS", "MONTHS", "DAYS", "HOURS", "MINUTES", "SECONDS",
	"MILLISECONDS", "ZONE", "TUMBLING", "HOPPING", "SIZE", "ADVANCE", "RETENTION",
	"GRACE", "PERIOD", "CASE", "WHEN", "THEN", "ELSE", "END", "JOIN", "FULL",
	"OUTER", "INNER", "LEFT", "RIGHT", "ON", "PARTITION", "STRUCT", "WITH",
	"VALUES", "CREATE", "TABLE", "TOPIC", "STREAM", "STREAMS", "INSERT", "DELETE",
	"INTO", "DESCRIBE", "EXTENDED", "PRINT", "EXPLAIN", "ANALYZE", "TYPE",
	"TYPES", "CAST", "SHOW", "LIST", "TABLES", "TOPICS", "QUERY", "QUERIES",
	"TERMINATE", "LOAD", "COLUMNS", "COLUMN", "PARTITIONS", "FUNCTIONS", "FUNCTION",
	"DROP", "TO", "RENAME", "ARRAY", "MAP", "SET", "DEFINE", "UNDEFINE", "RESET",
	"SESSION", "SAMPLE", "EXPORT", "CATALOG", "PROPERTIES", "BEGINNING", "UNSET",
	"RUN", "SCRIPT", "DECIMAL", "KEY", "CONNECTOR", "CONNECTORS", "SINK", "SOURCE",
	"NAMESPACE", "MATERIALIZED", "VIEW", "PRIMARY", "REPLACE", "ASSERT", "ADD",
	"ALTER", "VARIABLES", "PLUGINS", "HEADERS", "HEADER", "IF", "EQ", "NEQ",
	"LT", "LTE", "GT", "GTE", "PLUS", "MINUS", "ASTERISK", "SLASH", "PERCENT",
	"CONCAT", "ASSIGN", "STRUCT_FIELD_REF", "LAMBDA_EXPRESSION", "STRING",
	"INTEGER_VALUE", "DECIMAL_VALUE", "FLOATING_POINT_VALUE", "IDENTIFIER",
	"DIGIT_IDENTIFIER", "QUOTED_IDENTIFIER", "BACKQUOTED_IDENTIFIER", "VARIABLE",
	"SIMPLE_COMMENT", "DIRECTIVE_COMMENT", "BRACKETED_COMMENT", "WS", "UNRECOGNIZED",
	"DELIMITER",
}

var ruleNames = []string{
	"statements", "testStatement", "singleStatement", "singleExpression", "statement",
	"assertStatement", "runScript", "query", "resultMaterialization", "alterOption",
	"tableElements", "tableElement", "columnConstraints", "tableProperties",
	"tableProperty", "printClause", "intervalClause", "limitClause", "retentionClause",
	"gracePeriodClause", "windowExpression", "tumblingWindowExpression", "hoppingWindowExpression",
	"sessionWindowExpression", "windowUnit", "groupBy", "partitionBy", "values",
	"selectItem", "relation", "joinedSource", "joinType", "joinWindow", "withinExpression",
	"joinWindowSize", "joinCriteria", "aliasedRelation", "columns", "relationPrimary",
	"expression", "booleanExpression", "predicated", "predicate", "valueExpression",
	"primaryExpression", "functionArgument", "timeZoneSpecifier", "comparisonOperator",
	"booleanValue", "sqltype", "typeParameter", "baseType", "whenClause", "identifier",
	"lambdaFunction", "variableName", "variableValue", "sourceName", "number",
	"literal", "nonReserved",
}
var decisionToDFA = make([]*antlr.DFA, len(deserializedATN.DecisionToState))

func init() {
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
}

type KSqlParser struct {
	*antlr.BaseParser
}

func NewKSqlParser(input antlr.TokenStream) *KSqlParser {
	this := new(KSqlParser)

	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "KSql.g4"

	return this
}

// KSqlParser tokens.
const (
	KSqlParserEOF                   = antlr.TokenEOF
	KSqlParserT__0                  = 1
	KSqlParserT__1                  = 2
	KSqlParserT__2                  = 3
	KSqlParserT__3                  = 4
	KSqlParserT__4                  = 5
	KSqlParserT__5                  = 6
	KSqlParserT__6                  = 7
	KSqlParserT__7                  = 8
	KSqlParserEMIT                  = 9
	KSqlParserCHANGES               = 10
	KSqlParserFINAL                 = 11
	KSqlParserSELECT                = 12
	KSqlParserFROM                  = 13
	KSqlParserAS                    = 14
	KSqlParserALL                   = 15
	KSqlParserDISTINCT              = 16
	KSqlParserWHERE                 = 17
	KSqlParserWITHIN                = 18
	KSqlParserWINDOW                = 19
	KSqlParserGROUP                 = 20
	KSqlParserBY                    = 21
	KSqlParserHAVING                = 22
	KSqlParserLIMIT                 = 23
	KSqlParserAT                    = 24
	KSqlParserOR                    = 25
	KSqlParserAND                   = 26
	KSqlParserIN                    = 27
	KSqlParserNOT                   = 28
	KSqlParserEXISTS                = 29
	KSqlParserBETWEEN               = 30
	KSqlParserLIKE                  = 31
	KSqlParserESCAPE                = 32
	KSqlParserIS                    = 33
	KSqlParserNULL                  = 34
	KSqlParserTRUE                  = 35
	KSqlParserFALSE                 = 36
	KSqlParserINTEGER               = 37
	KSqlParserDATE                  = 38
	KSqlParserTIME                  = 39
	KSqlParserTIMESTAMP             = 40
	KSqlParserINTERVAL              = 41
	KSqlParserYEAR                  = 42
	KSqlParserMONTH                 = 43
	KSqlParserDAY                   = 44
	KSqlParserHOUR                  = 45
	KSqlParserMINUTE                = 46
	KSqlParserSECOND                = 47
	KSqlParserMILLISECOND           = 48
	KSqlParserYEARS                 = 49
	KSqlParserMONTHS                = 50
	KSqlParserDAYS                  = 51
	KSqlParserHOURS                 = 52
	KSqlParserMINUTES               = 53
	KSqlParserSECONDS               = 54
	KSqlParserMILLISECONDS          = 55
	KSqlParserZONE                  = 56
	KSqlParserTUMBLING              = 57
	KSqlParserHOPPING               = 58
	KSqlParserSIZE                  = 59
	KSqlParserADVANCE               = 60
	KSqlParserRETENTION             = 61
	KSqlParserGRACE                 = 62
	KSqlParserPERIOD                = 63
	KSqlParserCASE                  = 64
	KSqlParserWHEN                  = 65
	KSqlParserTHEN                  = 66
	KSqlParserELSE                  = 67
	KSqlParserEND                   = 68
	KSqlParserJOIN                  = 69
	KSqlParserFULL                  = 70
	KSqlParserOUTER                 = 71
	KSqlParserINNER                 = 72
	KSqlParserLEFT                  = 73
	KSqlParserRIGHT                 = 74
	KSqlParserON                    = 75
	KSqlParserPARTITION             = 76
	KSqlParserSTRUCT                = 77
	KSqlParserWITH                  = 78
	KSqlParserVALUES                = 79
	KSqlParserCREATE                = 80
	KSqlParserTABLE                 = 81
	KSqlParserTOPIC                 = 82
	KSqlParserSTREAM                = 83
	KSqlParserSTREAMS               = 84
	KSqlParserINSERT                = 85
	KSqlParserDELETE                = 86
	KSqlParserINTO                  = 87
	KSqlParserDESCRIBE              = 88
	KSqlParserEXTENDED              = 89
	KSqlParserPRINT                 = 90
	KSqlParserEXPLAIN               = 91
	KSqlParserANALYZE               = 92
	KSqlParserTYPE                  = 93
	KSqlParserTYPES                 = 94
	KSqlParserCAST                  = 95
	KSqlParserSHOW                  = 96
	KSqlParserLIST                  = 97
	KSqlParserTABLES                = 98
	KSqlParserTOPICS                = 99
	KSqlParserQUERY                 = 100
	KSqlParserQUERIES               = 101
	KSqlParserTERMINATE             = 102
	KSqlParserLOAD                  = 103
	KSqlParserCOLUMNS               = 104
	KSqlParserCOLUMN                = 105
	KSqlParserPARTITIONS            = 106
	KSqlParserFUNCTIONS             = 107
	KSqlParserFUNCTION              = 108
	KSqlParserDROP                  = 109
	KSqlParserTO                    = 110
	KSqlParserRENAME                = 111
	KSqlParserARRAY                 = 112
	KSqlParserMAP                   = 113
	KSqlParserSET                   = 114
	KSqlParserDEFINE                = 115
	KSqlParserUNDEFINE              = 116
	KSqlParserRESET                 = 117
	KSqlParserSESSION               = 118
	KSqlParserSAMPLE                = 119
	KSqlParserEXPORT                = 120
	KSqlParserCATALOG               = 121
	KSqlParserPROPERTIES            = 122
	KSqlParserBEGINNING             = 123
	KSqlParserUNSET                 = 124
	KSqlParserRUN                   = 125
	KSqlParserSCRIPT                = 126
	KSqlParserDECIMAL               = 127
	KSqlParserKEY                   = 128
	KSqlParserCONNECTOR             = 129
	KSqlParserCONNECTORS            = 130
	KSqlParserSINK                  = 131
	KSqlParserSOURCE                = 132
	KSqlParserNAMESPACE             = 133
	KSqlParserMATERIALIZED          = 134
	KSqlParserVIEW                  = 135
	KSqlParserPRIMARY               = 136
	KSqlParserREPLACE               = 137
	KSqlParserASSERT                = 138
	KSqlParserADD                   = 139
	KSqlParserALTER                 = 140
	KSqlParserVARIABLES             = 141
	KSqlParserPLUGINS               = 142
	KSqlParserHEADERS               = 143
	KSqlParserHEADER                = 144
	KSqlParserIF                    = 145
	KSqlParserEQ                    = 146
	KSqlParserNEQ                   = 147
	KSqlParserLT                    = 148
	KSqlParserLTE                   = 149
	KSqlParserGT                    = 150
	KSqlParserGTE                   = 151
	KSqlParserPLUS                  = 152
	KSqlParserMINUS                 = 153
	KSqlParserASTERISK              = 154
	KSqlParserSLASH                 = 155
	KSqlParserPERCENT               = 156
	KSqlParserCONCAT                = 157
	KSqlParserASSIGN                = 158
	KSqlParserSTRUCT_FIELD_REF      = 159
	KSqlParserLAMBDA_EXPRESSION     = 160
	KSqlParserSTRING                = 161
	KSqlParserINTEGER_VALUE         = 162
	KSqlParserDECIMAL_VALUE         = 163
	KSqlParserFLOATING_POINT_VALUE  = 164
	KSqlParserIDENTIFIER            = 165
	KSqlParserDIGIT_IDENTIFIER      = 166
	KSqlParserQUOTED_IDENTIFIER     = 167
	KSqlParserBACKQUOTED_IDENTIFIER = 168
	KSqlParserVARIABLE              = 169
	KSqlParserSIMPLE_COMMENT        = 170
	KSqlParserDIRECTIVE_COMMENT     = 171
	KSqlParserBRACKETED_COMMENT     = 172
	KSqlParserWS                    = 173
	KSqlParserUNRECOGNIZED          = 174
	KSqlParserDELIMITER             = 175
)

// KSqlParser rules.
const (
	KSqlParserRULE_statements               = 0
	KSqlParserRULE_testStatement            = 1
	KSqlParserRULE_singleStatement          = 2
	KSqlParserRULE_singleExpression         = 3
	KSqlParserRULE_statement                = 4
	KSqlParserRULE_assertStatement          = 5
	KSqlParserRULE_runScript                = 6
	KSqlParserRULE_query                    = 7
	KSqlParserRULE_resultMaterialization    = 8
	KSqlParserRULE_alterOption              = 9
	KSqlParserRULE_tableElements            = 10
	KSqlParserRULE_tableElement             = 11
	KSqlParserRULE_columnConstraints        = 12
	KSqlParserRULE_tableProperties          = 13
	KSqlParserRULE_tableProperty            = 14
	KSqlParserRULE_printClause              = 15
	KSqlParserRULE_intervalClause           = 16
	KSqlParserRULE_limitClause              = 17
	KSqlParserRULE_retentionClause          = 18
	KSqlParserRULE_gracePeriodClause        = 19
	KSqlParserRULE_windowExpression         = 20
	KSqlParserRULE_tumblingWindowExpression = 21
	KSqlParserRULE_hoppingWindowExpression  = 22
	KSqlParserRULE_sessionWindowExpression  = 23
	KSqlParserRULE_windowUnit               = 24
	KSqlParserRULE_groupBy                  = 25
	KSqlParserRULE_partitionBy              = 26
	KSqlParserRULE_values                   = 27
	KSqlParserRULE_selectItem               = 28
	KSqlParserRULE_relation                 = 29
	KSqlParserRULE_joinedSource             = 30
	KSqlParserRULE_joinType                 = 31
	KSqlParserRULE_joinWindow               = 32
	KSqlParserRULE_withinExpression         = 33
	KSqlParserRULE_joinWindowSize           = 34
	KSqlParserRULE_joinCriteria             = 35
	KSqlParserRULE_aliasedRelation          = 36
	KSqlParserRULE_columns                  = 37
	KSqlParserRULE_relationPrimary          = 38
	KSqlParserRULE_expression               = 39
	KSqlParserRULE_booleanExpression        = 40
	KSqlParserRULE_predicated               = 41
	KSqlParserRULE_predicate                = 42
	KSqlParserRULE_valueExpression          = 43
	KSqlParserRULE_primaryExpression        = 44
	KSqlParserRULE_functionArgument         = 45
	KSqlParserRULE_timeZoneSpecifier        = 46
	KSqlParserRULE_comparisonOperator       = 47
	KSqlParserRULE_booleanValue             = 48
	KSqlParserRULE_sqltype                  = 49
	KSqlParserRULE_typeParameter            = 50
	KSqlParserRULE_baseType                 = 51
	KSqlParserRULE_whenClause               = 52
	KSqlParserRULE_identifier               = 53
	KSqlParserRULE_lambdaFunction           = 54
	KSqlParserRULE_variableName             = 55
	KSqlParserRULE_variableValue            = 56
	KSqlParserRULE_sourceName               = 57
	KSqlParserRULE_number                   = 58
	KSqlParserRULE_literal                  = 59
	KSqlParserRULE_nonReserved              = 60
)

// IStatementsContext is an interface to support dynamic dispatch.
type IStatementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementsContext differentiates from other interfaces.
	IsStatementsContext()
}

type StatementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementsContext() *StatementsContext {
	var p = new(StatementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_statements
	return p
}

func (*StatementsContext) IsStatementsContext() {}

func NewStatementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementsContext {
	var p = new(StatementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_statements

	return p
}

func (s *StatementsContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementsContext) EOF() antlr.TerminalNode {
	return s.GetToken(KSqlParserEOF, 0)
}

func (s *StatementsContext) AllSingleStatement() []ISingleStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISingleStatementContext)(nil)).Elem())
	var tst = make([]ISingleStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISingleStatementContext)
		}
	}

	return tst
}

func (s *StatementsContext) SingleStatement(i int) ISingleStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISingleStatementContext)
}

func (s *StatementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterStatements(s)
	}
}

func (s *StatementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitStatements(s)
	}
}

func (p *KSqlParser) Statements() (localctx IStatementsContext) {
	localctx = NewStatementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, KSqlParserRULE_statements)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(125)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KSqlParserSELECT || (((_la-80)&-(0x1f+1)) == 0 && ((1<<uint((_la-80)))&((1<<(KSqlParserCREATE-80))|(1<<(KSqlParserINSERT-80))|(1<<(KSqlParserDESCRIBE-80))|(1<<(KSqlParserPRINT-80))|(1<<(KSqlParserEXPLAIN-80))|(1<<(KSqlParserSHOW-80))|(1<<(KSqlParserLIST-80))|(1<<(KSqlParserTERMINATE-80))|(1<<(KSqlParserDROP-80)))) != 0) || (((_la-114)&-(0x1f+1)) == 0 && ((1<<uint((_la-114)))&((1<<(KSqlParserSET-114))|(1<<(KSqlParserDEFINE-114))|(1<<(KSqlParserUNDEFINE-114))|(1<<(KSqlParserUNSET-114))|(1<<(KSqlParserALTER-114)))) != 0) {
		{
			p.SetState(122)
			p.SingleStatement()
		}

		p.SetState(127)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(128)
		p.Match(KSqlParserEOF)
	}

	return localctx
}

// ITestStatementContext is an interface to support dynamic dispatch.
type ITestStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTestStatementContext differentiates from other interfaces.
	IsTestStatementContext()
}

type TestStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTestStatementContext() *TestStatementContext {
	var p = new(TestStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_testStatement
	return p
}

func (*TestStatementContext) IsTestStatementContext() {}

func NewTestStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TestStatementContext {
	var p = new(TestStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_testStatement

	return p
}

func (s *TestStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TestStatementContext) SingleStatement() ISingleStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISingleStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISingleStatementContext)
}

func (s *TestStatementContext) AssertStatement() IAssertStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssertStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssertStatementContext)
}

func (s *TestStatementContext) RunScript() IRunScriptContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRunScriptContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRunScriptContext)
}

func (s *TestStatementContext) EOF() antlr.TerminalNode {
	return s.GetToken(KSqlParserEOF, 0)
}

func (s *TestStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TestStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TestStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterTestStatement(s)
	}
}

func (s *TestStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitTestStatement(s)
	}
}

func (p *KSqlParser) TestStatement() (localctx ITestStatementContext) {
	localctx = NewTestStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, KSqlParserRULE_testStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(137)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KSqlParserSELECT, KSqlParserCREATE, KSqlParserINSERT, KSqlParserDESCRIBE, KSqlParserPRINT, KSqlParserEXPLAIN, KSqlParserSHOW, KSqlParserLIST, KSqlParserTERMINATE, KSqlParserDROP, KSqlParserSET, KSqlParserDEFINE, KSqlParserUNDEFINE, KSqlParserUNSET, KSqlParserALTER:
		{
			p.SetState(130)
			p.SingleStatement()
		}

	case KSqlParserASSERT:
		{
			p.SetState(131)
			p.AssertStatement()
		}
		{
			p.SetState(132)
			p.Match(KSqlParserT__0)
		}

	case KSqlParserRUN:
		{
			p.SetState(134)
			p.RunScript()
		}
		{
			p.SetState(135)
			p.Match(KSqlParserT__0)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(140)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 2, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(139)
			p.Match(KSqlParserEOF)
		}

	}

	return localctx
}

// ISingleStatementContext is an interface to support dynamic dispatch.
type ISingleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSingleStatementContext differentiates from other interfaces.
	IsSingleStatementContext()
}

type SingleStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleStatementContext() *SingleStatementContext {
	var p = new(SingleStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_singleStatement
	return p
}

func (*SingleStatementContext) IsSingleStatementContext() {}

func NewSingleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleStatementContext {
	var p = new(SingleStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_singleStatement

	return p
}

func (s *SingleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleStatementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *SingleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterSingleStatement(s)
	}
}

func (s *SingleStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitSingleStatement(s)
	}
}

func (p *KSqlParser) SingleStatement() (localctx ISingleStatementContext) {
	localctx = NewSingleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, KSqlParserRULE_singleStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(142)
		p.Statement()
	}
	{
		p.SetState(143)
		p.Match(KSqlParserT__0)
	}

	return localctx
}

// ISingleExpressionContext is an interface to support dynamic dispatch.
type ISingleExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSingleExpressionContext differentiates from other interfaces.
	IsSingleExpressionContext()
}

type SingleExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleExpressionContext() *SingleExpressionContext {
	var p = new(SingleExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_singleExpression
	return p
}

func (*SingleExpressionContext) IsSingleExpressionContext() {}

func NewSingleExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleExpressionContext {
	var p = new(SingleExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_singleExpression

	return p
}

func (s *SingleExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleExpressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SingleExpressionContext) EOF() antlr.TerminalNode {
	return s.GetToken(KSqlParserEOF, 0)
}

func (s *SingleExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterSingleExpression(s)
	}
}

func (s *SingleExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitSingleExpression(s)
	}
}

func (p *KSqlParser) SingleExpression() (localctx ISingleExpressionContext) {
	localctx = NewSingleExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, KSqlParserRULE_singleExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(145)
		p.Expression()
	}
	{
		p.SetState(146)
		p.Match(KSqlParserEOF)
	}

	return localctx
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_statement
	return p
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) CopyFrom(ctx *StatementContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ListTablesContext struct {
	*StatementContext
}

func NewListTablesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ListTablesContext {
	var p = new(ListTablesContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ListTablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListTablesContext) TABLES() antlr.TerminalNode {
	return s.GetToken(KSqlParserTABLES, 0)
}

func (s *ListTablesContext) LIST() antlr.TerminalNode {
	return s.GetToken(KSqlParserLIST, 0)
}

func (s *ListTablesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(KSqlParserSHOW, 0)
}

func (s *ListTablesContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(KSqlParserEXTENDED, 0)
}

func (s *ListTablesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterListTables(s)
	}
}

func (s *ListTablesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitListTables(s)
	}
}

type DefineVariableContext struct {
	*StatementContext
}

func NewDefineVariableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DefineVariableContext {
	var p = new(DefineVariableContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *DefineVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefineVariableContext) DEFINE() antlr.TerminalNode {
	return s.GetToken(KSqlParserDEFINE, 0)
}

func (s *DefineVariableContext) VariableName() IVariableNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableNameContext)
}

func (s *DefineVariableContext) EQ() antlr.TerminalNode {
	return s.GetToken(KSqlParserEQ, 0)
}

func (s *DefineVariableContext) VariableValue() IVariableValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableValueContext)
}

func (s *DefineVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterDefineVariable(s)
	}
}

func (s *DefineVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitDefineVariable(s)
	}
}

type ExplainContext struct {
	*StatementContext
}

func NewExplainContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExplainContext {
	var p = new(ExplainContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ExplainContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplainContext) EXPLAIN() antlr.TerminalNode {
	return s.GetToken(KSqlParserEXPLAIN, 0)
}

func (s *ExplainContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ExplainContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ExplainContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterExplain(s)
	}
}

func (s *ExplainContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitExplain(s)
	}
}

type CreateTableContext struct {
	*StatementContext
}

func NewCreateTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateTableContext {
	var p = new(CreateTableContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *CreateTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableContext) CREATE() antlr.TerminalNode {
	return s.GetToken(KSqlParserCREATE, 0)
}

func (s *CreateTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(KSqlParserTABLE, 0)
}

func (s *CreateTableContext) SourceName() ISourceNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISourceNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISourceNameContext)
}

func (s *CreateTableContext) OR() antlr.TerminalNode {
	return s.GetToken(KSqlParserOR, 0)
}

func (s *CreateTableContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(KSqlParserREPLACE, 0)
}

func (s *CreateTableContext) SOURCE() antlr.TerminalNode {
	return s.GetToken(KSqlParserSOURCE, 0)
}

func (s *CreateTableContext) IF() antlr.TerminalNode {
	return s.GetToken(KSqlParserIF, 0)
}

func (s *CreateTableContext) NOT() antlr.TerminalNode {
	return s.GetToken(KSqlParserNOT, 0)
}

func (s *CreateTableContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(KSqlParserEXISTS, 0)
}

func (s *CreateTableContext) TableElements() ITableElementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableElementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableElementsContext)
}

func (s *CreateTableContext) WITH() antlr.TerminalNode {
	return s.GetToken(KSqlParserWITH, 0)
}

func (s *CreateTableContext) TableProperties() ITablePropertiesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITablePropertiesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITablePropertiesContext)
}

func (s *CreateTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterCreateTable(s)
	}
}

func (s *CreateTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitCreateTable(s)
	}
}

type UnsetPropertyContext struct {
	*StatementContext
}

func NewUnsetPropertyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnsetPropertyContext {
	var p = new(UnsetPropertyContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *UnsetPropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsetPropertyContext) UNSET() antlr.TerminalNode {
	return s.GetToken(KSqlParserUNSET, 0)
}

func (s *UnsetPropertyContext) STRING() antlr.TerminalNode {
	return s.GetToken(KSqlParserSTRING, 0)
}

func (s *UnsetPropertyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterUnsetProperty(s)
	}
}

func (s *UnsetPropertyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitUnsetProperty(s)
	}
}

type ListTypesContext struct {
	*StatementContext
}

func NewListTypesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ListTypesContext {
	var p = new(ListTypesContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ListTypesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListTypesContext) TYPES() antlr.TerminalNode {
	return s.GetToken(KSqlParserTYPES, 0)
}

func (s *ListTypesContext) LIST() antlr.TerminalNode {
	return s.GetToken(KSqlParserLIST, 0)
}

func (s *ListTypesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(KSqlParserSHOW, 0)
}

func (s *ListTypesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterListTypes(s)
	}
}

func (s *ListTypesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitListTypes(s)
	}
}

type DescribeFunctionContext struct {
	*StatementContext
}

func NewDescribeFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DescribeFunctionContext {
	var p = new(DescribeFunctionContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *DescribeFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescribeFunctionContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(KSqlParserDESCRIBE, 0)
}

func (s *DescribeFunctionContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(KSqlParserFUNCTION, 0)
}

func (s *DescribeFunctionContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DescribeFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterDescribeFunction(s)
	}
}

func (s *DescribeFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitDescribeFunction(s)
	}
}

type RegisterTypeContext struct {
	*StatementContext
}

func NewRegisterTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RegisterTypeContext {
	var p = new(RegisterTypeContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *RegisterTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RegisterTypeContext) CREATE() antlr.TerminalNode {
	return s.GetToken(KSqlParserCREATE, 0)
}

func (s *RegisterTypeContext) TYPE() antlr.TerminalNode {
	return s.GetToken(KSqlParserTYPE, 0)
}

func (s *RegisterTypeContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RegisterTypeContext) AS() antlr.TerminalNode {
	return s.GetToken(KSqlParserAS, 0)
}

func (s *RegisterTypeContext) Sqltype() ISqltypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISqltypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISqltypeContext)
}

func (s *RegisterTypeContext) IF() antlr.TerminalNode {
	return s.GetToken(KSqlParserIF, 0)
}

func (s *RegisterTypeContext) NOT() antlr.TerminalNode {
	return s.GetToken(KSqlParserNOT, 0)
}

func (s *RegisterTypeContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(KSqlParserEXISTS, 0)
}

func (s *RegisterTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterRegisterType(s)
	}
}

func (s *RegisterTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitRegisterType(s)
	}
}

type ListTopicsContext struct {
	*StatementContext
}

func NewListTopicsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ListTopicsContext {
	var p = new(ListTopicsContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ListTopicsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListTopicsContext) TOPICS() antlr.TerminalNode {
	return s.GetToken(KSqlParserTOPICS, 0)
}

func (s *ListTopicsContext) LIST() antlr.TerminalNode {
	return s.GetToken(KSqlParserLIST, 0)
}

func (s *ListTopicsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(KSqlParserSHOW, 0)
}

func (s *ListTopicsContext) ALL() antlr.TerminalNode {
	return s.GetToken(KSqlParserALL, 0)
}

func (s *ListTopicsContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(KSqlParserEXTENDED, 0)
}

func (s *ListTopicsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterListTopics(s)
	}
}

func (s *ListTopicsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitListTopics(s)
	}
}

type ListQueriesContext struct {
	*StatementContext
}

func NewListQueriesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ListQueriesContext {
	var p = new(ListQueriesContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ListQueriesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListQueriesContext) QUERIES() antlr.TerminalNode {
	return s.GetToken(KSqlParserQUERIES, 0)
}

func (s *ListQueriesContext) LIST() antlr.TerminalNode {
	return s.GetToken(KSqlParserLIST, 0)
}

func (s *ListQueriesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(KSqlParserSHOW, 0)
}

func (s *ListQueriesContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(KSqlParserEXTENDED, 0)
}

func (s *ListQueriesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterListQueries(s)
	}
}

func (s *ListQueriesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitListQueries(s)
	}
}

type DropStreamContext struct {
	*StatementContext
}

func NewDropStreamContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropStreamContext {
	var p = new(DropStreamContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *DropStreamContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropStreamContext) DROP() antlr.TerminalNode {
	return s.GetToken(KSqlParserDROP, 0)
}

func (s *DropStreamContext) STREAM() antlr.TerminalNode {
	return s.GetToken(KSqlParserSTREAM, 0)
}

func (s *DropStreamContext) SourceName() ISourceNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISourceNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISourceNameContext)
}

func (s *DropStreamContext) IF() antlr.TerminalNode {
	return s.GetToken(KSqlParserIF, 0)
}

func (s *DropStreamContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(KSqlParserEXISTS, 0)
}

func (s *DropStreamContext) DELETE() antlr.TerminalNode {
	return s.GetToken(KSqlParserDELETE, 0)
}

func (s *DropStreamContext) TOPIC() antlr.TerminalNode {
	return s.GetToken(KSqlParserTOPIC, 0)
}

func (s *DropStreamContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterDropStream(s)
	}
}

func (s *DropStreamContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitDropStream(s)
	}
}

type QueryStatementContext struct {
	*StatementContext
}

func NewQueryStatementContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QueryStatementContext {
	var p = new(QueryStatementContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *QueryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryStatementContext) Query() IQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *QueryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterQueryStatement(s)
	}
}

func (s *QueryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitQueryStatement(s)
	}
}

type CreateStreamAsContext struct {
	*StatementContext
}

func NewCreateStreamAsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateStreamAsContext {
	var p = new(CreateStreamAsContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *CreateStreamAsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateStreamAsContext) CREATE() antlr.TerminalNode {
	return s.GetToken(KSqlParserCREATE, 0)
}

func (s *CreateStreamAsContext) STREAM() antlr.TerminalNode {
	return s.GetToken(KSqlParserSTREAM, 0)
}

func (s *CreateStreamAsContext) SourceName() ISourceNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISourceNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISourceNameContext)
}

func (s *CreateStreamAsContext) AS() antlr.TerminalNode {
	return s.GetToken(KSqlParserAS, 0)
}

func (s *CreateStreamAsContext) Query() IQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *CreateStreamAsContext) OR() antlr.TerminalNode {
	return s.GetToken(KSqlParserOR, 0)
}

func (s *CreateStreamAsContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(KSqlParserREPLACE, 0)
}

func (s *CreateStreamAsContext) IF() antlr.TerminalNode {
	return s.GetToken(KSqlParserIF, 0)
}

func (s *CreateStreamAsContext) NOT() antlr.TerminalNode {
	return s.GetToken(KSqlParserNOT, 0)
}

func (s *CreateStreamAsContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(KSqlParserEXISTS, 0)
}

func (s *CreateStreamAsContext) WITH() antlr.TerminalNode {
	return s.GetToken(KSqlParserWITH, 0)
}

func (s *CreateStreamAsContext) TableProperties() ITablePropertiesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITablePropertiesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITablePropertiesContext)
}

func (s *CreateStreamAsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterCreateStreamAs(s)
	}
}

func (s *CreateStreamAsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitCreateStreamAs(s)
	}
}

type CreateTableAsContext struct {
	*StatementContext
}

func NewCreateTableAsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateTableAsContext {
	var p = new(CreateTableAsContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *CreateTableAsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableAsContext) CREATE() antlr.TerminalNode {
	return s.GetToken(KSqlParserCREATE, 0)
}

func (s *CreateTableAsContext) TABLE() antlr.TerminalNode {
	return s.GetToken(KSqlParserTABLE, 0)
}

func (s *CreateTableAsContext) SourceName() ISourceNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISourceNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISourceNameContext)
}

func (s *CreateTableAsContext) AS() antlr.TerminalNode {
	return s.GetToken(KSqlParserAS, 0)
}

func (s *CreateTableAsContext) Query() IQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *CreateTableAsContext) OR() antlr.TerminalNode {
	return s.GetToken(KSqlParserOR, 0)
}

func (s *CreateTableAsContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(KSqlParserREPLACE, 0)
}

func (s *CreateTableAsContext) IF() antlr.TerminalNode {
	return s.GetToken(KSqlParserIF, 0)
}

func (s *CreateTableAsContext) NOT() antlr.TerminalNode {
	return s.GetToken(KSqlParserNOT, 0)
}

func (s *CreateTableAsContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(KSqlParserEXISTS, 0)
}

func (s *CreateTableAsContext) WITH() antlr.TerminalNode {
	return s.GetToken(KSqlParserWITH, 0)
}

func (s *CreateTableAsContext) TableProperties() ITablePropertiesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITablePropertiesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITablePropertiesContext)
}

func (s *CreateTableAsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterCreateTableAs(s)
	}
}

func (s *CreateTableAsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitCreateTableAs(s)
	}
}

type CreateConnectorContext struct {
	*StatementContext
}

func NewCreateConnectorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateConnectorContext {
	var p = new(CreateConnectorContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *CreateConnectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateConnectorContext) CREATE() antlr.TerminalNode {
	return s.GetToken(KSqlParserCREATE, 0)
}

func (s *CreateConnectorContext) CONNECTOR() antlr.TerminalNode {
	return s.GetToken(KSqlParserCONNECTOR, 0)
}

func (s *CreateConnectorContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateConnectorContext) WITH() antlr.TerminalNode {
	return s.GetToken(KSqlParserWITH, 0)
}

func (s *CreateConnectorContext) TableProperties() ITablePropertiesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITablePropertiesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITablePropertiesContext)
}

func (s *CreateConnectorContext) SINK() antlr.TerminalNode {
	return s.GetToken(KSqlParserSINK, 0)
}

func (s *CreateConnectorContext) SOURCE() antlr.TerminalNode {
	return s.GetToken(KSqlParserSOURCE, 0)
}

func (s *CreateConnectorContext) IF() antlr.TerminalNode {
	return s.GetToken(KSqlParserIF, 0)
}

func (s *CreateConnectorContext) NOT() antlr.TerminalNode {
	return s.GetToken(KSqlParserNOT, 0)
}

func (s *CreateConnectorContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(KSqlParserEXISTS, 0)
}

func (s *CreateConnectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterCreateConnector(s)
	}
}

func (s *CreateConnectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitCreateConnector(s)
	}
}

type CreateStreamContext struct {
	*StatementContext
}

func NewCreateStreamContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CreateStreamContext {
	var p = new(CreateStreamContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *CreateStreamContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateStreamContext) CREATE() antlr.TerminalNode {
	return s.GetToken(KSqlParserCREATE, 0)
}

func (s *CreateStreamContext) STREAM() antlr.TerminalNode {
	return s.GetToken(KSqlParserSTREAM, 0)
}

func (s *CreateStreamContext) SourceName() ISourceNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISourceNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISourceNameContext)
}

func (s *CreateStreamContext) OR() antlr.TerminalNode {
	return s.GetToken(KSqlParserOR, 0)
}

func (s *CreateStreamContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(KSqlParserREPLACE, 0)
}

func (s *CreateStreamContext) SOURCE() antlr.TerminalNode {
	return s.GetToken(KSqlParserSOURCE, 0)
}

func (s *CreateStreamContext) IF() antlr.TerminalNode {
	return s.GetToken(KSqlParserIF, 0)
}

func (s *CreateStreamContext) NOT() antlr.TerminalNode {
	return s.GetToken(KSqlParserNOT, 0)
}

func (s *CreateStreamContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(KSqlParserEXISTS, 0)
}

func (s *CreateStreamContext) TableElements() ITableElementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableElementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableElementsContext)
}

func (s *CreateStreamContext) WITH() antlr.TerminalNode {
	return s.GetToken(KSqlParserWITH, 0)
}

func (s *CreateStreamContext) TableProperties() ITablePropertiesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITablePropertiesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITablePropertiesContext)
}

func (s *CreateStreamContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterCreateStream(s)
	}
}

func (s *CreateStreamContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitCreateStream(s)
	}
}

type ListConnectorsContext struct {
	*StatementContext
}

func NewListConnectorsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ListConnectorsContext {
	var p = new(ListConnectorsContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ListConnectorsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListConnectorsContext) CONNECTORS() antlr.TerminalNode {
	return s.GetToken(KSqlParserCONNECTORS, 0)
}

func (s *ListConnectorsContext) LIST() antlr.TerminalNode {
	return s.GetToken(KSqlParserLIST, 0)
}

func (s *ListConnectorsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(KSqlParserSHOW, 0)
}

func (s *ListConnectorsContext) SOURCE() antlr.TerminalNode {
	return s.GetToken(KSqlParserSOURCE, 0)
}

func (s *ListConnectorsContext) SINK() antlr.TerminalNode {
	return s.GetToken(KSqlParserSINK, 0)
}

func (s *ListConnectorsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterListConnectors(s)
	}
}

func (s *ListConnectorsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitListConnectors(s)
	}
}

type ListVariablesContext struct {
	*StatementContext
}

func NewListVariablesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ListVariablesContext {
	var p = new(ListVariablesContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ListVariablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListVariablesContext) VARIABLES() antlr.TerminalNode {
	return s.GetToken(KSqlParserVARIABLES, 0)
}

func (s *ListVariablesContext) LIST() antlr.TerminalNode {
	return s.GetToken(KSqlParserLIST, 0)
}

func (s *ListVariablesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(KSqlParserSHOW, 0)
}

func (s *ListVariablesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterListVariables(s)
	}
}

func (s *ListVariablesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitListVariables(s)
	}
}

type ListStreamsContext struct {
	*StatementContext
}

func NewListStreamsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ListStreamsContext {
	var p = new(ListStreamsContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ListStreamsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListStreamsContext) STREAMS() antlr.TerminalNode {
	return s.GetToken(KSqlParserSTREAMS, 0)
}

func (s *ListStreamsContext) LIST() antlr.TerminalNode {
	return s.GetToken(KSqlParserLIST, 0)
}

func (s *ListStreamsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(KSqlParserSHOW, 0)
}

func (s *ListStreamsContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(KSqlParserEXTENDED, 0)
}

func (s *ListStreamsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterListStreams(s)
	}
}

func (s *ListStreamsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitListStreams(s)
	}
}

type ShowColumnsContext struct {
	*StatementContext
}

func NewShowColumnsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowColumnsContext {
	var p = new(ShowColumnsContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ShowColumnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowColumnsContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(KSqlParserDESCRIBE, 0)
}

func (s *ShowColumnsContext) SourceName() ISourceNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISourceNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISourceNameContext)
}

func (s *ShowColumnsContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(KSqlParserEXTENDED, 0)
}

func (s *ShowColumnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterShowColumns(s)
	}
}

func (s *ShowColumnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitShowColumns(s)
	}
}

type DropTableContext struct {
	*StatementContext
}

func NewDropTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropTableContext {
	var p = new(DropTableContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *DropTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTableContext) DROP() antlr.TerminalNode {
	return s.GetToken(KSqlParserDROP, 0)
}

func (s *DropTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(KSqlParserTABLE, 0)
}

func (s *DropTableContext) SourceName() ISourceNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISourceNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISourceNameContext)
}

func (s *DropTableContext) IF() antlr.TerminalNode {
	return s.GetToken(KSqlParserIF, 0)
}

func (s *DropTableContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(KSqlParserEXISTS, 0)
}

func (s *DropTableContext) DELETE() antlr.TerminalNode {
	return s.GetToken(KSqlParserDELETE, 0)
}

func (s *DropTableContext) TOPIC() antlr.TerminalNode {
	return s.GetToken(KSqlParserTOPIC, 0)
}

func (s *DropTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterDropTable(s)
	}
}

func (s *DropTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitDropTable(s)
	}
}

type DropConnectorContext struct {
	*StatementContext
}

func NewDropConnectorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropConnectorContext {
	var p = new(DropConnectorContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *DropConnectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropConnectorContext) DROP() antlr.TerminalNode {
	return s.GetToken(KSqlParserDROP, 0)
}

func (s *DropConnectorContext) CONNECTOR() antlr.TerminalNode {
	return s.GetToken(KSqlParserCONNECTOR, 0)
}

func (s *DropConnectorContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropConnectorContext) IF() antlr.TerminalNode {
	return s.GetToken(KSqlParserIF, 0)
}

func (s *DropConnectorContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(KSqlParserEXISTS, 0)
}

func (s *DropConnectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterDropConnector(s)
	}
}

func (s *DropConnectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitDropConnector(s)
	}
}

type ListConnectorPluginsContext struct {
	*StatementContext
}

func NewListConnectorPluginsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ListConnectorPluginsContext {
	var p = new(ListConnectorPluginsContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ListConnectorPluginsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListConnectorPluginsContext) CONNECTOR() antlr.TerminalNode {
	return s.GetToken(KSqlParserCONNECTOR, 0)
}

func (s *ListConnectorPluginsContext) PLUGINS() antlr.TerminalNode {
	return s.GetToken(KSqlParserPLUGINS, 0)
}

func (s *ListConnectorPluginsContext) LIST() antlr.TerminalNode {
	return s.GetToken(KSqlParserLIST, 0)
}

func (s *ListConnectorPluginsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(KSqlParserSHOW, 0)
}

func (s *ListConnectorPluginsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterListConnectorPlugins(s)
	}
}

func (s *ListConnectorPluginsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitListConnectorPlugins(s)
	}
}

type ListFunctionsContext struct {
	*StatementContext
}

func NewListFunctionsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ListFunctionsContext {
	var p = new(ListFunctionsContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ListFunctionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListFunctionsContext) FUNCTIONS() antlr.TerminalNode {
	return s.GetToken(KSqlParserFUNCTIONS, 0)
}

func (s *ListFunctionsContext) LIST() antlr.TerminalNode {
	return s.GetToken(KSqlParserLIST, 0)
}

func (s *ListFunctionsContext) SHOW() antlr.TerminalNode {
	return s.GetToken(KSqlParserSHOW, 0)
}

func (s *ListFunctionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterListFunctions(s)
	}
}

func (s *ListFunctionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitListFunctions(s)
	}
}

type DescribeConnectorContext struct {
	*StatementContext
}

func NewDescribeConnectorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DescribeConnectorContext {
	var p = new(DescribeConnectorContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *DescribeConnectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescribeConnectorContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(KSqlParserDESCRIBE, 0)
}

func (s *DescribeConnectorContext) CONNECTOR() antlr.TerminalNode {
	return s.GetToken(KSqlParserCONNECTOR, 0)
}

func (s *DescribeConnectorContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DescribeConnectorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterDescribeConnector(s)
	}
}

func (s *DescribeConnectorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitDescribeConnector(s)
	}
}

type InsertIntoContext struct {
	*StatementContext
}

func NewInsertIntoContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InsertIntoContext {
	var p = new(InsertIntoContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *InsertIntoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertIntoContext) INSERT() antlr.TerminalNode {
	return s.GetToken(KSqlParserINSERT, 0)
}

func (s *InsertIntoContext) INTO() antlr.TerminalNode {
	return s.GetToken(KSqlParserINTO, 0)
}

func (s *InsertIntoContext) SourceName() ISourceNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISourceNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISourceNameContext)
}

func (s *InsertIntoContext) Query() IQueryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQueryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}

func (s *InsertIntoContext) WITH() antlr.TerminalNode {
	return s.GetToken(KSqlParserWITH, 0)
}

func (s *InsertIntoContext) TableProperties() ITablePropertiesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITablePropertiesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITablePropertiesContext)
}

func (s *InsertIntoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterInsertInto(s)
	}
}

func (s *InsertIntoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitInsertInto(s)
	}
}

type AlterSourceContext struct {
	*StatementContext
}

func NewAlterSourceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AlterSourceContext {
	var p = new(AlterSourceContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *AlterSourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterSourceContext) ALTER() antlr.TerminalNode {
	return s.GetToken(KSqlParserALTER, 0)
}

func (s *AlterSourceContext) SourceName() ISourceNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISourceNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISourceNameContext)
}

func (s *AlterSourceContext) AllAlterOption() []IAlterOptionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAlterOptionContext)(nil)).Elem())
	var tst = make([]IAlterOptionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAlterOptionContext)
		}
	}

	return tst
}

func (s *AlterSourceContext) AlterOption(i int) IAlterOptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlterOptionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAlterOptionContext)
}

func (s *AlterSourceContext) STREAM() antlr.TerminalNode {
	return s.GetToken(KSqlParserSTREAM, 0)
}

func (s *AlterSourceContext) TABLE() antlr.TerminalNode {
	return s.GetToken(KSqlParserTABLE, 0)
}

func (s *AlterSourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterAlterSource(s)
	}
}

func (s *AlterSourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitAlterSource(s)
	}
}

type PrintTopicContext struct {
	*StatementContext
}

func NewPrintTopicContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PrintTopicContext {
	var p = new(PrintTopicContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *PrintTopicContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrintTopicContext) PRINT() antlr.TerminalNode {
	return s.GetToken(KSqlParserPRINT, 0)
}

func (s *PrintTopicContext) PrintClause() IPrintClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrintClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrintClauseContext)
}

func (s *PrintTopicContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PrintTopicContext) STRING() antlr.TerminalNode {
	return s.GetToken(KSqlParserSTRING, 0)
}

func (s *PrintTopicContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterPrintTopic(s)
	}
}

func (s *PrintTopicContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitPrintTopic(s)
	}
}

type ListPropertiesContext struct {
	*StatementContext
}

func NewListPropertiesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ListPropertiesContext {
	var p = new(ListPropertiesContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *ListPropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListPropertiesContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(KSqlParserPROPERTIES, 0)
}

func (s *ListPropertiesContext) LIST() antlr.TerminalNode {
	return s.GetToken(KSqlParserLIST, 0)
}

func (s *ListPropertiesContext) SHOW() antlr.TerminalNode {
	return s.GetToken(KSqlParserSHOW, 0)
}

func (s *ListPropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterListProperties(s)
	}
}

func (s *ListPropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitListProperties(s)
	}
}

type DropTypeContext struct {
	*StatementContext
}

func NewDropTypeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DropTypeContext {
	var p = new(DropTypeContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *DropTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTypeContext) DROP() antlr.TerminalNode {
	return s.GetToken(KSqlParserDROP, 0)
}

func (s *DropTypeContext) TYPE() antlr.TerminalNode {
	return s.GetToken(KSqlParserTYPE, 0)
}

func (s *DropTypeContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropTypeContext) IF() antlr.TerminalNode {
	return s.GetToken(KSqlParserIF, 0)
}

func (s *DropTypeContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(KSqlParserEXISTS, 0)
}

func (s *DropTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterDropType(s)
	}
}

func (s *DropTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitDropType(s)
	}
}

type SetPropertyContext struct {
	*StatementContext
}

func NewSetPropertyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetPropertyContext {
	var p = new(SetPropertyContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *SetPropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetPropertyContext) SET() antlr.TerminalNode {
	return s.GetToken(KSqlParserSET, 0)
}

func (s *SetPropertyContext) AllSTRING() []antlr.TerminalNode {
	return s.GetTokens(KSqlParserSTRING)
}

func (s *SetPropertyContext) STRING(i int) antlr.TerminalNode {
	return s.GetToken(KSqlParserSTRING, i)
}

func (s *SetPropertyContext) EQ() antlr.TerminalNode {
	return s.GetToken(KSqlParserEQ, 0)
}

func (s *SetPropertyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterSetProperty(s)
	}
}

func (s *SetPropertyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitSetProperty(s)
	}
}

type TerminateQueryContext struct {
	*StatementContext
}

func NewTerminateQueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TerminateQueryContext {
	var p = new(TerminateQueryContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *TerminateQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TerminateQueryContext) TERMINATE() antlr.TerminalNode {
	return s.GetToken(KSqlParserTERMINATE, 0)
}

func (s *TerminateQueryContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TerminateQueryContext) ALL() antlr.TerminalNode {
	return s.GetToken(KSqlParserALL, 0)
}

func (s *TerminateQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterTerminateQuery(s)
	}
}

func (s *TerminateQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitTerminateQuery(s)
	}
}

type UndefineVariableContext struct {
	*StatementContext
}

func NewUndefineVariableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UndefineVariableContext {
	var p = new(UndefineVariableContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *UndefineVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UndefineVariableContext) UNDEFINE() antlr.TerminalNode {
	return s.GetToken(KSqlParserUNDEFINE, 0)
}

func (s *UndefineVariableContext) VariableName() IVariableNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariableNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariableNameContext)
}

func (s *UndefineVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterUndefineVariable(s)
	}
}

func (s *UndefineVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitUndefineVariable(s)
	}
}

type InsertValuesContext struct {
	*StatementContext
}

func NewInsertValuesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InsertValuesContext {
	var p = new(InsertValuesContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *InsertValuesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertValuesContext) INSERT() antlr.TerminalNode {
	return s.GetToken(KSqlParserINSERT, 0)
}

func (s *InsertValuesContext) INTO() antlr.TerminalNode {
	return s.GetToken(KSqlParserINTO, 0)
}

func (s *InsertValuesContext) SourceName() ISourceNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISourceNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISourceNameContext)
}

func (s *InsertValuesContext) VALUES() antlr.TerminalNode {
	return s.GetToken(KSqlParserVALUES, 0)
}

func (s *InsertValuesContext) Values() IValuesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValuesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValuesContext)
}

func (s *InsertValuesContext) Columns() IColumnsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnsContext)
}

func (s *InsertValuesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterInsertValues(s)
	}
}

func (s *InsertValuesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitInsertValues(s)
	}
}

type DescribeStreamsContext struct {
	*StatementContext
}

func NewDescribeStreamsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DescribeStreamsContext {
	var p = new(DescribeStreamsContext)

	p.StatementContext = NewEmptyStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*StatementContext))

	return p
}

func (s *DescribeStreamsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescribeStreamsContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(KSqlParserDESCRIBE, 0)
}

func (s *DescribeStreamsContext) STREAMS() antlr.TerminalNode {
	return s.GetToken(KSqlParserSTREAMS, 0)
}

func (s *DescribeStreamsContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(KSqlParserEXTENDED, 0)
}

func (s *DescribeStreamsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterDescribeStreams(s)
	}
}

func (s *DescribeStreamsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitDescribeStreams(s)
	}
}

func (p *KSqlParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, KSqlParserRULE_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(402)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 40, p.GetParserRuleContext()) {
	case 1:
		localctx = NewQueryStatementContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(148)
			p.Query()
		}

	case 2:
		localctx = NewListPropertiesContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(149)
			_la = p.GetTokenStream().LA(1)

			if !(_la == KSqlParserSHOW || _la == KSqlParserLIST) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(150)
			p.Match(KSqlParserPROPERTIES)
		}

	case 3:
		localctx = NewListTopicsContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(151)
			_la = p.GetTokenStream().LA(1)

			if !(_la == KSqlParserSHOW || _la == KSqlParserLIST) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(153)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserALL {
			{
				p.SetState(152)
				p.Match(KSqlParserALL)
			}

		}
		{
			p.SetState(155)
			p.Match(KSqlParserTOPICS)
		}
		p.SetState(157)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserEXTENDED {
			{
				p.SetState(156)
				p.Match(KSqlParserEXTENDED)
			}

		}

	case 4:
		localctx = NewListStreamsContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(159)
			_la = p.GetTokenStream().LA(1)

			if !(_la == KSqlParserSHOW || _la == KSqlParserLIST) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(160)
			p.Match(KSqlParserSTREAMS)
		}
		p.SetState(162)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserEXTENDED {
			{
				p.SetState(161)
				p.Match(KSqlParserEXTENDED)
			}

		}

	case 5:
		localctx = NewListTablesContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(164)
			_la = p.GetTokenStream().LA(1)

			if !(_la == KSqlParserSHOW || _la == KSqlParserLIST) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(165)
			p.Match(KSqlParserTABLES)
		}
		p.SetState(167)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserEXTENDED {
			{
				p.SetState(166)
				p.Match(KSqlParserEXTENDED)
			}

		}

	case 6:
		localctx = NewListFunctionsContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(169)
			_la = p.GetTokenStream().LA(1)

			if !(_la == KSqlParserSHOW || _la == KSqlParserLIST) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(170)
			p.Match(KSqlParserFUNCTIONS)
		}

	case 7:
		localctx = NewListConnectorsContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(171)
			_la = p.GetTokenStream().LA(1)

			if !(_la == KSqlParserSHOW || _la == KSqlParserLIST) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(173)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserSINK || _la == KSqlParserSOURCE {
			{
				p.SetState(172)
				_la = p.GetTokenStream().LA(1)

				if !(_la == KSqlParserSINK || _la == KSqlParserSOURCE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(175)
			p.Match(KSqlParserCONNECTORS)
		}

	case 8:
		localctx = NewListConnectorPluginsContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(176)
			_la = p.GetTokenStream().LA(1)

			if !(_la == KSqlParserSHOW || _la == KSqlParserLIST) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(177)
			p.Match(KSqlParserCONNECTOR)
		}
		{
			p.SetState(178)
			p.Match(KSqlParserPLUGINS)
		}

	case 9:
		localctx = NewListTypesContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(179)
			_la = p.GetTokenStream().LA(1)

			if !(_la == KSqlParserSHOW || _la == KSqlParserLIST) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(180)
			p.Match(KSqlParserTYPES)
		}

	case 10:
		localctx = NewListVariablesContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(181)
			_la = p.GetTokenStream().LA(1)

			if !(_la == KSqlParserSHOW || _la == KSqlParserLIST) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(182)
			p.Match(KSqlParserVARIABLES)
		}

	case 11:
		localctx = NewShowColumnsContext(p, localctx)
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(183)
			p.Match(KSqlParserDESCRIBE)
		}
		{
			p.SetState(184)
			p.SourceName()
		}
		p.SetState(186)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserEXTENDED {
			{
				p.SetState(185)
				p.Match(KSqlParserEXTENDED)
			}

		}

	case 12:
		localctx = NewDescribeStreamsContext(p, localctx)
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(188)
			p.Match(KSqlParserDESCRIBE)
		}
		{
			p.SetState(189)
			p.Match(KSqlParserSTREAMS)
		}
		p.SetState(191)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserEXTENDED {
			{
				p.SetState(190)
				p.Match(KSqlParserEXTENDED)
			}

		}

	case 13:
		localctx = NewDescribeFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(193)
			p.Match(KSqlParserDESCRIBE)
		}
		{
			p.SetState(194)
			p.Match(KSqlParserFUNCTION)
		}
		{
			p.SetState(195)
			p.Identifier()
		}

	case 14:
		localctx = NewDescribeConnectorContext(p, localctx)
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(196)
			p.Match(KSqlParserDESCRIBE)
		}
		{
			p.SetState(197)
			p.Match(KSqlParserCONNECTOR)
		}
		{
			p.SetState(198)
			p.Identifier()
		}

	case 15:
		localctx = NewPrintTopicContext(p, localctx)
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(199)
			p.Match(KSqlParserPRINT)
		}
		p.SetState(202)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case KSqlParserT__7, KSqlParserEMIT, KSqlParserCHANGES, KSqlParserFINAL, KSqlParserESCAPE, KSqlParserINTEGER, KSqlParserDATE, KSqlParserTIME, KSqlParserTIMESTAMP, KSqlParserINTERVAL, KSqlParserYEAR, KSqlParserMONTH, KSqlParserDAY, KSqlParserHOUR, KSqlParserMINUTE, KSqlParserSECOND, KSqlParserZONE, KSqlParserPARTITION, KSqlParserSTRUCT, KSqlParserEXPLAIN, KSqlParserANALYZE, KSqlParserTYPE, KSqlParserTYPES, KSqlParserSHOW, KSqlParserTABLES, KSqlParserCOLUMNS, KSqlParserCOLUMN, KSqlParserPARTITIONS, KSqlParserFUNCTIONS, KSqlParserFUNCTION, KSqlParserARRAY, KSqlParserMAP, KSqlParserSET, KSqlParserRESET, KSqlParserSESSION, KSqlParserKEY, KSqlParserSINK, KSqlParserSOURCE, KSqlParserPRIMARY, KSqlParserREPLACE, KSqlParserASSERT, KSqlParserADD, KSqlParserALTER, KSqlParserIF, KSqlParserIDENTIFIER, KSqlParserDIGIT_IDENTIFIER, KSqlParserQUOTED_IDENTIFIER, KSqlParserBACKQUOTED_IDENTIFIER, KSqlParserVARIABLE:
			{
				p.SetState(200)
				p.Identifier()
			}

		case KSqlParserSTRING:
			{
				p.SetState(201)
				p.Match(KSqlParserSTRING)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		{
			p.SetState(204)
			p.PrintClause()
		}

	case 16:
		localctx = NewListQueriesContext(p, localctx)
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(205)
			_la = p.GetTokenStream().LA(1)

			if !(_la == KSqlParserSHOW || _la == KSqlParserLIST) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(206)
			p.Match(KSqlParserQUERIES)
		}
		p.SetState(208)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserEXTENDED {
			{
				p.SetState(207)
				p.Match(KSqlParserEXTENDED)
			}

		}

	case 17:
		localctx = NewTerminateQueryContext(p, localctx)
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(210)
			p.Match(KSqlParserTERMINATE)
		}
		{
			p.SetState(211)
			p.Identifier()
		}

	case 18:
		localctx = NewTerminateQueryContext(p, localctx)
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(212)
			p.Match(KSqlParserTERMINATE)
		}
		{
			p.SetState(213)
			p.Match(KSqlParserALL)
		}

	case 19:
		localctx = NewSetPropertyContext(p, localctx)
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(214)
			p.Match(KSqlParserSET)
		}
		{
			p.SetState(215)
			p.Match(KSqlParserSTRING)
		}
		{
			p.SetState(216)
			p.Match(KSqlParserEQ)
		}
		{
			p.SetState(217)
			p.Match(KSqlParserSTRING)
		}

	case 20:
		localctx = NewUnsetPropertyContext(p, localctx)
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(218)
			p.Match(KSqlParserUNSET)
		}
		{
			p.SetState(219)
			p.Match(KSqlParserSTRING)
		}

	case 21:
		localctx = NewDefineVariableContext(p, localctx)
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(220)
			p.Match(KSqlParserDEFINE)
		}
		{
			p.SetState(221)
			p.VariableName()
		}
		{
			p.SetState(222)
			p.Match(KSqlParserEQ)
		}
		{
			p.SetState(223)
			p.VariableValue()
		}

	case 22:
		localctx = NewUndefineVariableContext(p, localctx)
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(225)
			p.Match(KSqlParserUNDEFINE)
		}
		{
			p.SetState(226)
			p.VariableName()
		}

	case 23:
		localctx = NewCreateStreamContext(p, localctx)
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(227)
			p.Match(KSqlParserCREATE)
		}
		p.SetState(230)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserOR {
			{
				p.SetState(228)
				p.Match(KSqlParserOR)
			}
			{
				p.SetState(229)
				p.Match(KSqlParserREPLACE)
			}

		}
		p.SetState(233)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserSOURCE {
			{
				p.SetState(232)
				p.Match(KSqlParserSOURCE)
			}

		}
		{
			p.SetState(235)
			p.Match(KSqlParserSTREAM)
		}
		p.SetState(239)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 14, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(236)
				p.Match(KSqlParserIF)
			}
			{
				p.SetState(237)
				p.Match(KSqlParserNOT)
			}
			{
				p.SetState(238)
				p.Match(KSqlParserEXISTS)
			}

		}
		{
			p.SetState(241)
			p.SourceName()
		}
		p.SetState(243)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserT__2 {
			{
				p.SetState(242)
				p.TableElements()
			}

		}
		p.SetState(247)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserWITH {
			{
				p.SetState(245)
				p.Match(KSqlParserWITH)
			}
			{
				p.SetState(246)
				p.TableProperties()
			}

		}

	case 24:
		localctx = NewCreateStreamAsContext(p, localctx)
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(249)
			p.Match(KSqlParserCREATE)
		}
		p.SetState(252)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserOR {
			{
				p.SetState(250)
				p.Match(KSqlParserOR)
			}
			{
				p.SetState(251)
				p.Match(KSqlParserREPLACE)
			}

		}
		{
			p.SetState(254)
			p.Match(KSqlParserSTREAM)
		}
		p.SetState(258)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 18, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(255)
				p.Match(KSqlParserIF)
			}
			{
				p.SetState(256)
				p.Match(KSqlParserNOT)
			}
			{
				p.SetState(257)
				p.Match(KSqlParserEXISTS)
			}

		}
		{
			p.SetState(260)
			p.SourceName()
		}
		p.SetState(263)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserWITH {
			{
				p.SetState(261)
				p.Match(KSqlParserWITH)
			}
			{
				p.SetState(262)
				p.TableProperties()
			}

		}
		{
			p.SetState(265)
			p.Match(KSqlParserAS)
		}
		{
			p.SetState(266)
			p.Query()
		}

	case 25:
		localctx = NewCreateTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(268)
			p.Match(KSqlParserCREATE)
		}
		p.SetState(271)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserOR {
			{
				p.SetState(269)
				p.Match(KSqlParserOR)
			}
			{
				p.SetState(270)
				p.Match(KSqlParserREPLACE)
			}

		}
		p.SetState(274)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserSOURCE {
			{
				p.SetState(273)
				p.Match(KSqlParserSOURCE)
			}

		}
		{
			p.SetState(276)
			p.Match(KSqlParserTABLE)
		}
		p.SetState(280)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 22, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(277)
				p.Match(KSqlParserIF)
			}
			{
				p.SetState(278)
				p.Match(KSqlParserNOT)
			}
			{
				p.SetState(279)
				p.Match(KSqlParserEXISTS)
			}

		}
		{
			p.SetState(282)
			p.SourceName()
		}
		p.SetState(284)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserT__2 {
			{
				p.SetState(283)
				p.TableElements()
			}

		}
		p.SetState(288)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserWITH {
			{
				p.SetState(286)
				p.Match(KSqlParserWITH)
			}
			{
				p.SetState(287)
				p.TableProperties()
			}

		}

	case 26:
		localctx = NewCreateTableAsContext(p, localctx)
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(290)
			p.Match(KSqlParserCREATE)
		}
		p.SetState(293)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserOR {
			{
				p.SetState(291)
				p.Match(KSqlParserOR)
			}
			{
				p.SetState(292)
				p.Match(KSqlParserREPLACE)
			}

		}
		{
			p.SetState(295)
			p.Match(KSqlParserTABLE)
		}
		p.SetState(299)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 26, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(296)
				p.Match(KSqlParserIF)
			}
			{
				p.SetState(297)
				p.Match(KSqlParserNOT)
			}
			{
				p.SetState(298)
				p.Match(KSqlParserEXISTS)
			}

		}
		{
			p.SetState(301)
			p.SourceName()
		}
		p.SetState(304)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserWITH {
			{
				p.SetState(302)
				p.Match(KSqlParserWITH)
			}
			{
				p.SetState(303)
				p.TableProperties()
			}

		}
		{
			p.SetState(306)
			p.Match(KSqlParserAS)
		}
		{
			p.SetState(307)
			p.Query()
		}

	case 27:
		localctx = NewCreateConnectorContext(p, localctx)
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(309)
			p.Match(KSqlParserCREATE)
		}
		{
			p.SetState(310)
			_la = p.GetTokenStream().LA(1)

			if !(_la == KSqlParserSINK || _la == KSqlParserSOURCE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(311)
			p.Match(KSqlParserCONNECTOR)
		}
		p.SetState(315)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 28, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(312)
				p.Match(KSqlParserIF)
			}
			{
				p.SetState(313)
				p.Match(KSqlParserNOT)
			}
			{
				p.SetState(314)
				p.Match(KSqlParserEXISTS)
			}

		}
		{
			p.SetState(317)
			p.Identifier()
		}
		{
			p.SetState(318)
			p.Match(KSqlParserWITH)
		}
		{
			p.SetState(319)
			p.TableProperties()
		}

	case 28:
		localctx = NewInsertIntoContext(p, localctx)
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(321)
			p.Match(KSqlParserINSERT)
		}
		{
			p.SetState(322)
			p.Match(KSqlParserINTO)
		}
		{
			p.SetState(323)
			p.SourceName()
		}
		p.SetState(326)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserWITH {
			{
				p.SetState(324)
				p.Match(KSqlParserWITH)
			}
			{
				p.SetState(325)
				p.TableProperties()
			}

		}
		{
			p.SetState(328)
			p.Query()
		}

	case 29:
		localctx = NewInsertValuesContext(p, localctx)
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(330)
			p.Match(KSqlParserINSERT)
		}
		{
			p.SetState(331)
			p.Match(KSqlParserINTO)
		}
		{
			p.SetState(332)
			p.SourceName()
		}
		p.SetState(334)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserT__2 {
			{
				p.SetState(333)
				p.Columns()
			}

		}
		{
			p.SetState(336)
			p.Match(KSqlParserVALUES)
		}
		{
			p.SetState(337)
			p.Values()
		}

	case 30:
		localctx = NewDropStreamContext(p, localctx)
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(339)
			p.Match(KSqlParserDROP)
		}
		{
			p.SetState(340)
			p.Match(KSqlParserSTREAM)
		}
		p.SetState(343)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 31, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(341)
				p.Match(KSqlParserIF)
			}
			{
				p.SetState(342)
				p.Match(KSqlParserEXISTS)
			}

		}
		{
			p.SetState(345)
			p.SourceName()
		}
		p.SetState(348)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserDELETE {
			{
				p.SetState(346)
				p.Match(KSqlParserDELETE)
			}
			{
				p.SetState(347)
				p.Match(KSqlParserTOPIC)
			}

		}

	case 31:
		localctx = NewDropTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(350)
			p.Match(KSqlParserDROP)
		}
		{
			p.SetState(351)
			p.Match(KSqlParserTABLE)
		}
		p.SetState(354)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 33, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(352)
				p.Match(KSqlParserIF)
			}
			{
				p.SetState(353)
				p.Match(KSqlParserEXISTS)
			}

		}
		{
			p.SetState(356)
			p.SourceName()
		}
		p.SetState(359)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserDELETE {
			{
				p.SetState(357)
				p.Match(KSqlParserDELETE)
			}
			{
				p.SetState(358)
				p.Match(KSqlParserTOPIC)
			}

		}

	case 32:
		localctx = NewDropConnectorContext(p, localctx)
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(361)
			p.Match(KSqlParserDROP)
		}
		{
			p.SetState(362)
			p.Match(KSqlParserCONNECTOR)
		}
		p.SetState(365)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 35, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(363)
				p.Match(KSqlParserIF)
			}
			{
				p.SetState(364)
				p.Match(KSqlParserEXISTS)
			}

		}
		{
			p.SetState(367)
			p.Identifier()
		}

	case 33:
		localctx = NewExplainContext(p, localctx)
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(368)
			p.Match(KSqlParserEXPLAIN)
		}
		p.SetState(371)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 36, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(369)
				p.Statement()
			}

		case 2:
			{
				p.SetState(370)
				p.Identifier()
			}

		}

	case 34:
		localctx = NewRegisterTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(373)
			p.Match(KSqlParserCREATE)
		}
		{
			p.SetState(374)
			p.Match(KSqlParserTYPE)
		}
		p.SetState(378)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 37, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(375)
				p.Match(KSqlParserIF)
			}
			{
				p.SetState(376)
				p.Match(KSqlParserNOT)
			}
			{
				p.SetState(377)
				p.Match(KSqlParserEXISTS)
			}

		}
		{
			p.SetState(380)
			p.Identifier()
		}
		{
			p.SetState(381)
			p.Match(KSqlParserAS)
		}
		{
			p.SetState(382)
			p.sqltype(0)
		}

	case 35:
		localctx = NewDropTypeContext(p, localctx)
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(384)
			p.Match(KSqlParserDROP)
		}
		{
			p.SetState(385)
			p.Match(KSqlParserTYPE)
		}
		p.SetState(388)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 38, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(386)
				p.Match(KSqlParserIF)
			}
			{
				p.SetState(387)
				p.Match(KSqlParserEXISTS)
			}

		}
		{
			p.SetState(390)
			p.Identifier()
		}

	case 36:
		localctx = NewAlterSourceContext(p, localctx)
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(391)
			p.Match(KSqlParserALTER)
		}
		{
			p.SetState(392)
			_la = p.GetTokenStream().LA(1)

			if !(_la == KSqlParserTABLE || _la == KSqlParserSTREAM) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(393)
			p.SourceName()
		}
		{
			p.SetState(394)
			p.AlterOption()
		}
		p.SetState(399)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KSqlParserT__1 {
			{
				p.SetState(395)
				p.Match(KSqlParserT__1)
			}
			{
				p.SetState(396)
				p.AlterOption()
			}

			p.SetState(401)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IAssertStatementContext is an interface to support dynamic dispatch.
type IAssertStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssertStatementContext differentiates from other interfaces.
	IsAssertStatementContext()
}

type AssertStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssertStatementContext() *AssertStatementContext {
	var p = new(AssertStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_assertStatement
	return p
}

func (*AssertStatementContext) IsAssertStatementContext() {}

func NewAssertStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssertStatementContext {
	var p = new(AssertStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_assertStatement

	return p
}

func (s *AssertStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AssertStatementContext) CopyFrom(ctx *AssertStatementContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *AssertStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssertStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type AssertValuesContext struct {
	*AssertStatementContext
}

func NewAssertValuesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AssertValuesContext {
	var p = new(AssertValuesContext)

	p.AssertStatementContext = NewEmptyAssertStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AssertStatementContext))

	return p
}

func (s *AssertValuesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssertValuesContext) ASSERT() antlr.TerminalNode {
	return s.GetToken(KSqlParserASSERT, 0)
}

func (s *AssertValuesContext) AllVALUES() []antlr.TerminalNode {
	return s.GetTokens(KSqlParserVALUES)
}

func (s *AssertValuesContext) VALUES(i int) antlr.TerminalNode {
	return s.GetToken(KSqlParserVALUES, i)
}

func (s *AssertValuesContext) SourceName() ISourceNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISourceNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISourceNameContext)
}

func (s *AssertValuesContext) Values() IValuesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValuesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValuesContext)
}

func (s *AssertValuesContext) Columns() IColumnsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnsContext)
}

func (s *AssertValuesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterAssertValues(s)
	}
}

func (s *AssertValuesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitAssertValues(s)
	}
}

type AssertTombstoneContext struct {
	*AssertStatementContext
}

func NewAssertTombstoneContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AssertTombstoneContext {
	var p = new(AssertTombstoneContext)

	p.AssertStatementContext = NewEmptyAssertStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AssertStatementContext))

	return p
}

func (s *AssertTombstoneContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssertTombstoneContext) ASSERT() antlr.TerminalNode {
	return s.GetToken(KSqlParserASSERT, 0)
}

func (s *AssertTombstoneContext) NULL() antlr.TerminalNode {
	return s.GetToken(KSqlParserNULL, 0)
}

func (s *AssertTombstoneContext) VALUES() antlr.TerminalNode {
	return s.GetToken(KSqlParserVALUES, 0)
}

func (s *AssertTombstoneContext) SourceName() ISourceNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISourceNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISourceNameContext)
}

func (s *AssertTombstoneContext) KEY() antlr.TerminalNode {
	return s.GetToken(KSqlParserKEY, 0)
}

func (s *AssertTombstoneContext) Values() IValuesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValuesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValuesContext)
}

func (s *AssertTombstoneContext) Columns() IColumnsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnsContext)
}

func (s *AssertTombstoneContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterAssertTombstone(s)
	}
}

func (s *AssertTombstoneContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitAssertTombstone(s)
	}
}

type AssertTableContext struct {
	*AssertStatementContext
}

func NewAssertTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AssertTableContext {
	var p = new(AssertTableContext)

	p.AssertStatementContext = NewEmptyAssertStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AssertStatementContext))

	return p
}

func (s *AssertTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssertTableContext) ASSERT() antlr.TerminalNode {
	return s.GetToken(KSqlParserASSERT, 0)
}

func (s *AssertTableContext) TABLE() antlr.TerminalNode {
	return s.GetToken(KSqlParserTABLE, 0)
}

func (s *AssertTableContext) SourceName() ISourceNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISourceNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISourceNameContext)
}

func (s *AssertTableContext) TableElements() ITableElementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableElementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableElementsContext)
}

func (s *AssertTableContext) WITH() antlr.TerminalNode {
	return s.GetToken(KSqlParserWITH, 0)
}

func (s *AssertTableContext) TableProperties() ITablePropertiesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITablePropertiesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITablePropertiesContext)
}

func (s *AssertTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterAssertTable(s)
	}
}

func (s *AssertTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitAssertTable(s)
	}
}

type AssertStreamContext struct {
	*AssertStatementContext
}

func NewAssertStreamContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AssertStreamContext {
	var p = new(AssertStreamContext)

	p.AssertStatementContext = NewEmptyAssertStatementContext()
	p.parser = parser
	p.CopyFrom(ctx.(*AssertStatementContext))

	return p
}

func (s *AssertStreamContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssertStreamContext) ASSERT() antlr.TerminalNode {
	return s.GetToken(KSqlParserASSERT, 0)
}

func (s *AssertStreamContext) STREAM() antlr.TerminalNode {
	return s.GetToken(KSqlParserSTREAM, 0)
}

func (s *AssertStreamContext) SourceName() ISourceNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISourceNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISourceNameContext)
}

func (s *AssertStreamContext) TableElements() ITableElementsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableElementsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITableElementsContext)
}

func (s *AssertStreamContext) WITH() antlr.TerminalNode {
	return s.GetToken(KSqlParserWITH, 0)
}

func (s *AssertStreamContext) TableProperties() ITablePropertiesContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITablePropertiesContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITablePropertiesContext)
}

func (s *AssertStreamContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterAssertStream(s)
	}
}

func (s *AssertStreamContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitAssertStream(s)
	}
}

func (p *KSqlParser) AssertStatement() (localctx IAssertStatementContext) {
	localctx = NewAssertStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, KSqlParserRULE_assertStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(443)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 47, p.GetParserRuleContext()) {
	case 1:
		localctx = NewAssertValuesContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(404)
			p.Match(KSqlParserASSERT)
		}
		{
			p.SetState(405)
			p.Match(KSqlParserVALUES)
		}
		{
			p.SetState(406)
			p.SourceName()
		}
		p.SetState(408)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserT__2 {
			{
				p.SetState(407)
				p.Columns()
			}

		}
		{
			p.SetState(410)
			p.Match(KSqlParserVALUES)
		}
		{
			p.SetState(411)
			p.Values()
		}

	case 2:
		localctx = NewAssertTombstoneContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(413)
			p.Match(KSqlParserASSERT)
		}
		{
			p.SetState(414)
			p.Match(KSqlParserNULL)
		}
		{
			p.SetState(415)
			p.Match(KSqlParserVALUES)
		}
		{
			p.SetState(416)
			p.SourceName()
		}
		p.SetState(418)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserT__2 {
			{
				p.SetState(417)
				p.Columns()
			}

		}
		{
			p.SetState(420)
			p.Match(KSqlParserKEY)
		}
		{
			p.SetState(421)
			p.Values()
		}

	case 3:
		localctx = NewAssertStreamContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(423)
			p.Match(KSqlParserASSERT)
		}
		{
			p.SetState(424)
			p.Match(KSqlParserSTREAM)
		}
		{
			p.SetState(425)
			p.SourceName()
		}
		p.SetState(427)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserT__2 {
			{
				p.SetState(426)
				p.TableElements()
			}

		}
		p.SetState(431)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserWITH {
			{
				p.SetState(429)
				p.Match(KSqlParserWITH)
			}
			{
				p.SetState(430)
				p.TableProperties()
			}

		}

	case 4:
		localctx = NewAssertTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(433)
			p.Match(KSqlParserASSERT)
		}
		{
			p.SetState(434)
			p.Match(KSqlParserTABLE)
		}
		{
			p.SetState(435)
			p.SourceName()
		}
		p.SetState(437)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserT__2 {
			{
				p.SetState(436)
				p.TableElements()
			}

		}
		p.SetState(441)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserWITH {
			{
				p.SetState(439)
				p.Match(KSqlParserWITH)
			}
			{
				p.SetState(440)
				p.TableProperties()
			}

		}

	}

	return localctx
}

// IRunScriptContext is an interface to support dynamic dispatch.
type IRunScriptContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRunScriptContext differentiates from other interfaces.
	IsRunScriptContext()
}

type RunScriptContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRunScriptContext() *RunScriptContext {
	var p = new(RunScriptContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_runScript
	return p
}

func (*RunScriptContext) IsRunScriptContext() {}

func NewRunScriptContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RunScriptContext {
	var p = new(RunScriptContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_runScript

	return p
}

func (s *RunScriptContext) GetParser() antlr.Parser { return s.parser }

func (s *RunScriptContext) RUN() antlr.TerminalNode {
	return s.GetToken(KSqlParserRUN, 0)
}

func (s *RunScriptContext) SCRIPT() antlr.TerminalNode {
	return s.GetToken(KSqlParserSCRIPT, 0)
}

func (s *RunScriptContext) STRING() antlr.TerminalNode {
	return s.GetToken(KSqlParserSTRING, 0)
}

func (s *RunScriptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RunScriptContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RunScriptContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterRunScript(s)
	}
}

func (s *RunScriptContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitRunScript(s)
	}
}

func (p *KSqlParser) RunScript() (localctx IRunScriptContext) {
	localctx = NewRunScriptContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, KSqlParserRULE_runScript)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(445)
		p.Match(KSqlParserRUN)
	}
	{
		p.SetState(446)
		p.Match(KSqlParserSCRIPT)
	}
	{
		p.SetState(447)
		p.Match(KSqlParserSTRING)
	}

	return localctx
}

// IQueryContext is an interface to support dynamic dispatch.
type IQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFrom returns the from rule contexts.
	GetFrom() IRelationContext

	// GetWhere returns the where rule contexts.
	GetWhere() IBooleanExpressionContext

	// GetHaving returns the having rule contexts.
	GetHaving() IBooleanExpressionContext

	// SetFrom sets the from rule contexts.
	SetFrom(IRelationContext)

	// SetWhere sets the where rule contexts.
	SetWhere(IBooleanExpressionContext)

	// SetHaving sets the having rule contexts.
	SetHaving(IBooleanExpressionContext)

	// IsQueryContext differentiates from other interfaces.
	IsQueryContext()
}

type QueryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	from   IRelationContext
	where  IBooleanExpressionContext
	having IBooleanExpressionContext
}

func NewEmptyQueryContext() *QueryContext {
	var p = new(QueryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_query
	return p
}

func (*QueryContext) IsQueryContext() {}

func NewQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryContext {
	var p = new(QueryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_query

	return p
}

func (s *QueryContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryContext) GetFrom() IRelationContext { return s.from }

func (s *QueryContext) GetWhere() IBooleanExpressionContext { return s.where }

func (s *QueryContext) GetHaving() IBooleanExpressionContext { return s.having }

func (s *QueryContext) SetFrom(v IRelationContext) { s.from = v }

func (s *QueryContext) SetWhere(v IBooleanExpressionContext) { s.where = v }

func (s *QueryContext) SetHaving(v IBooleanExpressionContext) { s.having = v }

func (s *QueryContext) SELECT() antlr.TerminalNode {
	return s.GetToken(KSqlParserSELECT, 0)
}

func (s *QueryContext) AllSelectItem() []ISelectItemContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISelectItemContext)(nil)).Elem())
	var tst = make([]ISelectItemContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISelectItemContext)
		}
	}

	return tst
}

func (s *QueryContext) SelectItem(i int) ISelectItemContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISelectItemContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISelectItemContext)
}

func (s *QueryContext) FROM() antlr.TerminalNode {
	return s.GetToken(KSqlParserFROM, 0)
}

func (s *QueryContext) Relation() IRelationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRelationContext)
}

func (s *QueryContext) WINDOW() antlr.TerminalNode {
	return s.GetToken(KSqlParserWINDOW, 0)
}

func (s *QueryContext) WindowExpression() IWindowExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWindowExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWindowExpressionContext)
}

func (s *QueryContext) WHERE() antlr.TerminalNode {
	return s.GetToken(KSqlParserWHERE, 0)
}

func (s *QueryContext) GROUP() antlr.TerminalNode {
	return s.GetToken(KSqlParserGROUP, 0)
}

func (s *QueryContext) AllBY() []antlr.TerminalNode {
	return s.GetTokens(KSqlParserBY)
}

func (s *QueryContext) BY(i int) antlr.TerminalNode {
	return s.GetToken(KSqlParserBY, i)
}

func (s *QueryContext) GroupBy() IGroupByContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroupByContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGroupByContext)
}

func (s *QueryContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(KSqlParserPARTITION, 0)
}

func (s *QueryContext) PartitionBy() IPartitionByContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPartitionByContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPartitionByContext)
}

func (s *QueryContext) HAVING() antlr.TerminalNode {
	return s.GetToken(KSqlParserHAVING, 0)
}

func (s *QueryContext) EMIT() antlr.TerminalNode {
	return s.GetToken(KSqlParserEMIT, 0)
}

func (s *QueryContext) ResultMaterialization() IResultMaterializationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IResultMaterializationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IResultMaterializationContext)
}

func (s *QueryContext) LimitClause() ILimitClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILimitClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *QueryContext) AllBooleanExpression() []IBooleanExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBooleanExpressionContext)(nil)).Elem())
	var tst = make([]IBooleanExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBooleanExpressionContext)
		}
	}

	return tst
}

func (s *QueryContext) BooleanExpression(i int) IBooleanExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *QueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterQuery(s)
	}
}

func (s *QueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitQuery(s)
	}
}

func (p *KSqlParser) Query() (localctx IQueryContext) {
	localctx = NewQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, KSqlParserRULE_query)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(449)
		p.Match(KSqlParserSELECT)
	}
	{
		p.SetState(450)
		p.SelectItem()
	}
	p.SetState(455)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KSqlParserT__1 {
		{
			p.SetState(451)
			p.Match(KSqlParserT__1)
		}
		{
			p.SetState(452)
			p.SelectItem()
		}

		p.SetState(457)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(458)
		p.Match(KSqlParserFROM)
	}
	{
		p.SetState(459)

		var _x = p.Relation()

		localctx.(*QueryContext).from = _x
	}
	p.SetState(462)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KSqlParserWINDOW {
		{
			p.SetState(460)
			p.Match(KSqlParserWINDOW)
		}
		{
			p.SetState(461)
			p.WindowExpression()
		}

	}
	p.SetState(466)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KSqlParserWHERE {
		{
			p.SetState(464)
			p.Match(KSqlParserWHERE)
		}
		{
			p.SetState(465)

			var _x = p.booleanExpression(0)

			localctx.(*QueryContext).where = _x
		}

	}
	p.SetState(471)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KSqlParserGROUP {
		{
			p.SetState(468)
			p.Match(KSqlParserGROUP)
		}
		{
			p.SetState(469)
			p.Match(KSqlParserBY)
		}
		{
			p.SetState(470)
			p.GroupBy()
		}

	}
	p.SetState(476)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KSqlParserPARTITION {
		{
			p.SetState(473)
			p.Match(KSqlParserPARTITION)
		}
		{
			p.SetState(474)
			p.Match(KSqlParserBY)
		}
		{
			p.SetState(475)
			p.PartitionBy()
		}

	}
	p.SetState(480)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KSqlParserHAVING {
		{
			p.SetState(478)
			p.Match(KSqlParserHAVING)
		}
		{
			p.SetState(479)

			var _x = p.booleanExpression(0)

			localctx.(*QueryContext).having = _x
		}

	}
	p.SetState(484)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KSqlParserEMIT {
		{
			p.SetState(482)
			p.Match(KSqlParserEMIT)
		}
		{
			p.SetState(483)
			p.ResultMaterialization()
		}

	}
	p.SetState(487)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KSqlParserLIMIT {
		{
			p.SetState(486)
			p.LimitClause()
		}

	}

	return localctx
}

// IResultMaterializationContext is an interface to support dynamic dispatch.
type IResultMaterializationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsResultMaterializationContext differentiates from other interfaces.
	IsResultMaterializationContext()
}

type ResultMaterializationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResultMaterializationContext() *ResultMaterializationContext {
	var p = new(ResultMaterializationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_resultMaterialization
	return p
}

func (*ResultMaterializationContext) IsResultMaterializationContext() {}

func NewResultMaterializationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResultMaterializationContext {
	var p = new(ResultMaterializationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_resultMaterialization

	return p
}

func (s *ResultMaterializationContext) GetParser() antlr.Parser { return s.parser }

func (s *ResultMaterializationContext) CHANGES() antlr.TerminalNode {
	return s.GetToken(KSqlParserCHANGES, 0)
}

func (s *ResultMaterializationContext) FINAL() antlr.TerminalNode {
	return s.GetToken(KSqlParserFINAL, 0)
}

func (s *ResultMaterializationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResultMaterializationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResultMaterializationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterResultMaterialization(s)
	}
}

func (s *ResultMaterializationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitResultMaterialization(s)
	}
}

func (p *KSqlParser) ResultMaterialization() (localctx IResultMaterializationContext) {
	localctx = NewResultMaterializationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, KSqlParserRULE_resultMaterialization)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(489)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KSqlParserCHANGES || _la == KSqlParserFINAL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IAlterOptionContext is an interface to support dynamic dispatch.
type IAlterOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlterOptionContext differentiates from other interfaces.
	IsAlterOptionContext()
}

type AlterOptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterOptionContext() *AlterOptionContext {
	var p = new(AlterOptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_alterOption
	return p
}

func (*AlterOptionContext) IsAlterOptionContext() {}

func NewAlterOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterOptionContext {
	var p = new(AlterOptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_alterOption

	return p
}

func (s *AlterOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterOptionContext) ADD() antlr.TerminalNode {
	return s.GetToken(KSqlParserADD, 0)
}

func (s *AlterOptionContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterOptionContext) Sqltype() ISqltypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISqltypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISqltypeContext)
}

func (s *AlterOptionContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(KSqlParserCOLUMN, 0)
}

func (s *AlterOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterAlterOption(s)
	}
}

func (s *AlterOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitAlterOption(s)
	}
}

func (p *KSqlParser) AlterOption() (localctx IAlterOptionContext) {
	localctx = NewAlterOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, KSqlParserRULE_alterOption)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(491)
		p.Match(KSqlParserADD)
	}
	p.SetState(493)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 56, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(492)
			p.Match(KSqlParserCOLUMN)
		}

	}
	{
		p.SetState(495)
		p.Identifier()
	}
	{
		p.SetState(496)
		p.sqltype(0)
	}

	return localctx
}

// ITableElementsContext is an interface to support dynamic dispatch.
type ITableElementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableElementsContext differentiates from other interfaces.
	IsTableElementsContext()
}

type TableElementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableElementsContext() *TableElementsContext {
	var p = new(TableElementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_tableElements
	return p
}

func (*TableElementsContext) IsTableElementsContext() {}

func NewTableElementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableElementsContext {
	var p = new(TableElementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_tableElements

	return p
}

func (s *TableElementsContext) GetParser() antlr.Parser { return s.parser }

func (s *TableElementsContext) AllTableElement() []ITableElementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITableElementContext)(nil)).Elem())
	var tst = make([]ITableElementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITableElementContext)
		}
	}

	return tst
}

func (s *TableElementsContext) TableElement(i int) ITableElementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITableElementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITableElementContext)
}

func (s *TableElementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableElementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableElementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterTableElements(s)
	}
}

func (s *TableElementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitTableElements(s)
	}
}

func (p *KSqlParser) TableElements() (localctx ITableElementsContext) {
	localctx = NewTableElementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, KSqlParserRULE_tableElements)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(498)
		p.Match(KSqlParserT__2)
	}
	{
		p.SetState(499)
		p.TableElement()
	}
	p.SetState(504)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KSqlParserT__1 {
		{
			p.SetState(500)
			p.Match(KSqlParserT__1)
		}
		{
			p.SetState(501)
			p.TableElement()
		}

		p.SetState(506)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(507)
		p.Match(KSqlParserT__3)
	}

	return localctx
}

// ITableElementContext is an interface to support dynamic dispatch.
type ITableElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableElementContext differentiates from other interfaces.
	IsTableElementContext()
}

type TableElementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableElementContext() *TableElementContext {
	var p = new(TableElementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_tableElement
	return p
}

func (*TableElementContext) IsTableElementContext() {}

func NewTableElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableElementContext {
	var p = new(TableElementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_tableElement

	return p
}

func (s *TableElementContext) GetParser() antlr.Parser { return s.parser }

func (s *TableElementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TableElementContext) Sqltype() ISqltypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISqltypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISqltypeContext)
}

func (s *TableElementContext) ColumnConstraints() IColumnConstraintsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IColumnConstraintsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IColumnConstraintsContext)
}

func (s *TableElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterTableElement(s)
	}
}

func (s *TableElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitTableElement(s)
	}
}

func (p *KSqlParser) TableElement() (localctx ITableElementContext) {
	localctx = NewTableElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, KSqlParserRULE_tableElement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(509)
		p.Identifier()
	}
	{
		p.SetState(510)
		p.sqltype(0)
	}
	p.SetState(512)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la-128)&-(0x1f+1)) == 0 && ((1<<uint((_la-128)))&((1<<(KSqlParserKEY-128))|(1<<(KSqlParserPRIMARY-128))|(1<<(KSqlParserHEADERS-128))|(1<<(KSqlParserHEADER-128)))) != 0 {
		{
			p.SetState(511)
			p.ColumnConstraints()
		}

	}

	return localctx
}

// IColumnConstraintsContext is an interface to support dynamic dispatch.
type IColumnConstraintsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsColumnConstraintsContext differentiates from other interfaces.
	IsColumnConstraintsContext()
}

type ColumnConstraintsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnConstraintsContext() *ColumnConstraintsContext {
	var p = new(ColumnConstraintsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_columnConstraints
	return p
}

func (*ColumnConstraintsContext) IsColumnConstraintsContext() {}

func NewColumnConstraintsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnConstraintsContext {
	var p = new(ColumnConstraintsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_columnConstraints

	return p
}

func (s *ColumnConstraintsContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnConstraintsContext) KEY() antlr.TerminalNode {
	return s.GetToken(KSqlParserKEY, 0)
}

func (s *ColumnConstraintsContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(KSqlParserPRIMARY, 0)
}

func (s *ColumnConstraintsContext) HEADERS() antlr.TerminalNode {
	return s.GetToken(KSqlParserHEADERS, 0)
}

func (s *ColumnConstraintsContext) HEADER() antlr.TerminalNode {
	return s.GetToken(KSqlParserHEADER, 0)
}

func (s *ColumnConstraintsContext) STRING() antlr.TerminalNode {
	return s.GetToken(KSqlParserSTRING, 0)
}

func (s *ColumnConstraintsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnConstraintsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnConstraintsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterColumnConstraints(s)
	}
}

func (s *ColumnConstraintsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitColumnConstraints(s)
	}
}

func (p *KSqlParser) ColumnConstraints() (localctx IColumnConstraintsContext) {
	localctx = NewColumnConstraintsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, KSqlParserRULE_columnConstraints)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(523)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KSqlParserKEY, KSqlParserPRIMARY:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(515)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserPRIMARY {
			{
				p.SetState(514)
				p.Match(KSqlParserPRIMARY)
			}

		}
		{
			p.SetState(517)
			p.Match(KSqlParserKEY)
		}

	case KSqlParserHEADERS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(518)
			p.Match(KSqlParserHEADERS)
		}

	case KSqlParserHEADER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(519)
			p.Match(KSqlParserHEADER)
		}
		{
			p.SetState(520)
			p.Match(KSqlParserT__2)
		}
		{
			p.SetState(521)
			p.Match(KSqlParserSTRING)
		}
		{
			p.SetState(522)
			p.Match(KSqlParserT__3)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITablePropertiesContext is an interface to support dynamic dispatch.
type ITablePropertiesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTablePropertiesContext differentiates from other interfaces.
	IsTablePropertiesContext()
}

type TablePropertiesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTablePropertiesContext() *TablePropertiesContext {
	var p = new(TablePropertiesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_tableProperties
	return p
}

func (*TablePropertiesContext) IsTablePropertiesContext() {}

func NewTablePropertiesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TablePropertiesContext {
	var p = new(TablePropertiesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_tableProperties

	return p
}

func (s *TablePropertiesContext) GetParser() antlr.Parser { return s.parser }

func (s *TablePropertiesContext) AllTableProperty() []ITablePropertyContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITablePropertyContext)(nil)).Elem())
	var tst = make([]ITablePropertyContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITablePropertyContext)
		}
	}

	return tst
}

func (s *TablePropertiesContext) TableProperty(i int) ITablePropertyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITablePropertyContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITablePropertyContext)
}

func (s *TablePropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TablePropertiesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TablePropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterTableProperties(s)
	}
}

func (s *TablePropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitTableProperties(s)
	}
}

func (p *KSqlParser) TableProperties() (localctx ITablePropertiesContext) {
	localctx = NewTablePropertiesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, KSqlParserRULE_tableProperties)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(525)
		p.Match(KSqlParserT__2)
	}
	{
		p.SetState(526)
		p.TableProperty()
	}
	p.SetState(531)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KSqlParserT__1 {
		{
			p.SetState(527)
			p.Match(KSqlParserT__1)
		}
		{
			p.SetState(528)
			p.TableProperty()
		}

		p.SetState(533)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(534)
		p.Match(KSqlParserT__3)
	}

	return localctx
}

// ITablePropertyContext is an interface to support dynamic dispatch.
type ITablePropertyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTablePropertyContext differentiates from other interfaces.
	IsTablePropertyContext()
}

type TablePropertyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTablePropertyContext() *TablePropertyContext {
	var p = new(TablePropertyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_tableProperty
	return p
}

func (*TablePropertyContext) IsTablePropertyContext() {}

func NewTablePropertyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TablePropertyContext {
	var p = new(TablePropertyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_tableProperty

	return p
}

func (s *TablePropertyContext) GetParser() antlr.Parser { return s.parser }

func (s *TablePropertyContext) EQ() antlr.TerminalNode {
	return s.GetToken(KSqlParserEQ, 0)
}

func (s *TablePropertyContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *TablePropertyContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TablePropertyContext) STRING() antlr.TerminalNode {
	return s.GetToken(KSqlParserSTRING, 0)
}

func (s *TablePropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TablePropertyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TablePropertyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterTableProperty(s)
	}
}

func (s *TablePropertyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitTableProperty(s)
	}
}

func (p *KSqlParser) TableProperty() (localctx ITablePropertyContext) {
	localctx = NewTablePropertyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, KSqlParserRULE_tableProperty)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(538)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KSqlParserT__7, KSqlParserEMIT, KSqlParserCHANGES, KSqlParserFINAL, KSqlParserESCAPE, KSqlParserINTEGER, KSqlParserDATE, KSqlParserTIME, KSqlParserTIMESTAMP, KSqlParserINTERVAL, KSqlParserYEAR, KSqlParserMONTH, KSqlParserDAY, KSqlParserHOUR, KSqlParserMINUTE, KSqlParserSECOND, KSqlParserZONE, KSqlParserPARTITION, KSqlParserSTRUCT, KSqlParserEXPLAIN, KSqlParserANALYZE, KSqlParserTYPE, KSqlParserTYPES, KSqlParserSHOW, KSqlParserTABLES, KSqlParserCOLUMNS, KSqlParserCOLUMN, KSqlParserPARTITIONS, KSqlParserFUNCTIONS, KSqlParserFUNCTION, KSqlParserARRAY, KSqlParserMAP, KSqlParserSET, KSqlParserRESET, KSqlParserSESSION, KSqlParserKEY, KSqlParserSINK, KSqlParserSOURCE, KSqlParserPRIMARY, KSqlParserREPLACE, KSqlParserASSERT, KSqlParserADD, KSqlParserALTER, KSqlParserIF, KSqlParserIDENTIFIER, KSqlParserDIGIT_IDENTIFIER, KSqlParserQUOTED_IDENTIFIER, KSqlParserBACKQUOTED_IDENTIFIER, KSqlParserVARIABLE:
		{
			p.SetState(536)
			p.Identifier()
		}

	case KSqlParserSTRING:
		{
			p.SetState(537)
			p.Match(KSqlParserSTRING)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(540)
		p.Match(KSqlParserEQ)
	}
	{
		p.SetState(541)
		p.Literal()
	}

	return localctx
}

// IPrintClauseContext is an interface to support dynamic dispatch.
type IPrintClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrintClauseContext differentiates from other interfaces.
	IsPrintClauseContext()
}

type PrintClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrintClauseContext() *PrintClauseContext {
	var p = new(PrintClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_printClause
	return p
}

func (*PrintClauseContext) IsPrintClauseContext() {}

func NewPrintClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrintClauseContext {
	var p = new(PrintClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_printClause

	return p
}

func (s *PrintClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PrintClauseContext) FROM() antlr.TerminalNode {
	return s.GetToken(KSqlParserFROM, 0)
}

func (s *PrintClauseContext) BEGINNING() antlr.TerminalNode {
	return s.GetToken(KSqlParserBEGINNING, 0)
}

func (s *PrintClauseContext) IntervalClause() IIntervalClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntervalClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntervalClauseContext)
}

func (s *PrintClauseContext) LimitClause() ILimitClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILimitClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *PrintClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrintClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrintClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterPrintClause(s)
	}
}

func (s *PrintClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitPrintClause(s)
	}
}

func (p *KSqlParser) PrintClause() (localctx IPrintClauseContext) {
	localctx = NewPrintClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, KSqlParserRULE_printClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(545)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KSqlParserFROM {
		{
			p.SetState(543)
			p.Match(KSqlParserFROM)
		}
		{
			p.SetState(544)
			p.Match(KSqlParserBEGINNING)
		}

	}
	p.SetState(548)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KSqlParserINTERVAL || _la == KSqlParserSAMPLE {
		{
			p.SetState(547)
			p.IntervalClause()
		}

	}
	p.SetState(551)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KSqlParserLIMIT {
		{
			p.SetState(550)
			p.LimitClause()
		}

	}

	return localctx
}

// IIntervalClauseContext is an interface to support dynamic dispatch.
type IIntervalClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIntervalClauseContext differentiates from other interfaces.
	IsIntervalClauseContext()
}

type IntervalClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntervalClauseContext() *IntervalClauseContext {
	var p = new(IntervalClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_intervalClause
	return p
}

func (*IntervalClauseContext) IsIntervalClauseContext() {}

func NewIntervalClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntervalClauseContext {
	var p = new(IntervalClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_intervalClause

	return p
}

func (s *IntervalClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *IntervalClauseContext) Number() INumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *IntervalClauseContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(KSqlParserINTERVAL, 0)
}

func (s *IntervalClauseContext) SAMPLE() antlr.TerminalNode {
	return s.GetToken(KSqlParserSAMPLE, 0)
}

func (s *IntervalClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntervalClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterIntervalClause(s)
	}
}

func (s *IntervalClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitIntervalClause(s)
	}
}

func (p *KSqlParser) IntervalClause() (localctx IIntervalClauseContext) {
	localctx = NewIntervalClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, KSqlParserRULE_intervalClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(553)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KSqlParserINTERVAL || _la == KSqlParserSAMPLE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(554)
		p.Number()
	}

	return localctx
}

// ILimitClauseContext is an interface to support dynamic dispatch.
type ILimitClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLimitClauseContext differentiates from other interfaces.
	IsLimitClauseContext()
}

type LimitClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLimitClauseContext() *LimitClauseContext {
	var p = new(LimitClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_limitClause
	return p
}

func (*LimitClauseContext) IsLimitClauseContext() {}

func NewLimitClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LimitClauseContext {
	var p = new(LimitClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_limitClause

	return p
}

func (s *LimitClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LimitClauseContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(KSqlParserLIMIT, 0)
}

func (s *LimitClauseContext) Number() INumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *LimitClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LimitClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LimitClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterLimitClause(s)
	}
}

func (s *LimitClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitLimitClause(s)
	}
}

func (p *KSqlParser) LimitClause() (localctx ILimitClauseContext) {
	localctx = NewLimitClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, KSqlParserRULE_limitClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(556)
		p.Match(KSqlParserLIMIT)
	}
	{
		p.SetState(557)
		p.Number()
	}

	return localctx
}

// IRetentionClauseContext is an interface to support dynamic dispatch.
type IRetentionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRetentionClauseContext differentiates from other interfaces.
	IsRetentionClauseContext()
}

type RetentionClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRetentionClauseContext() *RetentionClauseContext {
	var p = new(RetentionClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_retentionClause
	return p
}

func (*RetentionClauseContext) IsRetentionClauseContext() {}

func NewRetentionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RetentionClauseContext {
	var p = new(RetentionClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_retentionClause

	return p
}

func (s *RetentionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *RetentionClauseContext) RETENTION() antlr.TerminalNode {
	return s.GetToken(KSqlParserRETENTION, 0)
}

func (s *RetentionClauseContext) Number() INumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *RetentionClauseContext) WindowUnit() IWindowUnitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWindowUnitContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWindowUnitContext)
}

func (s *RetentionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RetentionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RetentionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterRetentionClause(s)
	}
}

func (s *RetentionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitRetentionClause(s)
	}
}

func (p *KSqlParser) RetentionClause() (localctx IRetentionClauseContext) {
	localctx = NewRetentionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, KSqlParserRULE_retentionClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(559)
		p.Match(KSqlParserRETENTION)
	}
	{
		p.SetState(560)
		p.Number()
	}
	{
		p.SetState(561)
		p.WindowUnit()
	}

	return localctx
}

// IGracePeriodClauseContext is an interface to support dynamic dispatch.
type IGracePeriodClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGracePeriodClauseContext differentiates from other interfaces.
	IsGracePeriodClauseContext()
}

type GracePeriodClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGracePeriodClauseContext() *GracePeriodClauseContext {
	var p = new(GracePeriodClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_gracePeriodClause
	return p
}

func (*GracePeriodClauseContext) IsGracePeriodClauseContext() {}

func NewGracePeriodClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GracePeriodClauseContext {
	var p = new(GracePeriodClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_gracePeriodClause

	return p
}

func (s *GracePeriodClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *GracePeriodClauseContext) GRACE() antlr.TerminalNode {
	return s.GetToken(KSqlParserGRACE, 0)
}

func (s *GracePeriodClauseContext) PERIOD() antlr.TerminalNode {
	return s.GetToken(KSqlParserPERIOD, 0)
}

func (s *GracePeriodClauseContext) Number() INumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *GracePeriodClauseContext) WindowUnit() IWindowUnitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWindowUnitContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWindowUnitContext)
}

func (s *GracePeriodClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GracePeriodClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GracePeriodClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterGracePeriodClause(s)
	}
}

func (s *GracePeriodClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitGracePeriodClause(s)
	}
}

func (p *KSqlParser) GracePeriodClause() (localctx IGracePeriodClauseContext) {
	localctx = NewGracePeriodClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, KSqlParserRULE_gracePeriodClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(563)
		p.Match(KSqlParserGRACE)
	}
	{
		p.SetState(564)
		p.Match(KSqlParserPERIOD)
	}
	{
		p.SetState(565)
		p.Number()
	}
	{
		p.SetState(566)
		p.WindowUnit()
	}

	return localctx
}

// IWindowExpressionContext is an interface to support dynamic dispatch.
type IWindowExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWindowExpressionContext differentiates from other interfaces.
	IsWindowExpressionContext()
}

type WindowExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowExpressionContext() *WindowExpressionContext {
	var p = new(WindowExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_windowExpression
	return p
}

func (*WindowExpressionContext) IsWindowExpressionContext() {}

func NewWindowExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowExpressionContext {
	var p = new(WindowExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_windowExpression

	return p
}

func (s *WindowExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowExpressionContext) TumblingWindowExpression() ITumblingWindowExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITumblingWindowExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITumblingWindowExpressionContext)
}

func (s *WindowExpressionContext) HoppingWindowExpression() IHoppingWindowExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHoppingWindowExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHoppingWindowExpressionContext)
}

func (s *WindowExpressionContext) SessionWindowExpression() ISessionWindowExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISessionWindowExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISessionWindowExpressionContext)
}

func (s *WindowExpressionContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(KSqlParserIDENTIFIER, 0)
}

func (s *WindowExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterWindowExpression(s)
	}
}

func (s *WindowExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitWindowExpression(s)
	}
}

func (p *KSqlParser) WindowExpression() (localctx IWindowExpressionContext) {
	localctx = NewWindowExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, KSqlParserRULE_windowExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(569)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KSqlParserIDENTIFIER {
		{
			p.SetState(568)
			p.Match(KSqlParserIDENTIFIER)
		}

	}
	p.SetState(574)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KSqlParserTUMBLING:
		{
			p.SetState(571)
			p.TumblingWindowExpression()
		}

	case KSqlParserHOPPING:
		{
			p.SetState(572)
			p.HoppingWindowExpression()
		}

	case KSqlParserSESSION:
		{
			p.SetState(573)
			p.SessionWindowExpression()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ITumblingWindowExpressionContext is an interface to support dynamic dispatch.
type ITumblingWindowExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTumblingWindowExpressionContext differentiates from other interfaces.
	IsTumblingWindowExpressionContext()
}

type TumblingWindowExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTumblingWindowExpressionContext() *TumblingWindowExpressionContext {
	var p = new(TumblingWindowExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_tumblingWindowExpression
	return p
}

func (*TumblingWindowExpressionContext) IsTumblingWindowExpressionContext() {}

func NewTumblingWindowExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TumblingWindowExpressionContext {
	var p = new(TumblingWindowExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_tumblingWindowExpression

	return p
}

func (s *TumblingWindowExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *TumblingWindowExpressionContext) TUMBLING() antlr.TerminalNode {
	return s.GetToken(KSqlParserTUMBLING, 0)
}

func (s *TumblingWindowExpressionContext) SIZE() antlr.TerminalNode {
	return s.GetToken(KSqlParserSIZE, 0)
}

func (s *TumblingWindowExpressionContext) Number() INumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *TumblingWindowExpressionContext) WindowUnit() IWindowUnitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWindowUnitContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWindowUnitContext)
}

func (s *TumblingWindowExpressionContext) RetentionClause() IRetentionClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRetentionClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRetentionClauseContext)
}

func (s *TumblingWindowExpressionContext) GracePeriodClause() IGracePeriodClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGracePeriodClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGracePeriodClauseContext)
}

func (s *TumblingWindowExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TumblingWindowExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TumblingWindowExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterTumblingWindowExpression(s)
	}
}

func (s *TumblingWindowExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitTumblingWindowExpression(s)
	}
}

func (p *KSqlParser) TumblingWindowExpression() (localctx ITumblingWindowExpressionContext) {
	localctx = NewTumblingWindowExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, KSqlParserRULE_tumblingWindowExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(576)
		p.Match(KSqlParserTUMBLING)
	}
	{
		p.SetState(577)
		p.Match(KSqlParserT__2)
	}
	{
		p.SetState(578)
		p.Match(KSqlParserSIZE)
	}
	{
		p.SetState(579)
		p.Number()
	}
	{
		p.SetState(580)
		p.WindowUnit()
	}
	p.SetState(583)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 68, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(581)
			p.Match(KSqlParserT__1)
		}
		{
			p.SetState(582)
			p.RetentionClause()
		}

	}
	p.SetState(587)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KSqlParserT__1 {
		{
			p.SetState(585)
			p.Match(KSqlParserT__1)
		}
		{
			p.SetState(586)
			p.GracePeriodClause()
		}

	}
	{
		p.SetState(589)
		p.Match(KSqlParserT__3)
	}

	return localctx
}

// IHoppingWindowExpressionContext is an interface to support dynamic dispatch.
type IHoppingWindowExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHoppingWindowExpressionContext differentiates from other interfaces.
	IsHoppingWindowExpressionContext()
}

type HoppingWindowExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHoppingWindowExpressionContext() *HoppingWindowExpressionContext {
	var p = new(HoppingWindowExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_hoppingWindowExpression
	return p
}

func (*HoppingWindowExpressionContext) IsHoppingWindowExpressionContext() {}

func NewHoppingWindowExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HoppingWindowExpressionContext {
	var p = new(HoppingWindowExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_hoppingWindowExpression

	return p
}

func (s *HoppingWindowExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *HoppingWindowExpressionContext) HOPPING() antlr.TerminalNode {
	return s.GetToken(KSqlParserHOPPING, 0)
}

func (s *HoppingWindowExpressionContext) SIZE() antlr.TerminalNode {
	return s.GetToken(KSqlParserSIZE, 0)
}

func (s *HoppingWindowExpressionContext) AllNumber() []INumberContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INumberContext)(nil)).Elem())
	var tst = make([]INumberContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INumberContext)
		}
	}

	return tst
}

func (s *HoppingWindowExpressionContext) Number(i int) INumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *HoppingWindowExpressionContext) AllWindowUnit() []IWindowUnitContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWindowUnitContext)(nil)).Elem())
	var tst = make([]IWindowUnitContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWindowUnitContext)
		}
	}

	return tst
}

func (s *HoppingWindowExpressionContext) WindowUnit(i int) IWindowUnitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWindowUnitContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWindowUnitContext)
}

func (s *HoppingWindowExpressionContext) ADVANCE() antlr.TerminalNode {
	return s.GetToken(KSqlParserADVANCE, 0)
}

func (s *HoppingWindowExpressionContext) BY() antlr.TerminalNode {
	return s.GetToken(KSqlParserBY, 0)
}

func (s *HoppingWindowExpressionContext) RetentionClause() IRetentionClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRetentionClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRetentionClauseContext)
}

func (s *HoppingWindowExpressionContext) GracePeriodClause() IGracePeriodClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGracePeriodClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGracePeriodClauseContext)
}

func (s *HoppingWindowExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HoppingWindowExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HoppingWindowExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterHoppingWindowExpression(s)
	}
}

func (s *HoppingWindowExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitHoppingWindowExpression(s)
	}
}

func (p *KSqlParser) HoppingWindowExpression() (localctx IHoppingWindowExpressionContext) {
	localctx = NewHoppingWindowExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, KSqlParserRULE_hoppingWindowExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(591)
		p.Match(KSqlParserHOPPING)
	}
	{
		p.SetState(592)
		p.Match(KSqlParserT__2)
	}
	{
		p.SetState(593)
		p.Match(KSqlParserSIZE)
	}
	{
		p.SetState(594)
		p.Number()
	}
	{
		p.SetState(595)
		p.WindowUnit()
	}
	{
		p.SetState(596)
		p.Match(KSqlParserT__1)
	}
	{
		p.SetState(597)
		p.Match(KSqlParserADVANCE)
	}
	{
		p.SetState(598)
		p.Match(KSqlParserBY)
	}
	{
		p.SetState(599)
		p.Number()
	}
	{
		p.SetState(600)
		p.WindowUnit()
	}
	p.SetState(603)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 70, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(601)
			p.Match(KSqlParserT__1)
		}
		{
			p.SetState(602)
			p.RetentionClause()
		}

	}
	p.SetState(607)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KSqlParserT__1 {
		{
			p.SetState(605)
			p.Match(KSqlParserT__1)
		}
		{
			p.SetState(606)
			p.GracePeriodClause()
		}

	}
	{
		p.SetState(609)
		p.Match(KSqlParserT__3)
	}

	return localctx
}

// ISessionWindowExpressionContext is an interface to support dynamic dispatch.
type ISessionWindowExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSessionWindowExpressionContext differentiates from other interfaces.
	IsSessionWindowExpressionContext()
}

type SessionWindowExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySessionWindowExpressionContext() *SessionWindowExpressionContext {
	var p = new(SessionWindowExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_sessionWindowExpression
	return p
}

func (*SessionWindowExpressionContext) IsSessionWindowExpressionContext() {}

func NewSessionWindowExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SessionWindowExpressionContext {
	var p = new(SessionWindowExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_sessionWindowExpression

	return p
}

func (s *SessionWindowExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *SessionWindowExpressionContext) SESSION() antlr.TerminalNode {
	return s.GetToken(KSqlParserSESSION, 0)
}

func (s *SessionWindowExpressionContext) Number() INumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *SessionWindowExpressionContext) WindowUnit() IWindowUnitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWindowUnitContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWindowUnitContext)
}

func (s *SessionWindowExpressionContext) RetentionClause() IRetentionClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRetentionClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRetentionClauseContext)
}

func (s *SessionWindowExpressionContext) GracePeriodClause() IGracePeriodClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGracePeriodClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGracePeriodClauseContext)
}

func (s *SessionWindowExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SessionWindowExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SessionWindowExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterSessionWindowExpression(s)
	}
}

func (s *SessionWindowExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitSessionWindowExpression(s)
	}
}

func (p *KSqlParser) SessionWindowExpression() (localctx ISessionWindowExpressionContext) {
	localctx = NewSessionWindowExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, KSqlParserRULE_sessionWindowExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(611)
		p.Match(KSqlParserSESSION)
	}
	{
		p.SetState(612)
		p.Match(KSqlParserT__2)
	}
	{
		p.SetState(613)
		p.Number()
	}
	{
		p.SetState(614)
		p.WindowUnit()
	}
	p.SetState(617)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 72, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(615)
			p.Match(KSqlParserT__1)
		}
		{
			p.SetState(616)
			p.RetentionClause()
		}

	}
	p.SetState(621)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KSqlParserT__1 {
		{
			p.SetState(619)
			p.Match(KSqlParserT__1)
		}
		{
			p.SetState(620)
			p.GracePeriodClause()
		}

	}
	{
		p.SetState(623)
		p.Match(KSqlParserT__3)
	}

	return localctx
}

// IWindowUnitContext is an interface to support dynamic dispatch.
type IWindowUnitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWindowUnitContext differentiates from other interfaces.
	IsWindowUnitContext()
}

type WindowUnitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowUnitContext() *WindowUnitContext {
	var p = new(WindowUnitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_windowUnit
	return p
}

func (*WindowUnitContext) IsWindowUnitContext() {}

func NewWindowUnitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowUnitContext {
	var p = new(WindowUnitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_windowUnit

	return p
}

func (s *WindowUnitContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowUnitContext) DAY() antlr.TerminalNode {
	return s.GetToken(KSqlParserDAY, 0)
}

func (s *WindowUnitContext) HOUR() antlr.TerminalNode {
	return s.GetToken(KSqlParserHOUR, 0)
}

func (s *WindowUnitContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(KSqlParserMINUTE, 0)
}

func (s *WindowUnitContext) SECOND() antlr.TerminalNode {
	return s.GetToken(KSqlParserSECOND, 0)
}

func (s *WindowUnitContext) MILLISECOND() antlr.TerminalNode {
	return s.GetToken(KSqlParserMILLISECOND, 0)
}

func (s *WindowUnitContext) DAYS() antlr.TerminalNode {
	return s.GetToken(KSqlParserDAYS, 0)
}

func (s *WindowUnitContext) HOURS() antlr.TerminalNode {
	return s.GetToken(KSqlParserHOURS, 0)
}

func (s *WindowUnitContext) MINUTES() antlr.TerminalNode {
	return s.GetToken(KSqlParserMINUTES, 0)
}

func (s *WindowUnitContext) SECONDS() antlr.TerminalNode {
	return s.GetToken(KSqlParserSECONDS, 0)
}

func (s *WindowUnitContext) MILLISECONDS() antlr.TerminalNode {
	return s.GetToken(KSqlParserMILLISECONDS, 0)
}

func (s *WindowUnitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowUnitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowUnitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterWindowUnit(s)
	}
}

func (s *WindowUnitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitWindowUnit(s)
	}
}

func (p *KSqlParser) WindowUnit() (localctx IWindowUnitContext) {
	localctx = NewWindowUnitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, KSqlParserRULE_windowUnit)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(625)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-44)&-(0x1f+1)) == 0 && ((1<<uint((_la-44)))&((1<<(KSqlParserDAY-44))|(1<<(KSqlParserHOUR-44))|(1<<(KSqlParserMINUTE-44))|(1<<(KSqlParserSECOND-44))|(1<<(KSqlParserMILLISECOND-44))|(1<<(KSqlParserDAYS-44))|(1<<(KSqlParserHOURS-44))|(1<<(KSqlParserMINUTES-44))|(1<<(KSqlParserSECONDS-44))|(1<<(KSqlParserMILLISECONDS-44)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IGroupByContext is an interface to support dynamic dispatch.
type IGroupByContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGroupByContext differentiates from other interfaces.
	IsGroupByContext()
}

type GroupByContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupByContext() *GroupByContext {
	var p = new(GroupByContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_groupBy
	return p
}

func (*GroupByContext) IsGroupByContext() {}

func NewGroupByContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupByContext {
	var p = new(GroupByContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_groupBy

	return p
}

func (s *GroupByContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupByContext) AllValueExpression() []IValueExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem())
	var tst = make([]IValueExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueExpressionContext)
		}
	}

	return tst
}

func (s *GroupByContext) ValueExpression(i int) IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *GroupByContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupByContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupByContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterGroupBy(s)
	}
}

func (s *GroupByContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitGroupBy(s)
	}
}

func (p *KSqlParser) GroupBy() (localctx IGroupByContext) {
	localctx = NewGroupByContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, KSqlParserRULE_groupBy)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(647)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 77, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(627)
			p.valueExpression(0)
		}
		p.SetState(632)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KSqlParserT__1 {
			{
				p.SetState(628)
				p.Match(KSqlParserT__1)
			}
			{
				p.SetState(629)
				p.valueExpression(0)
			}

			p.SetState(634)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(635)
			p.Match(KSqlParserT__2)
		}
		p.SetState(644)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la-3)&-(0x1f+1)) == 0 && ((1<<uint((_la-3)))&((1<<(KSqlParserT__2-3))|(1<<(KSqlParserT__7-3))|(1<<(KSqlParserEMIT-3))|(1<<(KSqlParserCHANGES-3))|(1<<(KSqlParserFINAL-3))|(1<<(KSqlParserESCAPE-3))|(1<<(KSqlParserNULL-3)))) != 0) || (((_la-35)&-(0x1f+1)) == 0 && ((1<<uint((_la-35)))&((1<<(KSqlParserTRUE-35))|(1<<(KSqlParserFALSE-35))|(1<<(KSqlParserINTEGER-35))|(1<<(KSqlParserDATE-35))|(1<<(KSqlParserTIME-35))|(1<<(KSqlParserTIMESTAMP-35))|(1<<(KSqlParserINTERVAL-35))|(1<<(KSqlParserYEAR-35))|(1<<(KSqlParserMONTH-35))|(1<<(KSqlParserDAY-35))|(1<<(KSqlParserHOUR-35))|(1<<(KSqlParserMINUTE-35))|(1<<(KSqlParserSECOND-35))|(1<<(KSqlParserZONE-35))|(1<<(KSqlParserCASE-35)))) != 0) || (((_la-76)&-(0x1f+1)) == 0 && ((1<<uint((_la-76)))&((1<<(KSqlParserPARTITION-76))|(1<<(KSqlParserSTRUCT-76))|(1<<(KSqlParserEXPLAIN-76))|(1<<(KSqlParserANALYZE-76))|(1<<(KSqlParserTYPE-76))|(1<<(KSqlParserTYPES-76))|(1<<(KSqlParserCAST-76))|(1<<(KSqlParserSHOW-76))|(1<<(KSqlParserTABLES-76))|(1<<(KSqlParserCOLUMNS-76))|(1<<(KSqlParserCOLUMN-76))|(1<<(KSqlParserPARTITIONS-76))|(1<<(KSqlParserFUNCTIONS-76)))) != 0) || (((_la-108)&-(0x1f+1)) == 0 && ((1<<uint((_la-108)))&((1<<(KSqlParserFUNCTION-108))|(1<<(KSqlParserARRAY-108))|(1<<(KSqlParserMAP-108))|(1<<(KSqlParserSET-108))|(1<<(KSqlParserRESET-108))|(1<<(KSqlParserSESSION-108))|(1<<(KSqlParserKEY-108))|(1<<(KSqlParserSINK-108))|(1<<(KSqlParserSOURCE-108))|(1<<(KSqlParserPRIMARY-108))|(1<<(KSqlParserREPLACE-108))|(1<<(KSqlParserASSERT-108))|(1<<(KSqlParserADD-108)))) != 0) || (((_la-140)&-(0x1f+1)) == 0 && ((1<<uint((_la-140)))&((1<<(KSqlParserALTER-140))|(1<<(KSqlParserIF-140))|(1<<(KSqlParserPLUS-140))|(1<<(KSqlParserMINUS-140))|(1<<(KSqlParserSTRING-140))|(1<<(KSqlParserINTEGER_VALUE-140))|(1<<(KSqlParserDECIMAL_VALUE-140))|(1<<(KSqlParserFLOATING_POINT_VALUE-140))|(1<<(KSqlParserIDENTIFIER-140))|(1<<(KSqlParserDIGIT_IDENTIFIER-140))|(1<<(KSqlParserQUOTED_IDENTIFIER-140))|(1<<(KSqlParserBACKQUOTED_IDENTIFIER-140))|(1<<(KSqlParserVARIABLE-140)))) != 0) {
			{
				p.SetState(636)
				p.valueExpression(0)
			}
			p.SetState(641)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KSqlParserT__1 {
				{
					p.SetState(637)
					p.Match(KSqlParserT__1)
				}
				{
					p.SetState(638)
					p.valueExpression(0)
				}

				p.SetState(643)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(646)
			p.Match(KSqlParserT__3)
		}

	}

	return localctx
}

// IPartitionByContext is an interface to support dynamic dispatch.
type IPartitionByContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPartitionByContext differentiates from other interfaces.
	IsPartitionByContext()
}

type PartitionByContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionByContext() *PartitionByContext {
	var p = new(PartitionByContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_partitionBy
	return p
}

func (*PartitionByContext) IsPartitionByContext() {}

func NewPartitionByContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionByContext {
	var p = new(PartitionByContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_partitionBy

	return p
}

func (s *PartitionByContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionByContext) AllValueExpression() []IValueExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem())
	var tst = make([]IValueExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueExpressionContext)
		}
	}

	return tst
}

func (s *PartitionByContext) ValueExpression(i int) IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *PartitionByContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionByContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionByContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterPartitionBy(s)
	}
}

func (s *PartitionByContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitPartitionBy(s)
	}
}

func (p *KSqlParser) PartitionBy() (localctx IPartitionByContext) {
	localctx = NewPartitionByContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, KSqlParserRULE_partitionBy)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(669)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 81, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(649)
			p.valueExpression(0)
		}
		p.SetState(654)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KSqlParserT__1 {
			{
				p.SetState(650)
				p.Match(KSqlParserT__1)
			}
			{
				p.SetState(651)
				p.valueExpression(0)
			}

			p.SetState(656)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(657)
			p.Match(KSqlParserT__2)
		}
		p.SetState(666)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la-3)&-(0x1f+1)) == 0 && ((1<<uint((_la-3)))&((1<<(KSqlParserT__2-3))|(1<<(KSqlParserT__7-3))|(1<<(KSqlParserEMIT-3))|(1<<(KSqlParserCHANGES-3))|(1<<(KSqlParserFINAL-3))|(1<<(KSqlParserESCAPE-3))|(1<<(KSqlParserNULL-3)))) != 0) || (((_la-35)&-(0x1f+1)) == 0 && ((1<<uint((_la-35)))&((1<<(KSqlParserTRUE-35))|(1<<(KSqlParserFALSE-35))|(1<<(KSqlParserINTEGER-35))|(1<<(KSqlParserDATE-35))|(1<<(KSqlParserTIME-35))|(1<<(KSqlParserTIMESTAMP-35))|(1<<(KSqlParserINTERVAL-35))|(1<<(KSqlParserYEAR-35))|(1<<(KSqlParserMONTH-35))|(1<<(KSqlParserDAY-35))|(1<<(KSqlParserHOUR-35))|(1<<(KSqlParserMINUTE-35))|(1<<(KSqlParserSECOND-35))|(1<<(KSqlParserZONE-35))|(1<<(KSqlParserCASE-35)))) != 0) || (((_la-76)&-(0x1f+1)) == 0 && ((1<<uint((_la-76)))&((1<<(KSqlParserPARTITION-76))|(1<<(KSqlParserSTRUCT-76))|(1<<(KSqlParserEXPLAIN-76))|(1<<(KSqlParserANALYZE-76))|(1<<(KSqlParserTYPE-76))|(1<<(KSqlParserTYPES-76))|(1<<(KSqlParserCAST-76))|(1<<(KSqlParserSHOW-76))|(1<<(KSqlParserTABLES-76))|(1<<(KSqlParserCOLUMNS-76))|(1<<(KSqlParserCOLUMN-76))|(1<<(KSqlParserPARTITIONS-76))|(1<<(KSqlParserFUNCTIONS-76)))) != 0) || (((_la-108)&-(0x1f+1)) == 0 && ((1<<uint((_la-108)))&((1<<(KSqlParserFUNCTION-108))|(1<<(KSqlParserARRAY-108))|(1<<(KSqlParserMAP-108))|(1<<(KSqlParserSET-108))|(1<<(KSqlParserRESET-108))|(1<<(KSqlParserSESSION-108))|(1<<(KSqlParserKEY-108))|(1<<(KSqlParserSINK-108))|(1<<(KSqlParserSOURCE-108))|(1<<(KSqlParserPRIMARY-108))|(1<<(KSqlParserREPLACE-108))|(1<<(KSqlParserASSERT-108))|(1<<(KSqlParserADD-108)))) != 0) || (((_la-140)&-(0x1f+1)) == 0 && ((1<<uint((_la-140)))&((1<<(KSqlParserALTER-140))|(1<<(KSqlParserIF-140))|(1<<(KSqlParserPLUS-140))|(1<<(KSqlParserMINUS-140))|(1<<(KSqlParserSTRING-140))|(1<<(KSqlParserINTEGER_VALUE-140))|(1<<(KSqlParserDECIMAL_VALUE-140))|(1<<(KSqlParserFLOATING_POINT_VALUE-140))|(1<<(KSqlParserIDENTIFIER-140))|(1<<(KSqlParserDIGIT_IDENTIFIER-140))|(1<<(KSqlParserQUOTED_IDENTIFIER-140))|(1<<(KSqlParserBACKQUOTED_IDENTIFIER-140))|(1<<(KSqlParserVARIABLE-140)))) != 0) {
			{
				p.SetState(658)
				p.valueExpression(0)
			}
			p.SetState(663)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KSqlParserT__1 {
				{
					p.SetState(659)
					p.Match(KSqlParserT__1)
				}
				{
					p.SetState(660)
					p.valueExpression(0)
				}

				p.SetState(665)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(668)
			p.Match(KSqlParserT__3)
		}

	}

	return localctx
}

// IValuesContext is an interface to support dynamic dispatch.
type IValuesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValuesContext differentiates from other interfaces.
	IsValuesContext()
}

type ValuesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValuesContext() *ValuesContext {
	var p = new(ValuesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_values
	return p
}

func (*ValuesContext) IsValuesContext() {}

func NewValuesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValuesContext {
	var p = new(ValuesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_values

	return p
}

func (s *ValuesContext) GetParser() antlr.Parser { return s.parser }

func (s *ValuesContext) AllValueExpression() []IValueExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem())
	var tst = make([]IValueExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueExpressionContext)
		}
	}

	return tst
}

func (s *ValuesContext) ValueExpression(i int) IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ValuesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValuesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValuesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterValues(s)
	}
}

func (s *ValuesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitValues(s)
	}
}

func (p *KSqlParser) Values() (localctx IValuesContext) {
	localctx = NewValuesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, KSqlParserRULE_values)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(671)
		p.Match(KSqlParserT__2)
	}
	p.SetState(680)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-3)&-(0x1f+1)) == 0 && ((1<<uint((_la-3)))&((1<<(KSqlParserT__2-3))|(1<<(KSqlParserT__7-3))|(1<<(KSqlParserEMIT-3))|(1<<(KSqlParserCHANGES-3))|(1<<(KSqlParserFINAL-3))|(1<<(KSqlParserESCAPE-3))|(1<<(KSqlParserNULL-3)))) != 0) || (((_la-35)&-(0x1f+1)) == 0 && ((1<<uint((_la-35)))&((1<<(KSqlParserTRUE-35))|(1<<(KSqlParserFALSE-35))|(1<<(KSqlParserINTEGER-35))|(1<<(KSqlParserDATE-35))|(1<<(KSqlParserTIME-35))|(1<<(KSqlParserTIMESTAMP-35))|(1<<(KSqlParserINTERVAL-35))|(1<<(KSqlParserYEAR-35))|(1<<(KSqlParserMONTH-35))|(1<<(KSqlParserDAY-35))|(1<<(KSqlParserHOUR-35))|(1<<(KSqlParserMINUTE-35))|(1<<(KSqlParserSECOND-35))|(1<<(KSqlParserZONE-35))|(1<<(KSqlParserCASE-35)))) != 0) || (((_la-76)&-(0x1f+1)) == 0 && ((1<<uint((_la-76)))&((1<<(KSqlParserPARTITION-76))|(1<<(KSqlParserSTRUCT-76))|(1<<(KSqlParserEXPLAIN-76))|(1<<(KSqlParserANALYZE-76))|(1<<(KSqlParserTYPE-76))|(1<<(KSqlParserTYPES-76))|(1<<(KSqlParserCAST-76))|(1<<(KSqlParserSHOW-76))|(1<<(KSqlParserTABLES-76))|(1<<(KSqlParserCOLUMNS-76))|(1<<(KSqlParserCOLUMN-76))|(1<<(KSqlParserPARTITIONS-76))|(1<<(KSqlParserFUNCTIONS-76)))) != 0) || (((_la-108)&-(0x1f+1)) == 0 && ((1<<uint((_la-108)))&((1<<(KSqlParserFUNCTION-108))|(1<<(KSqlParserARRAY-108))|(1<<(KSqlParserMAP-108))|(1<<(KSqlParserSET-108))|(1<<(KSqlParserRESET-108))|(1<<(KSqlParserSESSION-108))|(1<<(KSqlParserKEY-108))|(1<<(KSqlParserSINK-108))|(1<<(KSqlParserSOURCE-108))|(1<<(KSqlParserPRIMARY-108))|(1<<(KSqlParserREPLACE-108))|(1<<(KSqlParserASSERT-108))|(1<<(KSqlParserADD-108)))) != 0) || (((_la-140)&-(0x1f+1)) == 0 && ((1<<uint((_la-140)))&((1<<(KSqlParserALTER-140))|(1<<(KSqlParserIF-140))|(1<<(KSqlParserPLUS-140))|(1<<(KSqlParserMINUS-140))|(1<<(KSqlParserSTRING-140))|(1<<(KSqlParserINTEGER_VALUE-140))|(1<<(KSqlParserDECIMAL_VALUE-140))|(1<<(KSqlParserFLOATING_POINT_VALUE-140))|(1<<(KSqlParserIDENTIFIER-140))|(1<<(KSqlParserDIGIT_IDENTIFIER-140))|(1<<(KSqlParserQUOTED_IDENTIFIER-140))|(1<<(KSqlParserBACKQUOTED_IDENTIFIER-140))|(1<<(KSqlParserVARIABLE-140)))) != 0) {
		{
			p.SetState(672)
			p.valueExpression(0)
		}
		p.SetState(677)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KSqlParserT__1 {
			{
				p.SetState(673)
				p.Match(KSqlParserT__1)
			}
			{
				p.SetState(674)
				p.valueExpression(0)
			}

			p.SetState(679)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(682)
		p.Match(KSqlParserT__3)
	}

	return localctx
}

// ISelectItemContext is an interface to support dynamic dispatch.
type ISelectItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelectItemContext differentiates from other interfaces.
	IsSelectItemContext()
}

type SelectItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectItemContext() *SelectItemContext {
	var p = new(SelectItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_selectItem
	return p
}

func (*SelectItemContext) IsSelectItemContext() {}

func NewSelectItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectItemContext {
	var p = new(SelectItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_selectItem

	return p
}

func (s *SelectItemContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectItemContext) CopyFrom(ctx *SelectItemContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *SelectItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SelectAllContext struct {
	*SelectItemContext
}

func NewSelectAllContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectAllContext {
	var p = new(SelectAllContext)

	p.SelectItemContext = NewEmptySelectItemContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SelectItemContext))

	return p
}

func (s *SelectAllContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectAllContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SelectAllContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(KSqlParserASTERISK, 0)
}

func (s *SelectAllContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterSelectAll(s)
	}
}

func (s *SelectAllContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitSelectAll(s)
	}
}

type SelectSingleContext struct {
	*SelectItemContext
}

func NewSelectSingleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectSingleContext {
	var p = new(SelectSingleContext)

	p.SelectItemContext = NewEmptySelectItemContext()
	p.parser = parser
	p.CopyFrom(ctx.(*SelectItemContext))

	return p
}

func (s *SelectSingleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectSingleContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SelectSingleContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SelectSingleContext) AS() antlr.TerminalNode {
	return s.GetToken(KSqlParserAS, 0)
}

func (s *SelectSingleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterSelectSingle(s)
	}
}

func (s *SelectSingleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitSelectSingle(s)
	}
}

func (p *KSqlParser) SelectItem() (localctx ISelectItemContext) {
	localctx = NewSelectItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, KSqlParserRULE_selectItem)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(696)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 86, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSelectSingleContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(684)
			p.Expression()
		}
		p.SetState(689)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<KSqlParserT__7)|(1<<KSqlParserEMIT)|(1<<KSqlParserCHANGES)|(1<<KSqlParserFINAL)|(1<<KSqlParserAS))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(KSqlParserESCAPE-32))|(1<<(KSqlParserINTEGER-32))|(1<<(KSqlParserDATE-32))|(1<<(KSqlParserTIME-32))|(1<<(KSqlParserTIMESTAMP-32))|(1<<(KSqlParserINTERVAL-32))|(1<<(KSqlParserYEAR-32))|(1<<(KSqlParserMONTH-32))|(1<<(KSqlParserDAY-32))|(1<<(KSqlParserHOUR-32))|(1<<(KSqlParserMINUTE-32))|(1<<(KSqlParserSECOND-32))|(1<<(KSqlParserZONE-32)))) != 0) || (((_la-76)&-(0x1f+1)) == 0 && ((1<<uint((_la-76)))&((1<<(KSqlParserPARTITION-76))|(1<<(KSqlParserSTRUCT-76))|(1<<(KSqlParserEXPLAIN-76))|(1<<(KSqlParserANALYZE-76))|(1<<(KSqlParserTYPE-76))|(1<<(KSqlParserTYPES-76))|(1<<(KSqlParserSHOW-76))|(1<<(KSqlParserTABLES-76))|(1<<(KSqlParserCOLUMNS-76))|(1<<(KSqlParserCOLUMN-76))|(1<<(KSqlParserPARTITIONS-76))|(1<<(KSqlParserFUNCTIONS-76)))) != 0) || (((_la-108)&-(0x1f+1)) == 0 && ((1<<uint((_la-108)))&((1<<(KSqlParserFUNCTION-108))|(1<<(KSqlParserARRAY-108))|(1<<(KSqlParserMAP-108))|(1<<(KSqlParserSET-108))|(1<<(KSqlParserRESET-108))|(1<<(KSqlParserSESSION-108))|(1<<(KSqlParserKEY-108))|(1<<(KSqlParserSINK-108))|(1<<(KSqlParserSOURCE-108))|(1<<(KSqlParserPRIMARY-108))|(1<<(KSqlParserREPLACE-108))|(1<<(KSqlParserASSERT-108))|(1<<(KSqlParserADD-108)))) != 0) || (((_la-140)&-(0x1f+1)) == 0 && ((1<<uint((_la-140)))&((1<<(KSqlParserALTER-140))|(1<<(KSqlParserIF-140))|(1<<(KSqlParserIDENTIFIER-140))|(1<<(KSqlParserDIGIT_IDENTIFIER-140))|(1<<(KSqlParserQUOTED_IDENTIFIER-140))|(1<<(KSqlParserBACKQUOTED_IDENTIFIER-140))|(1<<(KSqlParserVARIABLE-140)))) != 0) {
			p.SetState(686)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == KSqlParserAS {
				{
					p.SetState(685)
					p.Match(KSqlParserAS)
				}

			}
			{
				p.SetState(688)
				p.Identifier()
			}

		}

	case 2:
		localctx = NewSelectAllContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(691)
			p.Identifier()
		}
		{
			p.SetState(692)
			p.Match(KSqlParserT__4)
		}
		{
			p.SetState(693)
			p.Match(KSqlParserASTERISK)
		}

	case 3:
		localctx = NewSelectAllContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(695)
			p.Match(KSqlParserASTERISK)
		}

	}

	return localctx
}

// IRelationContext is an interface to support dynamic dispatch.
type IRelationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelationContext differentiates from other interfaces.
	IsRelationContext()
}

type RelationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationContext() *RelationContext {
	var p = new(RelationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_relation
	return p
}

func (*RelationContext) IsRelationContext() {}

func NewRelationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationContext {
	var p = new(RelationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_relation

	return p
}

func (s *RelationContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationContext) CopyFrom(ctx *RelationContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *RelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type RelationDefaultContext struct {
	*RelationContext
}

func NewRelationDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RelationDefaultContext {
	var p = new(RelationDefaultContext)

	p.RelationContext = NewEmptyRelationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*RelationContext))

	return p
}

func (s *RelationDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationDefaultContext) AliasedRelation() IAliasedRelationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAliasedRelationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAliasedRelationContext)
}

func (s *RelationDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterRelationDefault(s)
	}
}

func (s *RelationDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitRelationDefault(s)
	}
}

type JoinRelationContext struct {
	*RelationContext
	left IAliasedRelationContext
}

func NewJoinRelationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *JoinRelationContext {
	var p = new(JoinRelationContext)

	p.RelationContext = NewEmptyRelationContext()
	p.parser = parser
	p.CopyFrom(ctx.(*RelationContext))

	return p
}

func (s *JoinRelationContext) GetLeft() IAliasedRelationContext { return s.left }

func (s *JoinRelationContext) SetLeft(v IAliasedRelationContext) { s.left = v }

func (s *JoinRelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinRelationContext) AliasedRelation() IAliasedRelationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAliasedRelationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAliasedRelationContext)
}

func (s *JoinRelationContext) AllJoinedSource() []IJoinedSourceContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IJoinedSourceContext)(nil)).Elem())
	var tst = make([]IJoinedSourceContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IJoinedSourceContext)
		}
	}

	return tst
}

func (s *JoinRelationContext) JoinedSource(i int) IJoinedSourceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJoinedSourceContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IJoinedSourceContext)
}

func (s *JoinRelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterJoinRelation(s)
	}
}

func (s *JoinRelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitJoinRelation(s)
	}
}

func (p *KSqlParser) Relation() (localctx IRelationContext) {
	localctx = NewRelationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, KSqlParserRULE_relation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(705)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 88, p.GetParserRuleContext()) {
	case 1:
		localctx = NewJoinRelationContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(698)

			var _x = p.AliasedRelation()

			localctx.(*JoinRelationContext).left = _x
		}
		p.SetState(700)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la-69)&-(0x1f+1)) == 0 && ((1<<uint((_la-69)))&((1<<(KSqlParserJOIN-69))|(1<<(KSqlParserFULL-69))|(1<<(KSqlParserINNER-69))|(1<<(KSqlParserLEFT-69)))) != 0) {
			{
				p.SetState(699)
				p.JoinedSource()
			}

			p.SetState(702)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		localctx = NewRelationDefaultContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(704)
			p.AliasedRelation()
		}

	}

	return localctx
}

// IJoinedSourceContext is an interface to support dynamic dispatch.
type IJoinedSourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJoinedSourceContext differentiates from other interfaces.
	IsJoinedSourceContext()
}

type JoinedSourceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinedSourceContext() *JoinedSourceContext {
	var p = new(JoinedSourceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_joinedSource
	return p
}

func (*JoinedSourceContext) IsJoinedSourceContext() {}

func NewJoinedSourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinedSourceContext {
	var p = new(JoinedSourceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_joinedSource

	return p
}

func (s *JoinedSourceContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinedSourceContext) JoinType() IJoinTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJoinTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJoinTypeContext)
}

func (s *JoinedSourceContext) JOIN() antlr.TerminalNode {
	return s.GetToken(KSqlParserJOIN, 0)
}

func (s *JoinedSourceContext) AliasedRelation() IAliasedRelationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAliasedRelationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAliasedRelationContext)
}

func (s *JoinedSourceContext) JoinCriteria() IJoinCriteriaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJoinCriteriaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJoinCriteriaContext)
}

func (s *JoinedSourceContext) JoinWindow() IJoinWindowContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJoinWindowContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJoinWindowContext)
}

func (s *JoinedSourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinedSourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinedSourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterJoinedSource(s)
	}
}

func (s *JoinedSourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitJoinedSource(s)
	}
}

func (p *KSqlParser) JoinedSource() (localctx IJoinedSourceContext) {
	localctx = NewJoinedSourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, KSqlParserRULE_joinedSource)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(707)
		p.JoinType()
	}
	{
		p.SetState(708)
		p.Match(KSqlParserJOIN)
	}
	{
		p.SetState(709)
		p.AliasedRelation()
	}
	p.SetState(711)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == KSqlParserWITHIN {
		{
			p.SetState(710)
			p.JoinWindow()
		}

	}
	{
		p.SetState(713)
		p.JoinCriteria()
	}

	return localctx
}

// IJoinTypeContext is an interface to support dynamic dispatch.
type IJoinTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJoinTypeContext differentiates from other interfaces.
	IsJoinTypeContext()
}

type JoinTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinTypeContext() *JoinTypeContext {
	var p = new(JoinTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_joinType
	return p
}

func (*JoinTypeContext) IsJoinTypeContext() {}

func NewJoinTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinTypeContext {
	var p = new(JoinTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_joinType

	return p
}

func (s *JoinTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinTypeContext) CopyFrom(ctx *JoinTypeContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *JoinTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type InnerJoinContext struct {
	*JoinTypeContext
}

func NewInnerJoinContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InnerJoinContext {
	var p = new(InnerJoinContext)

	p.JoinTypeContext = NewEmptyJoinTypeContext()
	p.parser = parser
	p.CopyFrom(ctx.(*JoinTypeContext))

	return p
}

func (s *InnerJoinContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InnerJoinContext) INNER() antlr.TerminalNode {
	return s.GetToken(KSqlParserINNER, 0)
}

func (s *InnerJoinContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterInnerJoin(s)
	}
}

func (s *InnerJoinContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitInnerJoin(s)
	}
}

type LeftJoinContext struct {
	*JoinTypeContext
}

func NewLeftJoinContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LeftJoinContext {
	var p = new(LeftJoinContext)

	p.JoinTypeContext = NewEmptyJoinTypeContext()
	p.parser = parser
	p.CopyFrom(ctx.(*JoinTypeContext))

	return p
}

func (s *LeftJoinContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LeftJoinContext) LEFT() antlr.TerminalNode {
	return s.GetToken(KSqlParserLEFT, 0)
}

func (s *LeftJoinContext) OUTER() antlr.TerminalNode {
	return s.GetToken(KSqlParserOUTER, 0)
}

func (s *LeftJoinContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterLeftJoin(s)
	}
}

func (s *LeftJoinContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitLeftJoin(s)
	}
}

type OuterJoinContext struct {
	*JoinTypeContext
}

func NewOuterJoinContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *OuterJoinContext {
	var p = new(OuterJoinContext)

	p.JoinTypeContext = NewEmptyJoinTypeContext()
	p.parser = parser
	p.CopyFrom(ctx.(*JoinTypeContext))

	return p
}

func (s *OuterJoinContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OuterJoinContext) FULL() antlr.TerminalNode {
	return s.GetToken(KSqlParserFULL, 0)
}

func (s *OuterJoinContext) OUTER() antlr.TerminalNode {
	return s.GetToken(KSqlParserOUTER, 0)
}

func (s *OuterJoinContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterOuterJoin(s)
	}
}

func (s *OuterJoinContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitOuterJoin(s)
	}
}

func (p *KSqlParser) JoinType() (localctx IJoinTypeContext) {
	localctx = NewJoinTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, KSqlParserRULE_joinType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(726)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KSqlParserJOIN, KSqlParserINNER:
		localctx = NewInnerJoinContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(716)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserINNER {
			{
				p.SetState(715)
				p.Match(KSqlParserINNER)
			}

		}

	case KSqlParserFULL:
		localctx = NewOuterJoinContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(718)
			p.Match(KSqlParserFULL)
		}
		p.SetState(720)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserOUTER {
			{
				p.SetState(719)
				p.Match(KSqlParserOUTER)
			}

		}

	case KSqlParserLEFT:
		localctx = NewLeftJoinContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(722)
			p.Match(KSqlParserLEFT)
		}
		p.SetState(724)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserOUTER {
			{
				p.SetState(723)
				p.Match(KSqlParserOUTER)
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IJoinWindowContext is an interface to support dynamic dispatch.
type IJoinWindowContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJoinWindowContext differentiates from other interfaces.
	IsJoinWindowContext()
}

type JoinWindowContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinWindowContext() *JoinWindowContext {
	var p = new(JoinWindowContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_joinWindow
	return p
}

func (*JoinWindowContext) IsJoinWindowContext() {}

func NewJoinWindowContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinWindowContext {
	var p = new(JoinWindowContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_joinWindow

	return p
}

func (s *JoinWindowContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinWindowContext) WITHIN() antlr.TerminalNode {
	return s.GetToken(KSqlParserWITHIN, 0)
}

func (s *JoinWindowContext) WithinExpression() IWithinExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWithinExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWithinExpressionContext)
}

func (s *JoinWindowContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinWindowContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinWindowContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterJoinWindow(s)
	}
}

func (s *JoinWindowContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitJoinWindow(s)
	}
}

func (p *KSqlParser) JoinWindow() (localctx IJoinWindowContext) {
	localctx = NewJoinWindowContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, KSqlParserRULE_joinWindow)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(728)
		p.Match(KSqlParserWITHIN)
	}
	{
		p.SetState(729)
		p.WithinExpression()
	}

	return localctx
}

// IWithinExpressionContext is an interface to support dynamic dispatch.
type IWithinExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWithinExpressionContext differentiates from other interfaces.
	IsWithinExpressionContext()
}

type WithinExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithinExpressionContext() *WithinExpressionContext {
	var p = new(WithinExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_withinExpression
	return p
}

func (*WithinExpressionContext) IsWithinExpressionContext() {}

func NewWithinExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithinExpressionContext {
	var p = new(WithinExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_withinExpression

	return p
}

func (s *WithinExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *WithinExpressionContext) CopyFrom(ctx *WithinExpressionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *WithinExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithinExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SingleJoinWindowContext struct {
	*WithinExpressionContext
}

func NewSingleJoinWindowContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SingleJoinWindowContext {
	var p = new(SingleJoinWindowContext)

	p.WithinExpressionContext = NewEmptyWithinExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*WithinExpressionContext))

	return p
}

func (s *SingleJoinWindowContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleJoinWindowContext) JoinWindowSize() IJoinWindowSizeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJoinWindowSizeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IJoinWindowSizeContext)
}

func (s *SingleJoinWindowContext) GracePeriodClause() IGracePeriodClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGracePeriodClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGracePeriodClauseContext)
}

func (s *SingleJoinWindowContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterSingleJoinWindow(s)
	}
}

func (s *SingleJoinWindowContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitSingleJoinWindow(s)
	}
}

type JoinWindowWithBeforeAndAfterContext struct {
	*WithinExpressionContext
}

func NewJoinWindowWithBeforeAndAfterContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *JoinWindowWithBeforeAndAfterContext {
	var p = new(JoinWindowWithBeforeAndAfterContext)

	p.WithinExpressionContext = NewEmptyWithinExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*WithinExpressionContext))

	return p
}

func (s *JoinWindowWithBeforeAndAfterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinWindowWithBeforeAndAfterContext) AllJoinWindowSize() []IJoinWindowSizeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IJoinWindowSizeContext)(nil)).Elem())
	var tst = make([]IJoinWindowSizeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IJoinWindowSizeContext)
		}
	}

	return tst
}

func (s *JoinWindowWithBeforeAndAfterContext) JoinWindowSize(i int) IJoinWindowSizeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IJoinWindowSizeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IJoinWindowSizeContext)
}

func (s *JoinWindowWithBeforeAndAfterContext) GracePeriodClause() IGracePeriodClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGracePeriodClauseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGracePeriodClauseContext)
}

func (s *JoinWindowWithBeforeAndAfterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterJoinWindowWithBeforeAndAfter(s)
	}
}

func (s *JoinWindowWithBeforeAndAfterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitJoinWindowWithBeforeAndAfter(s)
	}
}

func (p *KSqlParser) WithinExpression() (localctx IWithinExpressionContext) {
	localctx = NewWithinExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, KSqlParserRULE_withinExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(743)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KSqlParserT__2:
		localctx = NewJoinWindowWithBeforeAndAfterContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(731)
			p.Match(KSqlParserT__2)
		}
		{
			p.SetState(732)
			p.JoinWindowSize()
		}
		{
			p.SetState(733)
			p.Match(KSqlParserT__1)
		}
		{
			p.SetState(734)
			p.JoinWindowSize()
		}
		{
			p.SetState(735)
			p.Match(KSqlParserT__3)
		}
		p.SetState(737)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserGRACE {
			{
				p.SetState(736)
				p.GracePeriodClause()
			}

		}

	case KSqlParserMINUS, KSqlParserINTEGER_VALUE, KSqlParserDECIMAL_VALUE, KSqlParserFLOATING_POINT_VALUE:
		localctx = NewSingleJoinWindowContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(739)
			p.JoinWindowSize()
		}
		p.SetState(741)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserGRACE {
			{
				p.SetState(740)
				p.GracePeriodClause()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IJoinWindowSizeContext is an interface to support dynamic dispatch.
type IJoinWindowSizeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJoinWindowSizeContext differentiates from other interfaces.
	IsJoinWindowSizeContext()
}

type JoinWindowSizeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinWindowSizeContext() *JoinWindowSizeContext {
	var p = new(JoinWindowSizeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_joinWindowSize
	return p
}

func (*JoinWindowSizeContext) IsJoinWindowSizeContext() {}

func NewJoinWindowSizeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinWindowSizeContext {
	var p = new(JoinWindowSizeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_joinWindowSize

	return p
}

func (s *JoinWindowSizeContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinWindowSizeContext) Number() INumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *JoinWindowSizeContext) WindowUnit() IWindowUnitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWindowUnitContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWindowUnitContext)
}

func (s *JoinWindowSizeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinWindowSizeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinWindowSizeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterJoinWindowSize(s)
	}
}

func (s *JoinWindowSizeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitJoinWindowSize(s)
	}
}

func (p *KSqlParser) JoinWindowSize() (localctx IJoinWindowSizeContext) {
	localctx = NewJoinWindowSizeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, KSqlParserRULE_joinWindowSize)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(745)
		p.Number()
	}
	{
		p.SetState(746)
		p.WindowUnit()
	}

	return localctx
}

// IJoinCriteriaContext is an interface to support dynamic dispatch.
type IJoinCriteriaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsJoinCriteriaContext differentiates from other interfaces.
	IsJoinCriteriaContext()
}

type JoinCriteriaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinCriteriaContext() *JoinCriteriaContext {
	var p = new(JoinCriteriaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_joinCriteria
	return p
}

func (*JoinCriteriaContext) IsJoinCriteriaContext() {}

func NewJoinCriteriaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinCriteriaContext {
	var p = new(JoinCriteriaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_joinCriteria

	return p
}

func (s *JoinCriteriaContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinCriteriaContext) ON() antlr.TerminalNode {
	return s.GetToken(KSqlParserON, 0)
}

func (s *JoinCriteriaContext) BooleanExpression() IBooleanExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *JoinCriteriaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinCriteriaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinCriteriaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterJoinCriteria(s)
	}
}

func (s *JoinCriteriaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitJoinCriteria(s)
	}
}

func (p *KSqlParser) JoinCriteria() (localctx IJoinCriteriaContext) {
	localctx = NewJoinCriteriaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, KSqlParserRULE_joinCriteria)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(748)
		p.Match(KSqlParserON)
	}
	{
		p.SetState(749)
		p.booleanExpression(0)
	}

	return localctx
}

// IAliasedRelationContext is an interface to support dynamic dispatch.
type IAliasedRelationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAliasedRelationContext differentiates from other interfaces.
	IsAliasedRelationContext()
}

type AliasedRelationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAliasedRelationContext() *AliasedRelationContext {
	var p = new(AliasedRelationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_aliasedRelation
	return p
}

func (*AliasedRelationContext) IsAliasedRelationContext() {}

func NewAliasedRelationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AliasedRelationContext {
	var p = new(AliasedRelationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_aliasedRelation

	return p
}

func (s *AliasedRelationContext) GetParser() antlr.Parser { return s.parser }

func (s *AliasedRelationContext) RelationPrimary() IRelationPrimaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelationPrimaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRelationPrimaryContext)
}

func (s *AliasedRelationContext) SourceName() ISourceNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISourceNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISourceNameContext)
}

func (s *AliasedRelationContext) AS() antlr.TerminalNode {
	return s.GetToken(KSqlParserAS, 0)
}

func (s *AliasedRelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AliasedRelationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AliasedRelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterAliasedRelation(s)
	}
}

func (s *AliasedRelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitAliasedRelation(s)
	}
}

func (p *KSqlParser) AliasedRelation() (localctx IAliasedRelationContext) {
	localctx = NewAliasedRelationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, KSqlParserRULE_aliasedRelation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(751)
		p.RelationPrimary()
	}
	p.SetState(756)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 98, p.GetParserRuleContext()) == 1 {
		p.SetState(753)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserAS {
			{
				p.SetState(752)
				p.Match(KSqlParserAS)
			}

		}
		{
			p.SetState(755)
			p.SourceName()
		}

	}

	return localctx
}

// IColumnsContext is an interface to support dynamic dispatch.
type IColumnsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsColumnsContext differentiates from other interfaces.
	IsColumnsContext()
}

type ColumnsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnsContext() *ColumnsContext {
	var p = new(ColumnsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_columns
	return p
}

func (*ColumnsContext) IsColumnsContext() {}

func NewColumnsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnsContext {
	var p = new(ColumnsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_columns

	return p
}

func (s *ColumnsContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnsContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *ColumnsContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterColumns(s)
	}
}

func (s *ColumnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitColumns(s)
	}
}

func (p *KSqlParser) Columns() (localctx IColumnsContext) {
	localctx = NewColumnsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, KSqlParserRULE_columns)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(758)
		p.Match(KSqlParserT__2)
	}
	{
		p.SetState(759)
		p.Identifier()
	}
	p.SetState(764)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == KSqlParserT__1 {
		{
			p.SetState(760)
			p.Match(KSqlParserT__1)
		}
		{
			p.SetState(761)
			p.Identifier()
		}

		p.SetState(766)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(767)
		p.Match(KSqlParserT__3)
	}

	return localctx
}

// IRelationPrimaryContext is an interface to support dynamic dispatch.
type IRelationPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelationPrimaryContext differentiates from other interfaces.
	IsRelationPrimaryContext()
}

type RelationPrimaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationPrimaryContext() *RelationPrimaryContext {
	var p = new(RelationPrimaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_relationPrimary
	return p
}

func (*RelationPrimaryContext) IsRelationPrimaryContext() {}

func NewRelationPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationPrimaryContext {
	var p = new(RelationPrimaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_relationPrimary

	return p
}

func (s *RelationPrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationPrimaryContext) CopyFrom(ctx *RelationPrimaryContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *RelationPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationPrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type TableNameContext struct {
	*RelationPrimaryContext
}

func NewTableNameContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableNameContext {
	var p = new(TableNameContext)

	p.RelationPrimaryContext = NewEmptyRelationPrimaryContext()
	p.parser = parser
	p.CopyFrom(ctx.(*RelationPrimaryContext))

	return p
}

func (s *TableNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableNameContext) SourceName() ISourceNameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISourceNameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISourceNameContext)
}

func (s *TableNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterTableName(s)
	}
}

func (s *TableNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitTableName(s)
	}
}

func (p *KSqlParser) RelationPrimary() (localctx IRelationPrimaryContext) {
	localctx = NewRelationPrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, KSqlParserRULE_relationPrimary)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	localctx = NewTableNameContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(769)
		p.SourceName()
	}

	return localctx
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_expression
	return p
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) BooleanExpression() IBooleanExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (p *KSqlParser) Expression() (localctx IExpressionContext) {
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, KSqlParserRULE_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(771)
		p.booleanExpression(0)
	}

	return localctx
}

// IBooleanExpressionContext is an interface to support dynamic dispatch.
type IBooleanExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBooleanExpressionContext differentiates from other interfaces.
	IsBooleanExpressionContext()
}

type BooleanExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanExpressionContext() *BooleanExpressionContext {
	var p = new(BooleanExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_booleanExpression
	return p
}

func (*BooleanExpressionContext) IsBooleanExpressionContext() {}

func NewBooleanExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanExpressionContext {
	var p = new(BooleanExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_booleanExpression

	return p
}

func (s *BooleanExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanExpressionContext) CopyFrom(ctx *BooleanExpressionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *BooleanExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LogicalNotContext struct {
	*BooleanExpressionContext
}

func NewLogicalNotContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalNotContext {
	var p = new(LogicalNotContext)

	p.BooleanExpressionContext = NewEmptyBooleanExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*BooleanExpressionContext))

	return p
}

func (s *LogicalNotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalNotContext) NOT() antlr.TerminalNode {
	return s.GetToken(KSqlParserNOT, 0)
}

func (s *LogicalNotContext) BooleanExpression() IBooleanExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *LogicalNotContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterLogicalNot(s)
	}
}

func (s *LogicalNotContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitLogicalNot(s)
	}
}

type BooleanDefaultContext struct {
	*BooleanExpressionContext
}

func NewBooleanDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BooleanDefaultContext {
	var p = new(BooleanDefaultContext)

	p.BooleanExpressionContext = NewEmptyBooleanExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*BooleanExpressionContext))

	return p
}

func (s *BooleanDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanDefaultContext) Predicated() IPredicatedContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPredicatedContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPredicatedContext)
}

func (s *BooleanDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterBooleanDefault(s)
	}
}

func (s *BooleanDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitBooleanDefault(s)
	}
}

type LogicalBinaryContext struct {
	*BooleanExpressionContext
	left     IBooleanExpressionContext
	operator antlr.Token
	right    IBooleanExpressionContext
}

func NewLogicalBinaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalBinaryContext {
	var p = new(LogicalBinaryContext)

	p.BooleanExpressionContext = NewEmptyBooleanExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*BooleanExpressionContext))

	return p
}

func (s *LogicalBinaryContext) GetOperator() antlr.Token { return s.operator }

func (s *LogicalBinaryContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *LogicalBinaryContext) GetLeft() IBooleanExpressionContext { return s.left }

func (s *LogicalBinaryContext) GetRight() IBooleanExpressionContext { return s.right }

func (s *LogicalBinaryContext) SetLeft(v IBooleanExpressionContext) { s.left = v }

func (s *LogicalBinaryContext) SetRight(v IBooleanExpressionContext) { s.right = v }

func (s *LogicalBinaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalBinaryContext) AllBooleanExpression() []IBooleanExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBooleanExpressionContext)(nil)).Elem())
	var tst = make([]IBooleanExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBooleanExpressionContext)
		}
	}

	return tst
}

func (s *LogicalBinaryContext) BooleanExpression(i int) IBooleanExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *LogicalBinaryContext) AND() antlr.TerminalNode {
	return s.GetToken(KSqlParserAND, 0)
}

func (s *LogicalBinaryContext) OR() antlr.TerminalNode {
	return s.GetToken(KSqlParserOR, 0)
}

func (s *LogicalBinaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterLogicalBinary(s)
	}
}

func (s *LogicalBinaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitLogicalBinary(s)
	}
}

func (p *KSqlParser) BooleanExpression() (localctx IBooleanExpressionContext) {
	return p.booleanExpression(0)
}

func (p *KSqlParser) booleanExpression(_p int) (localctx IBooleanExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewBooleanExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IBooleanExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 80
	p.EnterRecursionRule(localctx, 80, KSqlParserRULE_booleanExpression, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(777)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KSqlParserT__2, KSqlParserT__7, KSqlParserEMIT, KSqlParserCHANGES, KSqlParserFINAL, KSqlParserESCAPE, KSqlParserNULL, KSqlParserTRUE, KSqlParserFALSE, KSqlParserINTEGER, KSqlParserDATE, KSqlParserTIME, KSqlParserTIMESTAMP, KSqlParserINTERVAL, KSqlParserYEAR, KSqlParserMONTH, KSqlParserDAY, KSqlParserHOUR, KSqlParserMINUTE, KSqlParserSECOND, KSqlParserZONE, KSqlParserCASE, KSqlParserPARTITION, KSqlParserSTRUCT, KSqlParserEXPLAIN, KSqlParserANALYZE, KSqlParserTYPE, KSqlParserTYPES, KSqlParserCAST, KSqlParserSHOW, KSqlParserTABLES, KSqlParserCOLUMNS, KSqlParserCOLUMN, KSqlParserPARTITIONS, KSqlParserFUNCTIONS, KSqlParserFUNCTION, KSqlParserARRAY, KSqlParserMAP, KSqlParserSET, KSqlParserRESET, KSqlParserSESSION, KSqlParserKEY, KSqlParserSINK, KSqlParserSOURCE, KSqlParserPRIMARY, KSqlParserREPLACE, KSqlParserASSERT, KSqlParserADD, KSqlParserALTER, KSqlParserIF, KSqlParserPLUS, KSqlParserMINUS, KSqlParserSTRING, KSqlParserINTEGER_VALUE, KSqlParserDECIMAL_VALUE, KSqlParserFLOATING_POINT_VALUE, KSqlParserIDENTIFIER, KSqlParserDIGIT_IDENTIFIER, KSqlParserQUOTED_IDENTIFIER, KSqlParserBACKQUOTED_IDENTIFIER, KSqlParserVARIABLE:
		localctx = NewBooleanDefaultContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(774)
			p.Predicated()
		}

	case KSqlParserNOT:
		localctx = NewLogicalNotContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(775)
			p.Match(KSqlParserNOT)
		}
		{
			p.SetState(776)
			p.booleanExpression(3)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(787)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 102, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(785)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 101, p.GetParserRuleContext()) {
			case 1:
				localctx = NewLogicalBinaryContext(p, NewBooleanExpressionContext(p, _parentctx, _parentState))
				localctx.(*LogicalBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, KSqlParserRULE_booleanExpression)
				p.SetState(779)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(780)

					var _m = p.Match(KSqlParserAND)

					localctx.(*LogicalBinaryContext).operator = _m
				}
				{
					p.SetState(781)

					var _x = p.booleanExpression(3)

					localctx.(*LogicalBinaryContext).right = _x
				}

			case 2:
				localctx = NewLogicalBinaryContext(p, NewBooleanExpressionContext(p, _parentctx, _parentState))
				localctx.(*LogicalBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, KSqlParserRULE_booleanExpression)
				p.SetState(782)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(783)

					var _m = p.Match(KSqlParserOR)

					localctx.(*LogicalBinaryContext).operator = _m
				}
				{
					p.SetState(784)

					var _x = p.booleanExpression(2)

					localctx.(*LogicalBinaryContext).right = _x
				}

			}

		}
		p.SetState(789)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 102, p.GetParserRuleContext())
	}

	return localctx
}

// IPredicatedContext is an interface to support dynamic dispatch.
type IPredicatedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_valueExpression returns the _valueExpression rule contexts.
	Get_valueExpression() IValueExpressionContext

	// Set_valueExpression sets the _valueExpression rule contexts.
	Set_valueExpression(IValueExpressionContext)

	// IsPredicatedContext differentiates from other interfaces.
	IsPredicatedContext()
}

type PredicatedContext struct {
	*antlr.BaseParserRuleContext
	parser           antlr.Parser
	_valueExpression IValueExpressionContext
}

func NewEmptyPredicatedContext() *PredicatedContext {
	var p = new(PredicatedContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_predicated
	return p
}

func (*PredicatedContext) IsPredicatedContext() {}

func NewPredicatedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PredicatedContext {
	var p = new(PredicatedContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_predicated

	return p
}

func (s *PredicatedContext) GetParser() antlr.Parser { return s.parser }

func (s *PredicatedContext) Get_valueExpression() IValueExpressionContext { return s._valueExpression }

func (s *PredicatedContext) Set_valueExpression(v IValueExpressionContext) { s._valueExpression = v }

func (s *PredicatedContext) ValueExpression() IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *PredicatedContext) Predicate() IPredicateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPredicateContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *PredicatedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicatedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PredicatedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterPredicated(s)
	}
}

func (s *PredicatedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitPredicated(s)
	}
}

func (p *KSqlParser) Predicated() (localctx IPredicatedContext) {
	localctx = NewPredicatedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, KSqlParserRULE_predicated)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(790)

		var _x = p.valueExpression(0)

		localctx.(*PredicatedContext)._valueExpression = _x
	}
	p.SetState(792)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 103, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(791)
			p.Predicate(localctx.(*PredicatedContext).Get_valueExpression())
		}

	}

	return localctx
}

// IPredicateContext is an interface to support dynamic dispatch.
type IPredicateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetValue returns the value attribute.
	GetValue() antlr.ParserRuleContext

	// SetValue sets the value attribute.
	SetValue(antlr.ParserRuleContext)

	// IsPredicateContext differentiates from other interfaces.
	IsPredicateContext()
}

type PredicateContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	value  antlr.ParserRuleContext
}

func NewEmptyPredicateContext() *PredicateContext {
	var p = new(PredicateContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_predicate
	return p
}

func (*PredicateContext) IsPredicateContext() {}

func NewPredicateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int, value antlr.ParserRuleContext) *PredicateContext {
	var p = new(PredicateContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_predicate

	p.value = value

	return p
}

func (s *PredicateContext) GetParser() antlr.Parser { return s.parser }

func (s *PredicateContext) GetValue() antlr.ParserRuleContext { return s.value }

func (s *PredicateContext) SetValue(v antlr.ParserRuleContext) { s.value = v }

func (s *PredicateContext) CopyFrom(ctx *PredicateContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
	s.value = ctx.value
}

func (s *PredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ComparisonContext struct {
	*PredicateContext
	right IValueExpressionContext
}

func NewComparisonContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ComparisonContext {
	var p = new(ComparisonContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *ComparisonContext) GetRight() IValueExpressionContext { return s.right }

func (s *ComparisonContext) SetRight(v IValueExpressionContext) { s.right = v }

func (s *ComparisonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonContext) ComparisonOperator() IComparisonOperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComparisonOperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *ComparisonContext) ValueExpression() IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ComparisonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterComparison(s)
	}
}

func (s *ComparisonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitComparison(s)
	}
}

type LikeContext struct {
	*PredicateContext
	pattern IValueExpressionContext
	escape  antlr.Token
}

func NewLikeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LikeContext {
	var p = new(LikeContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *LikeContext) GetEscape() antlr.Token { return s.escape }

func (s *LikeContext) SetEscape(v antlr.Token) { s.escape = v }

func (s *LikeContext) GetPattern() IValueExpressionContext { return s.pattern }

func (s *LikeContext) SetPattern(v IValueExpressionContext) { s.pattern = v }

func (s *LikeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LikeContext) LIKE() antlr.TerminalNode {
	return s.GetToken(KSqlParserLIKE, 0)
}

func (s *LikeContext) ValueExpression() IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *LikeContext) NOT() antlr.TerminalNode {
	return s.GetToken(KSqlParserNOT, 0)
}

func (s *LikeContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(KSqlParserESCAPE, 0)
}

func (s *LikeContext) STRING() antlr.TerminalNode {
	return s.GetToken(KSqlParserSTRING, 0)
}

func (s *LikeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterLike(s)
	}
}

func (s *LikeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitLike(s)
	}
}

type DistinctFromContext struct {
	*PredicateContext
	right IValueExpressionContext
}

func NewDistinctFromContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DistinctFromContext {
	var p = new(DistinctFromContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *DistinctFromContext) GetRight() IValueExpressionContext { return s.right }

func (s *DistinctFromContext) SetRight(v IValueExpressionContext) { s.right = v }

func (s *DistinctFromContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DistinctFromContext) IS() antlr.TerminalNode {
	return s.GetToken(KSqlParserIS, 0)
}

func (s *DistinctFromContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(KSqlParserDISTINCT, 0)
}

func (s *DistinctFromContext) FROM() antlr.TerminalNode {
	return s.GetToken(KSqlParserFROM, 0)
}

func (s *DistinctFromContext) ValueExpression() IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *DistinctFromContext) NOT() antlr.TerminalNode {
	return s.GetToken(KSqlParserNOT, 0)
}

func (s *DistinctFromContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterDistinctFrom(s)
	}
}

func (s *DistinctFromContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitDistinctFrom(s)
	}
}

type InListContext struct {
	*PredicateContext
}

func NewInListContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InListContext {
	var p = new(InListContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *InListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InListContext) IN() antlr.TerminalNode {
	return s.GetToken(KSqlParserIN, 0)
}

func (s *InListContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *InListContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *InListContext) NOT() antlr.TerminalNode {
	return s.GetToken(KSqlParserNOT, 0)
}

func (s *InListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterInList(s)
	}
}

func (s *InListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitInList(s)
	}
}

type NullPredicateContext struct {
	*PredicateContext
}

func NewNullPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NullPredicateContext {
	var p = new(NullPredicateContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *NullPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullPredicateContext) IS() antlr.TerminalNode {
	return s.GetToken(KSqlParserIS, 0)
}

func (s *NullPredicateContext) NULL() antlr.TerminalNode {
	return s.GetToken(KSqlParserNULL, 0)
}

func (s *NullPredicateContext) NOT() antlr.TerminalNode {
	return s.GetToken(KSqlParserNOT, 0)
}

func (s *NullPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterNullPredicate(s)
	}
}

func (s *NullPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitNullPredicate(s)
	}
}

type BetweenContext struct {
	*PredicateContext
	lower IValueExpressionContext
	upper IValueExpressionContext
}

func NewBetweenContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BetweenContext {
	var p = new(BetweenContext)

	p.PredicateContext = NewEmptyPredicateContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PredicateContext))

	return p
}

func (s *BetweenContext) GetLower() IValueExpressionContext { return s.lower }

func (s *BetweenContext) GetUpper() IValueExpressionContext { return s.upper }

func (s *BetweenContext) SetLower(v IValueExpressionContext) { s.lower = v }

func (s *BetweenContext) SetUpper(v IValueExpressionContext) { s.upper = v }

func (s *BetweenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BetweenContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(KSqlParserBETWEEN, 0)
}

func (s *BetweenContext) AND() antlr.TerminalNode {
	return s.GetToken(KSqlParserAND, 0)
}

func (s *BetweenContext) AllValueExpression() []IValueExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem())
	var tst = make([]IValueExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueExpressionContext)
		}
	}

	return tst
}

func (s *BetweenContext) ValueExpression(i int) IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *BetweenContext) NOT() antlr.TerminalNode {
	return s.GetToken(KSqlParserNOT, 0)
}

func (s *BetweenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterBetween(s)
	}
}

func (s *BetweenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitBetween(s)
	}
}

func (p *KSqlParser) Predicate(value antlr.ParserRuleContext) (localctx IPredicateContext) {
	localctx = NewPredicateContext(p, p.GetParserRuleContext(), p.GetState(), value)
	p.EnterRule(localctx, 84, KSqlParserRULE_predicate)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(841)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 111, p.GetParserRuleContext()) {
	case 1:
		localctx = NewComparisonContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(794)
			p.ComparisonOperator()
		}
		{
			p.SetState(795)

			var _x = p.valueExpression(0)

			localctx.(*ComparisonContext).right = _x
		}

	case 2:
		localctx = NewBetweenContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(798)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserNOT {
			{
				p.SetState(797)
				p.Match(KSqlParserNOT)
			}

		}
		{
			p.SetState(800)
			p.Match(KSqlParserBETWEEN)
		}
		{
			p.SetState(801)

			var _x = p.valueExpression(0)

			localctx.(*BetweenContext).lower = _x
		}
		{
			p.SetState(802)
			p.Match(KSqlParserAND)
		}
		{
			p.SetState(803)

			var _x = p.valueExpression(0)

			localctx.(*BetweenContext).upper = _x
		}

	case 3:
		localctx = NewInListContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		p.SetState(806)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserNOT {
			{
				p.SetState(805)
				p.Match(KSqlParserNOT)
			}

		}
		{
			p.SetState(808)
			p.Match(KSqlParserIN)
		}
		{
			p.SetState(809)
			p.Match(KSqlParserT__2)
		}
		{
			p.SetState(810)
			p.Expression()
		}
		p.SetState(815)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KSqlParserT__1 {
			{
				p.SetState(811)
				p.Match(KSqlParserT__1)
			}
			{
				p.SetState(812)
				p.Expression()
			}

			p.SetState(817)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(818)
			p.Match(KSqlParserT__3)
		}

	case 4:
		localctx = NewLikeContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		p.SetState(821)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserNOT {
			{
				p.SetState(820)
				p.Match(KSqlParserNOT)
			}

		}
		{
			p.SetState(823)
			p.Match(KSqlParserLIKE)
		}
		{
			p.SetState(824)

			var _x = p.valueExpression(0)

			localctx.(*LikeContext).pattern = _x
		}
		p.SetState(827)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 108, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(825)
				p.Match(KSqlParserESCAPE)
			}
			{
				p.SetState(826)

				var _m = p.Match(KSqlParserSTRING)

				localctx.(*LikeContext).escape = _m
			}

		}

	case 5:
		localctx = NewNullPredicateContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(829)
			p.Match(KSqlParserIS)
		}
		p.SetState(831)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserNOT {
			{
				p.SetState(830)
				p.Match(KSqlParserNOT)
			}

		}
		{
			p.SetState(833)
			p.Match(KSqlParserNULL)
		}

	case 6:
		localctx = NewDistinctFromContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(834)
			p.Match(KSqlParserIS)
		}
		p.SetState(836)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserNOT {
			{
				p.SetState(835)
				p.Match(KSqlParserNOT)
			}

		}
		{
			p.SetState(838)
			p.Match(KSqlParserDISTINCT)
		}
		{
			p.SetState(839)
			p.Match(KSqlParserFROM)
		}
		{
			p.SetState(840)

			var _x = p.valueExpression(0)

			localctx.(*DistinctFromContext).right = _x
		}

	}

	return localctx
}

// IValueExpressionContext is an interface to support dynamic dispatch.
type IValueExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValueExpressionContext differentiates from other interfaces.
	IsValueExpressionContext()
}

type ValueExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueExpressionContext() *ValueExpressionContext {
	var p = new(ValueExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_valueExpression
	return p
}

func (*ValueExpressionContext) IsValueExpressionContext() {}

func NewValueExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueExpressionContext {
	var p = new(ValueExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_valueExpression

	return p
}

func (s *ValueExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueExpressionContext) CopyFrom(ctx *ValueExpressionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *ValueExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ValueExpressionDefaultContext struct {
	*ValueExpressionContext
}

func NewValueExpressionDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ValueExpressionDefaultContext {
	var p = new(ValueExpressionDefaultContext)

	p.ValueExpressionContext = NewEmptyValueExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueExpressionContext))

	return p
}

func (s *ValueExpressionDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueExpressionDefaultContext) PrimaryExpression() IPrimaryExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *ValueExpressionDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterValueExpressionDefault(s)
	}
}

func (s *ValueExpressionDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitValueExpressionDefault(s)
	}
}

type ConcatenationContext struct {
	*ValueExpressionContext
	left  IValueExpressionContext
	right IValueExpressionContext
}

func NewConcatenationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConcatenationContext {
	var p = new(ConcatenationContext)

	p.ValueExpressionContext = NewEmptyValueExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueExpressionContext))

	return p
}

func (s *ConcatenationContext) GetLeft() IValueExpressionContext { return s.left }

func (s *ConcatenationContext) GetRight() IValueExpressionContext { return s.right }

func (s *ConcatenationContext) SetLeft(v IValueExpressionContext) { s.left = v }

func (s *ConcatenationContext) SetRight(v IValueExpressionContext) { s.right = v }

func (s *ConcatenationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConcatenationContext) CONCAT() antlr.TerminalNode {
	return s.GetToken(KSqlParserCONCAT, 0)
}

func (s *ConcatenationContext) AllValueExpression() []IValueExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem())
	var tst = make([]IValueExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueExpressionContext)
		}
	}

	return tst
}

func (s *ConcatenationContext) ValueExpression(i int) IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ConcatenationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterConcatenation(s)
	}
}

func (s *ConcatenationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitConcatenation(s)
	}
}

type ArithmeticBinaryContext struct {
	*ValueExpressionContext
	left     IValueExpressionContext
	operator antlr.Token
	right    IValueExpressionContext
}

func NewArithmeticBinaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArithmeticBinaryContext {
	var p = new(ArithmeticBinaryContext)

	p.ValueExpressionContext = NewEmptyValueExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueExpressionContext))

	return p
}

func (s *ArithmeticBinaryContext) GetOperator() antlr.Token { return s.operator }

func (s *ArithmeticBinaryContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *ArithmeticBinaryContext) GetLeft() IValueExpressionContext { return s.left }

func (s *ArithmeticBinaryContext) GetRight() IValueExpressionContext { return s.right }

func (s *ArithmeticBinaryContext) SetLeft(v IValueExpressionContext) { s.left = v }

func (s *ArithmeticBinaryContext) SetRight(v IValueExpressionContext) { s.right = v }

func (s *ArithmeticBinaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArithmeticBinaryContext) AllValueExpression() []IValueExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem())
	var tst = make([]IValueExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValueExpressionContext)
		}
	}

	return tst
}

func (s *ArithmeticBinaryContext) ValueExpression(i int) IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ArithmeticBinaryContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(KSqlParserASTERISK, 0)
}

func (s *ArithmeticBinaryContext) SLASH() antlr.TerminalNode {
	return s.GetToken(KSqlParserSLASH, 0)
}

func (s *ArithmeticBinaryContext) PERCENT() antlr.TerminalNode {
	return s.GetToken(KSqlParserPERCENT, 0)
}

func (s *ArithmeticBinaryContext) PLUS() antlr.TerminalNode {
	return s.GetToken(KSqlParserPLUS, 0)
}

func (s *ArithmeticBinaryContext) MINUS() antlr.TerminalNode {
	return s.GetToken(KSqlParserMINUS, 0)
}

func (s *ArithmeticBinaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterArithmeticBinary(s)
	}
}

func (s *ArithmeticBinaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitArithmeticBinary(s)
	}
}

type ArithmeticUnaryContext struct {
	*ValueExpressionContext
	operator antlr.Token
}

func NewArithmeticUnaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArithmeticUnaryContext {
	var p = new(ArithmeticUnaryContext)

	p.ValueExpressionContext = NewEmptyValueExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueExpressionContext))

	return p
}

func (s *ArithmeticUnaryContext) GetOperator() antlr.Token { return s.operator }

func (s *ArithmeticUnaryContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *ArithmeticUnaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArithmeticUnaryContext) ValueExpression() IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ArithmeticUnaryContext) MINUS() antlr.TerminalNode {
	return s.GetToken(KSqlParserMINUS, 0)
}

func (s *ArithmeticUnaryContext) PLUS() antlr.TerminalNode {
	return s.GetToken(KSqlParserPLUS, 0)
}

func (s *ArithmeticUnaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterArithmeticUnary(s)
	}
}

func (s *ArithmeticUnaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitArithmeticUnary(s)
	}
}

type AtTimeZoneContext struct {
	*ValueExpressionContext
}

func NewAtTimeZoneContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AtTimeZoneContext {
	var p = new(AtTimeZoneContext)

	p.ValueExpressionContext = NewEmptyValueExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*ValueExpressionContext))

	return p
}

func (s *AtTimeZoneContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtTimeZoneContext) ValueExpression() IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *AtTimeZoneContext) AT() antlr.TerminalNode {
	return s.GetToken(KSqlParserAT, 0)
}

func (s *AtTimeZoneContext) TimeZoneSpecifier() ITimeZoneSpecifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITimeZoneSpecifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITimeZoneSpecifierContext)
}

func (s *AtTimeZoneContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterAtTimeZone(s)
	}
}

func (s *AtTimeZoneContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitAtTimeZone(s)
	}
}

func (p *KSqlParser) ValueExpression() (localctx IValueExpressionContext) {
	return p.valueExpression(0)
}

func (p *KSqlParser) valueExpression(_p int) (localctx IValueExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewValueExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IValueExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 86
	p.EnterRecursionRule(localctx, 86, KSqlParserRULE_valueExpression, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(847)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 112, p.GetParserRuleContext()) {
	case 1:
		localctx = NewValueExpressionDefaultContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(844)
			p.primaryExpression(0)
		}

	case 2:
		localctx = NewArithmeticUnaryContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(845)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ArithmeticUnaryContext).operator = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == KSqlParserPLUS || _la == KSqlParserMINUS) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ArithmeticUnaryContext).operator = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(846)
			p.valueExpression(4)
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(863)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 114, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(861)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 113, p.GetParserRuleContext()) {
			case 1:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, KSqlParserRULE_valueExpression)
				p.SetState(849)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				{
					p.SetState(850)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ArithmeticBinaryContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !(((_la-154)&-(0x1f+1)) == 0 && ((1<<uint((_la-154)))&((1<<(KSqlParserASTERISK-154))|(1<<(KSqlParserSLASH-154))|(1<<(KSqlParserPERCENT-154)))) != 0) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ArithmeticBinaryContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(851)

					var _x = p.valueExpression(4)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 2:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, KSqlParserRULE_valueExpression)
				p.SetState(852)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(853)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ArithmeticBinaryContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == KSqlParserPLUS || _la == KSqlParserMINUS) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ArithmeticBinaryContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(854)

					var _x = p.valueExpression(3)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 3:
				localctx = NewConcatenationContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ConcatenationContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, KSqlParserRULE_valueExpression)
				p.SetState(855)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(856)
					p.Match(KSqlParserCONCAT)
				}
				{
					p.SetState(857)

					var _x = p.valueExpression(2)

					localctx.(*ConcatenationContext).right = _x
				}

			case 4:
				localctx = NewAtTimeZoneContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, KSqlParserRULE_valueExpression)
				p.SetState(858)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
				}
				{
					p.SetState(859)
					p.Match(KSqlParserAT)
				}
				{
					p.SetState(860)
					p.TimeZoneSpecifier()
				}

			}

		}
		p.SetState(865)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 114, p.GetParserRuleContext())
	}

	return localctx
}

// IPrimaryExpressionContext is an interface to support dynamic dispatch.
type IPrimaryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimaryExpressionContext differentiates from other interfaces.
	IsPrimaryExpressionContext()
}

type PrimaryExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryExpressionContext() *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_primaryExpression
	return p
}

func (*PrimaryExpressionContext) IsPrimaryExpressionContext() {}

func NewPrimaryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_primaryExpression

	return p
}

func (s *PrimaryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryExpressionContext) CopyFrom(ctx *PrimaryExpressionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *PrimaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DereferenceContext struct {
	*PrimaryExpressionContext
	base      IPrimaryExpressionContext
	fieldName IIdentifierContext
}

func NewDereferenceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DereferenceContext {
	var p = new(DereferenceContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *DereferenceContext) GetBase() IPrimaryExpressionContext { return s.base }

func (s *DereferenceContext) GetFieldName() IIdentifierContext { return s.fieldName }

func (s *DereferenceContext) SetBase(v IPrimaryExpressionContext) { s.base = v }

func (s *DereferenceContext) SetFieldName(v IIdentifierContext) { s.fieldName = v }

func (s *DereferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DereferenceContext) STRUCT_FIELD_REF() antlr.TerminalNode {
	return s.GetToken(KSqlParserSTRUCT_FIELD_REF, 0)
}

func (s *DereferenceContext) PrimaryExpression() IPrimaryExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *DereferenceContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DereferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterDereference(s)
	}
}

func (s *DereferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitDereference(s)
	}
}

type SimpleCaseContext struct {
	*PrimaryExpressionContext
	elseExpression IExpressionContext
}

func NewSimpleCaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleCaseContext {
	var p = new(SimpleCaseContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SimpleCaseContext) GetElseExpression() IExpressionContext { return s.elseExpression }

func (s *SimpleCaseContext) SetElseExpression(v IExpressionContext) { s.elseExpression = v }

func (s *SimpleCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleCaseContext) CASE() antlr.TerminalNode {
	return s.GetToken(KSqlParserCASE, 0)
}

func (s *SimpleCaseContext) ValueExpression() IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *SimpleCaseContext) END() antlr.TerminalNode {
	return s.GetToken(KSqlParserEND, 0)
}

func (s *SimpleCaseContext) AllWhenClause() []IWhenClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWhenClauseContext)(nil)).Elem())
	var tst = make([]IWhenClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWhenClauseContext)
		}
	}

	return tst
}

func (s *SimpleCaseContext) WhenClause(i int) IWhenClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhenClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWhenClauseContext)
}

func (s *SimpleCaseContext) ELSE() antlr.TerminalNode {
	return s.GetToken(KSqlParserELSE, 0)
}

func (s *SimpleCaseContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SimpleCaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterSimpleCase(s)
	}
}

func (s *SimpleCaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitSimpleCase(s)
	}
}

type ColumnReferenceContext struct {
	*PrimaryExpressionContext
}

func NewColumnReferenceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnReferenceContext {
	var p = new(ColumnReferenceContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ColumnReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnReferenceContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterColumnReference(s)
	}
}

func (s *ColumnReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitColumnReference(s)
	}
}

type SubscriptContext struct {
	*PrimaryExpressionContext
	value IPrimaryExpressionContext
	index IValueExpressionContext
}

func NewSubscriptContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubscriptContext {
	var p = new(SubscriptContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SubscriptContext) GetValue() IPrimaryExpressionContext { return s.value }

func (s *SubscriptContext) GetIndex() IValueExpressionContext { return s.index }

func (s *SubscriptContext) SetValue(v IPrimaryExpressionContext) { s.value = v }

func (s *SubscriptContext) SetIndex(v IValueExpressionContext) { s.index = v }

func (s *SubscriptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubscriptContext) PrimaryExpression() IPrimaryExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *SubscriptContext) ValueExpression() IValueExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *SubscriptContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterSubscript(s)
	}
}

func (s *SubscriptContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitSubscript(s)
	}
}

type StructConstructorContext struct {
	*PrimaryExpressionContext
}

func NewStructConstructorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StructConstructorContext {
	var p = new(StructConstructorContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *StructConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructConstructorContext) STRUCT() antlr.TerminalNode {
	return s.GetToken(KSqlParserSTRUCT, 0)
}

func (s *StructConstructorContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *StructConstructorContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *StructConstructorContext) AllASSIGN() []antlr.TerminalNode {
	return s.GetTokens(KSqlParserASSIGN)
}

func (s *StructConstructorContext) ASSIGN(i int) antlr.TerminalNode {
	return s.GetToken(KSqlParserASSIGN, i)
}

func (s *StructConstructorContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *StructConstructorContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *StructConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterStructConstructor(s)
	}
}

func (s *StructConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitStructConstructor(s)
	}
}

type TypeConstructorContext struct {
	*PrimaryExpressionContext
}

func NewTypeConstructorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TypeConstructorContext {
	var p = new(TypeConstructorContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *TypeConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeConstructorContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TypeConstructorContext) STRING() antlr.TerminalNode {
	return s.GetToken(KSqlParserSTRING, 0)
}

func (s *TypeConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterTypeConstructor(s)
	}
}

func (s *TypeConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitTypeConstructor(s)
	}
}

type QualifiedColumnReferenceContext struct {
	*PrimaryExpressionContext
}

func NewQualifiedColumnReferenceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QualifiedColumnReferenceContext {
	var p = new(QualifiedColumnReferenceContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *QualifiedColumnReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedColumnReferenceContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *QualifiedColumnReferenceContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *QualifiedColumnReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterQualifiedColumnReference(s)
	}
}

func (s *QualifiedColumnReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitQualifiedColumnReference(s)
	}
}

type CastContext struct {
	*PrimaryExpressionContext
}

func NewCastContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CastContext {
	var p = new(CastContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *CastContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastContext) CAST() antlr.TerminalNode {
	return s.GetToken(KSqlParserCAST, 0)
}

func (s *CastContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CastContext) AS() antlr.TerminalNode {
	return s.GetToken(KSqlParserAS, 0)
}

func (s *CastContext) Sqltype() ISqltypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISqltypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISqltypeContext)
}

func (s *CastContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterCast(s)
	}
}

func (s *CastContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitCast(s)
	}
}

type ParenthesizedExpressionContext struct {
	*PrimaryExpressionContext
}

func NewParenthesizedExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParenthesizedExpressionContext {
	var p = new(ParenthesizedExpressionContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ParenthesizedExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedExpressionContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ParenthesizedExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterParenthesizedExpression(s)
	}
}

func (s *ParenthesizedExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitParenthesizedExpression(s)
	}
}

type ArrayConstructorContext struct {
	*PrimaryExpressionContext
}

func NewArrayConstructorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArrayConstructorContext {
	var p = new(ArrayConstructorContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ArrayConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayConstructorContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(KSqlParserARRAY, 0)
}

func (s *ArrayConstructorContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *ArrayConstructorContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ArrayConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterArrayConstructor(s)
	}
}

func (s *ArrayConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitArrayConstructor(s)
	}
}

type MapConstructorContext struct {
	*PrimaryExpressionContext
}

func NewMapConstructorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MapConstructorContext {
	var p = new(MapConstructorContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *MapConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapConstructorContext) MAP() antlr.TerminalNode {
	return s.GetToken(KSqlParserMAP, 0)
}

func (s *MapConstructorContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *MapConstructorContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MapConstructorContext) AllASSIGN() []antlr.TerminalNode {
	return s.GetTokens(KSqlParserASSIGN)
}

func (s *MapConstructorContext) ASSIGN(i int) antlr.TerminalNode {
	return s.GetToken(KSqlParserASSIGN, i)
}

func (s *MapConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterMapConstructor(s)
	}
}

func (s *MapConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitMapConstructor(s)
	}
}

type FunctionCallContext struct {
	*PrimaryExpressionContext
}

func NewFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FunctionCallContext {
	var p = new(FunctionCallContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *FunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FunctionCallContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(KSqlParserASTERISK, 0)
}

func (s *FunctionCallContext) AllFunctionArgument() []IFunctionArgumentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFunctionArgumentContext)(nil)).Elem())
	var tst = make([]IFunctionArgumentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFunctionArgumentContext)
		}
	}

	return tst
}

func (s *FunctionCallContext) FunctionArgument(i int) IFunctionArgumentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctionArgumentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFunctionArgumentContext)
}

func (s *FunctionCallContext) AllLambdaFunction() []ILambdaFunctionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILambdaFunctionContext)(nil)).Elem())
	var tst = make([]ILambdaFunctionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILambdaFunctionContext)
		}
	}

	return tst
}

func (s *FunctionCallContext) LambdaFunction(i int) ILambdaFunctionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILambdaFunctionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILambdaFunctionContext)
}

func (s *FunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterFunctionCall(s)
	}
}

func (s *FunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitFunctionCall(s)
	}
}

type SearchedCaseContext struct {
	*PrimaryExpressionContext
	elseExpression IExpressionContext
}

func NewSearchedCaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SearchedCaseContext {
	var p = new(SearchedCaseContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SearchedCaseContext) GetElseExpression() IExpressionContext { return s.elseExpression }

func (s *SearchedCaseContext) SetElseExpression(v IExpressionContext) { s.elseExpression = v }

func (s *SearchedCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SearchedCaseContext) CASE() antlr.TerminalNode {
	return s.GetToken(KSqlParserCASE, 0)
}

func (s *SearchedCaseContext) END() antlr.TerminalNode {
	return s.GetToken(KSqlParserEND, 0)
}

func (s *SearchedCaseContext) AllWhenClause() []IWhenClauseContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWhenClauseContext)(nil)).Elem())
	var tst = make([]IWhenClauseContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWhenClauseContext)
		}
	}

	return tst
}

func (s *SearchedCaseContext) WhenClause(i int) IWhenClauseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhenClauseContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWhenClauseContext)
}

func (s *SearchedCaseContext) ELSE() antlr.TerminalNode {
	return s.GetToken(KSqlParserELSE, 0)
}

func (s *SearchedCaseContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SearchedCaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterSearchedCase(s)
	}
}

func (s *SearchedCaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitSearchedCase(s)
	}
}

type LiteralExpressionContext struct {
	*PrimaryExpressionContext
}

func NewLiteralExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LiteralExpressionContext {
	var p = new(LiteralExpressionContext)

	p.PrimaryExpressionContext = NewEmptyPrimaryExpressionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *LiteralExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralExpressionContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *LiteralExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterLiteralExpression(s)
	}
}

func (s *LiteralExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitLiteralExpression(s)
	}
}

func (p *KSqlParser) PrimaryExpression() (localctx IPrimaryExpressionContext) {
	return p.primaryExpression(0)
}

func (p *KSqlParser) primaryExpression(_p int) (localctx IPrimaryExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewPrimaryExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IPrimaryExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 88
	p.EnterRecursionRule(localctx, 88, KSqlParserRULE_primaryExpression, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(987)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 128, p.GetParserRuleContext()) {
	case 1:
		localctx = NewLiteralExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(867)
			p.Literal()
		}

	case 2:
		localctx = NewTypeConstructorContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(868)
			p.Identifier()
		}
		{
			p.SetState(869)
			p.Match(KSqlParserSTRING)
		}

	case 3:
		localctx = NewSimpleCaseContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(871)
			p.Match(KSqlParserCASE)
		}
		{
			p.SetState(872)
			p.valueExpression(0)
		}
		p.SetState(874)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == KSqlParserWHEN {
			{
				p.SetState(873)
				p.WhenClause()
			}

			p.SetState(876)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(880)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserELSE {
			{
				p.SetState(878)
				p.Match(KSqlParserELSE)
			}
			{
				p.SetState(879)

				var _x = p.Expression()

				localctx.(*SimpleCaseContext).elseExpression = _x
			}

		}
		{
			p.SetState(882)
			p.Match(KSqlParserEND)
		}

	case 4:
		localctx = NewSearchedCaseContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(884)
			p.Match(KSqlParserCASE)
		}
		p.SetState(886)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == KSqlParserWHEN {
			{
				p.SetState(885)
				p.WhenClause()
			}

			p.SetState(888)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(892)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserELSE {
			{
				p.SetState(890)
				p.Match(KSqlParserELSE)
			}
			{
				p.SetState(891)

				var _x = p.Expression()

				localctx.(*SearchedCaseContext).elseExpression = _x
			}

		}
		{
			p.SetState(894)
			p.Match(KSqlParserEND)
		}

	case 5:
		localctx = NewCastContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(896)
			p.Match(KSqlParserCAST)
		}
		{
			p.SetState(897)
			p.Match(KSqlParserT__2)
		}
		{
			p.SetState(898)
			p.Expression()
		}
		{
			p.SetState(899)
			p.Match(KSqlParserAS)
		}
		{
			p.SetState(900)
			p.sqltype(0)
		}
		{
			p.SetState(901)
			p.Match(KSqlParserT__3)
		}

	case 6:
		localctx = NewArrayConstructorContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(903)
			p.Match(KSqlParserARRAY)
		}
		{
			p.SetState(904)
			p.Match(KSqlParserT__5)
		}
		p.SetState(913)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la-3)&-(0x1f+1)) == 0 && ((1<<uint((_la-3)))&((1<<(KSqlParserT__2-3))|(1<<(KSqlParserT__7-3))|(1<<(KSqlParserEMIT-3))|(1<<(KSqlParserCHANGES-3))|(1<<(KSqlParserFINAL-3))|(1<<(KSqlParserNOT-3))|(1<<(KSqlParserESCAPE-3))|(1<<(KSqlParserNULL-3)))) != 0) || (((_la-35)&-(0x1f+1)) == 0 && ((1<<uint((_la-35)))&((1<<(KSqlParserTRUE-35))|(1<<(KSqlParserFALSE-35))|(1<<(KSqlParserINTEGER-35))|(1<<(KSqlParserDATE-35))|(1<<(KSqlParserTIME-35))|(1<<(KSqlParserTIMESTAMP-35))|(1<<(KSqlParserINTERVAL-35))|(1<<(KSqlParserYEAR-35))|(1<<(KSqlParserMONTH-35))|(1<<(KSqlParserDAY-35))|(1<<(KSqlParserHOUR-35))|(1<<(KSqlParserMINUTE-35))|(1<<(KSqlParserSECOND-35))|(1<<(KSqlParserZONE-35))|(1<<(KSqlParserCASE-35)))) != 0) || (((_la-76)&-(0x1f+1)) == 0 && ((1<<uint((_la-76)))&((1<<(KSqlParserPARTITION-76))|(1<<(KSqlParserSTRUCT-76))|(1<<(KSqlParserEXPLAIN-76))|(1<<(KSqlParserANALYZE-76))|(1<<(KSqlParserTYPE-76))|(1<<(KSqlParserTYPES-76))|(1<<(KSqlParserCAST-76))|(1<<(KSqlParserSHOW-76))|(1<<(KSqlParserTABLES-76))|(1<<(KSqlParserCOLUMNS-76))|(1<<(KSqlParserCOLUMN-76))|(1<<(KSqlParserPARTITIONS-76))|(1<<(KSqlParserFUNCTIONS-76)))) != 0) || (((_la-108)&-(0x1f+1)) == 0 && ((1<<uint((_la-108)))&((1<<(KSqlParserFUNCTION-108))|(1<<(KSqlParserARRAY-108))|(1<<(KSqlParserMAP-108))|(1<<(KSqlParserSET-108))|(1<<(KSqlParserRESET-108))|(1<<(KSqlParserSESSION-108))|(1<<(KSqlParserKEY-108))|(1<<(KSqlParserSINK-108))|(1<<(KSqlParserSOURCE-108))|(1<<(KSqlParserPRIMARY-108))|(1<<(KSqlParserREPLACE-108))|(1<<(KSqlParserASSERT-108))|(1<<(KSqlParserADD-108)))) != 0) || (((_la-140)&-(0x1f+1)) == 0 && ((1<<uint((_la-140)))&((1<<(KSqlParserALTER-140))|(1<<(KSqlParserIF-140))|(1<<(KSqlParserPLUS-140))|(1<<(KSqlParserMINUS-140))|(1<<(KSqlParserSTRING-140))|(1<<(KSqlParserINTEGER_VALUE-140))|(1<<(KSqlParserDECIMAL_VALUE-140))|(1<<(KSqlParserFLOATING_POINT_VALUE-140))|(1<<(KSqlParserIDENTIFIER-140))|(1<<(KSqlParserDIGIT_IDENTIFIER-140))|(1<<(KSqlParserQUOTED_IDENTIFIER-140))|(1<<(KSqlParserBACKQUOTED_IDENTIFIER-140))|(1<<(KSqlParserVARIABLE-140)))) != 0) {
			{
				p.SetState(905)
				p.Expression()
			}
			p.SetState(910)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KSqlParserT__1 {
				{
					p.SetState(906)
					p.Match(KSqlParserT__1)
				}
				{
					p.SetState(907)
					p.Expression()
				}

				p.SetState(912)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(915)
			p.Match(KSqlParserT__6)
		}

	case 7:
		localctx = NewMapConstructorContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(916)
			p.Match(KSqlParserMAP)
		}
		{
			p.SetState(917)
			p.Match(KSqlParserT__2)
		}
		p.SetState(931)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la-3)&-(0x1f+1)) == 0 && ((1<<uint((_la-3)))&((1<<(KSqlParserT__2-3))|(1<<(KSqlParserT__7-3))|(1<<(KSqlParserEMIT-3))|(1<<(KSqlParserCHANGES-3))|(1<<(KSqlParserFINAL-3))|(1<<(KSqlParserNOT-3))|(1<<(KSqlParserESCAPE-3))|(1<<(KSqlParserNULL-3)))) != 0) || (((_la-35)&-(0x1f+1)) == 0 && ((1<<uint((_la-35)))&((1<<(KSqlParserTRUE-35))|(1<<(KSqlParserFALSE-35))|(1<<(KSqlParserINTEGER-35))|(1<<(KSqlParserDATE-35))|(1<<(KSqlParserTIME-35))|(1<<(KSqlParserTIMESTAMP-35))|(1<<(KSqlParserINTERVAL-35))|(1<<(KSqlParserYEAR-35))|(1<<(KSqlParserMONTH-35))|(1<<(KSqlParserDAY-35))|(1<<(KSqlParserHOUR-35))|(1<<(KSqlParserMINUTE-35))|(1<<(KSqlParserSECOND-35))|(1<<(KSqlParserZONE-35))|(1<<(KSqlParserCASE-35)))) != 0) || (((_la-76)&-(0x1f+1)) == 0 && ((1<<uint((_la-76)))&((1<<(KSqlParserPARTITION-76))|(1<<(KSqlParserSTRUCT-76))|(1<<(KSqlParserEXPLAIN-76))|(1<<(KSqlParserANALYZE-76))|(1<<(KSqlParserTYPE-76))|(1<<(KSqlParserTYPES-76))|(1<<(KSqlParserCAST-76))|(1<<(KSqlParserSHOW-76))|(1<<(KSqlParserTABLES-76))|(1<<(KSqlParserCOLUMNS-76))|(1<<(KSqlParserCOLUMN-76))|(1<<(KSqlParserPARTITIONS-76))|(1<<(KSqlParserFUNCTIONS-76)))) != 0) || (((_la-108)&-(0x1f+1)) == 0 && ((1<<uint((_la-108)))&((1<<(KSqlParserFUNCTION-108))|(1<<(KSqlParserARRAY-108))|(1<<(KSqlParserMAP-108))|(1<<(KSqlParserSET-108))|(1<<(KSqlParserRESET-108))|(1<<(KSqlParserSESSION-108))|(1<<(KSqlParserKEY-108))|(1<<(KSqlParserSINK-108))|(1<<(KSqlParserSOURCE-108))|(1<<(KSqlParserPRIMARY-108))|(1<<(KSqlParserREPLACE-108))|(1<<(KSqlParserASSERT-108))|(1<<(KSqlParserADD-108)))) != 0) || (((_la-140)&-(0x1f+1)) == 0 && ((1<<uint((_la-140)))&((1<<(KSqlParserALTER-140))|(1<<(KSqlParserIF-140))|(1<<(KSqlParserPLUS-140))|(1<<(KSqlParserMINUS-140))|(1<<(KSqlParserSTRING-140))|(1<<(KSqlParserINTEGER_VALUE-140))|(1<<(KSqlParserDECIMAL_VALUE-140))|(1<<(KSqlParserFLOATING_POINT_VALUE-140))|(1<<(KSqlParserIDENTIFIER-140))|(1<<(KSqlParserDIGIT_IDENTIFIER-140))|(1<<(KSqlParserQUOTED_IDENTIFIER-140))|(1<<(KSqlParserBACKQUOTED_IDENTIFIER-140))|(1<<(KSqlParserVARIABLE-140)))) != 0) {
			{
				p.SetState(918)
				p.Expression()
			}
			{
				p.SetState(919)
				p.Match(KSqlParserASSIGN)
			}
			{
				p.SetState(920)
				p.Expression()
			}
			p.SetState(928)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KSqlParserT__1 {
				{
					p.SetState(921)
					p.Match(KSqlParserT__1)
				}
				{
					p.SetState(922)
					p.Expression()
				}
				{
					p.SetState(923)
					p.Match(KSqlParserASSIGN)
				}
				{
					p.SetState(924)
					p.Expression()
				}

				p.SetState(930)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(933)
			p.Match(KSqlParserT__3)
		}

	case 8:
		localctx = NewStructConstructorContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(934)
			p.Match(KSqlParserSTRUCT)
		}
		{
			p.SetState(935)
			p.Match(KSqlParserT__2)
		}
		p.SetState(949)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<KSqlParserT__7)|(1<<KSqlParserEMIT)|(1<<KSqlParserCHANGES)|(1<<KSqlParserFINAL))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(KSqlParserESCAPE-32))|(1<<(KSqlParserINTEGER-32))|(1<<(KSqlParserDATE-32))|(1<<(KSqlParserTIME-32))|(1<<(KSqlParserTIMESTAMP-32))|(1<<(KSqlParserINTERVAL-32))|(1<<(KSqlParserYEAR-32))|(1<<(KSqlParserMONTH-32))|(1<<(KSqlParserDAY-32))|(1<<(KSqlParserHOUR-32))|(1<<(KSqlParserMINUTE-32))|(1<<(KSqlParserSECOND-32))|(1<<(KSqlParserZONE-32)))) != 0) || (((_la-76)&-(0x1f+1)) == 0 && ((1<<uint((_la-76)))&((1<<(KSqlParserPARTITION-76))|(1<<(KSqlParserSTRUCT-76))|(1<<(KSqlParserEXPLAIN-76))|(1<<(KSqlParserANALYZE-76))|(1<<(KSqlParserTYPE-76))|(1<<(KSqlParserTYPES-76))|(1<<(KSqlParserSHOW-76))|(1<<(KSqlParserTABLES-76))|(1<<(KSqlParserCOLUMNS-76))|(1<<(KSqlParserCOLUMN-76))|(1<<(KSqlParserPARTITIONS-76))|(1<<(KSqlParserFUNCTIONS-76)))) != 0) || (((_la-108)&-(0x1f+1)) == 0 && ((1<<uint((_la-108)))&((1<<(KSqlParserFUNCTION-108))|(1<<(KSqlParserARRAY-108))|(1<<(KSqlParserMAP-108))|(1<<(KSqlParserSET-108))|(1<<(KSqlParserRESET-108))|(1<<(KSqlParserSESSION-108))|(1<<(KSqlParserKEY-108))|(1<<(KSqlParserSINK-108))|(1<<(KSqlParserSOURCE-108))|(1<<(KSqlParserPRIMARY-108))|(1<<(KSqlParserREPLACE-108))|(1<<(KSqlParserASSERT-108))|(1<<(KSqlParserADD-108)))) != 0) || (((_la-140)&-(0x1f+1)) == 0 && ((1<<uint((_la-140)))&((1<<(KSqlParserALTER-140))|(1<<(KSqlParserIF-140))|(1<<(KSqlParserIDENTIFIER-140))|(1<<(KSqlParserDIGIT_IDENTIFIER-140))|(1<<(KSqlParserQUOTED_IDENTIFIER-140))|(1<<(KSqlParserBACKQUOTED_IDENTIFIER-140))|(1<<(KSqlParserVARIABLE-140)))) != 0) {
			{
				p.SetState(936)
				p.Identifier()
			}
			{
				p.SetState(937)
				p.Match(KSqlParserASSIGN)
			}
			{
				p.SetState(938)
				p.Expression()
			}
			p.SetState(946)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KSqlParserT__1 {
				{
					p.SetState(939)
					p.Match(KSqlParserT__1)
				}
				{
					p.SetState(940)
					p.Identifier()
				}
				{
					p.SetState(941)
					p.Match(KSqlParserASSIGN)
				}
				{
					p.SetState(942)
					p.Expression()
				}

				p.SetState(948)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(951)
			p.Match(KSqlParserT__3)
		}

	case 9:
		localctx = NewFunctionCallContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(952)
			p.Identifier()
		}
		{
			p.SetState(953)
			p.Match(KSqlParserT__2)
		}
		{
			p.SetState(954)
			p.Match(KSqlParserASTERISK)
		}
		{
			p.SetState(955)
			p.Match(KSqlParserT__3)
		}

	case 10:
		localctx = NewFunctionCallContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(957)
			p.Identifier()
		}
		{
			p.SetState(958)
			p.Match(KSqlParserT__2)
		}
		p.SetState(974)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la-3)&-(0x1f+1)) == 0 && ((1<<uint((_la-3)))&((1<<(KSqlParserT__2-3))|(1<<(KSqlParserT__7-3))|(1<<(KSqlParserEMIT-3))|(1<<(KSqlParserCHANGES-3))|(1<<(KSqlParserFINAL-3))|(1<<(KSqlParserNOT-3))|(1<<(KSqlParserESCAPE-3))|(1<<(KSqlParserNULL-3)))) != 0) || (((_la-35)&-(0x1f+1)) == 0 && ((1<<uint((_la-35)))&((1<<(KSqlParserTRUE-35))|(1<<(KSqlParserFALSE-35))|(1<<(KSqlParserINTEGER-35))|(1<<(KSqlParserDATE-35))|(1<<(KSqlParserTIME-35))|(1<<(KSqlParserTIMESTAMP-35))|(1<<(KSqlParserINTERVAL-35))|(1<<(KSqlParserYEAR-35))|(1<<(KSqlParserMONTH-35))|(1<<(KSqlParserDAY-35))|(1<<(KSqlParserHOUR-35))|(1<<(KSqlParserMINUTE-35))|(1<<(KSqlParserSECOND-35))|(1<<(KSqlParserMILLISECOND-35))|(1<<(KSqlParserDAYS-35))|(1<<(KSqlParserHOURS-35))|(1<<(KSqlParserMINUTES-35))|(1<<(KSqlParserSECONDS-35))|(1<<(KSqlParserMILLISECONDS-35))|(1<<(KSqlParserZONE-35))|(1<<(KSqlParserCASE-35)))) != 0) || (((_la-76)&-(0x1f+1)) == 0 && ((1<<uint((_la-76)))&((1<<(KSqlParserPARTITION-76))|(1<<(KSqlParserSTRUCT-76))|(1<<(KSqlParserEXPLAIN-76))|(1<<(KSqlParserANALYZE-76))|(1<<(KSqlParserTYPE-76))|(1<<(KSqlParserTYPES-76))|(1<<(KSqlParserCAST-76))|(1<<(KSqlParserSHOW-76))|(1<<(KSqlParserTABLES-76))|(1<<(KSqlParserCOLUMNS-76))|(1<<(KSqlParserCOLUMN-76))|(1<<(KSqlParserPARTITIONS-76))|(1<<(KSqlParserFUNCTIONS-76)))) != 0) || (((_la-108)&-(0x1f+1)) == 0 && ((1<<uint((_la-108)))&((1<<(KSqlParserFUNCTION-108))|(1<<(KSqlParserARRAY-108))|(1<<(KSqlParserMAP-108))|(1<<(KSqlParserSET-108))|(1<<(KSqlParserRESET-108))|(1<<(KSqlParserSESSION-108))|(1<<(KSqlParserKEY-108))|(1<<(KSqlParserSINK-108))|(1<<(KSqlParserSOURCE-108))|(1<<(KSqlParserPRIMARY-108))|(1<<(KSqlParserREPLACE-108))|(1<<(KSqlParserASSERT-108))|(1<<(KSqlParserADD-108)))) != 0) || (((_la-140)&-(0x1f+1)) == 0 && ((1<<uint((_la-140)))&((1<<(KSqlParserALTER-140))|(1<<(KSqlParserIF-140))|(1<<(KSqlParserPLUS-140))|(1<<(KSqlParserMINUS-140))|(1<<(KSqlParserSTRING-140))|(1<<(KSqlParserINTEGER_VALUE-140))|(1<<(KSqlParserDECIMAL_VALUE-140))|(1<<(KSqlParserFLOATING_POINT_VALUE-140))|(1<<(KSqlParserIDENTIFIER-140))|(1<<(KSqlParserDIGIT_IDENTIFIER-140))|(1<<(KSqlParserQUOTED_IDENTIFIER-140))|(1<<(KSqlParserBACKQUOTED_IDENTIFIER-140))|(1<<(KSqlParserVARIABLE-140)))) != 0) {
			{
				p.SetState(959)
				p.FunctionArgument()
			}
			p.SetState(964)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 125, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(960)
						p.Match(KSqlParserT__1)
					}
					{
						p.SetState(961)
						p.FunctionArgument()
					}

				}
				p.SetState(966)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 125, p.GetParserRuleContext())
			}
			p.SetState(971)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KSqlParserT__1 {
				{
					p.SetState(967)
					p.Match(KSqlParserT__1)
				}
				{
					p.SetState(968)
					p.LambdaFunction()
				}

				p.SetState(973)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(976)
			p.Match(KSqlParserT__3)
		}

	case 11:
		localctx = NewColumnReferenceContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(978)
			p.Identifier()
		}

	case 12:
		localctx = NewQualifiedColumnReferenceContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(979)
			p.Identifier()
		}
		{
			p.SetState(980)
			p.Match(KSqlParserT__4)
		}
		{
			p.SetState(981)
			p.Identifier()
		}

	case 13:
		localctx = NewParenthesizedExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(983)
			p.Match(KSqlParserT__2)
		}
		{
			p.SetState(984)
			p.Expression()
		}
		{
			p.SetState(985)
			p.Match(KSqlParserT__3)
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(999)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 130, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(997)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 129, p.GetParserRuleContext()) {
			case 1:
				localctx = NewSubscriptContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				localctx.(*SubscriptContext).value = _prevctx

				p.PushNewRecursionContext(localctx, _startState, KSqlParserRULE_primaryExpression)
				p.SetState(989)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
				}
				{
					p.SetState(990)
					p.Match(KSqlParserT__5)
				}
				{
					p.SetState(991)

					var _x = p.valueExpression(0)

					localctx.(*SubscriptContext).index = _x
				}
				{
					p.SetState(992)
					p.Match(KSqlParserT__6)
				}

			case 2:
				localctx = NewDereferenceContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				localctx.(*DereferenceContext).base = _prevctx

				p.PushNewRecursionContext(localctx, _startState, KSqlParserRULE_primaryExpression)
				p.SetState(994)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(995)
					p.Match(KSqlParserSTRUCT_FIELD_REF)
				}
				{
					p.SetState(996)

					var _x = p.Identifier()

					localctx.(*DereferenceContext).fieldName = _x
				}

			}

		}
		p.SetState(1001)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 130, p.GetParserRuleContext())
	}

	return localctx
}

// IFunctionArgumentContext is an interface to support dynamic dispatch.
type IFunctionArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionArgumentContext differentiates from other interfaces.
	IsFunctionArgumentContext()
}

type FunctionArgumentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionArgumentContext() *FunctionArgumentContext {
	var p = new(FunctionArgumentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_functionArgument
	return p
}

func (*FunctionArgumentContext) IsFunctionArgumentContext() {}

func NewFunctionArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionArgumentContext {
	var p = new(FunctionArgumentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_functionArgument

	return p
}

func (s *FunctionArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionArgumentContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FunctionArgumentContext) WindowUnit() IWindowUnitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWindowUnitContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWindowUnitContext)
}

func (s *FunctionArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterFunctionArgument(s)
	}
}

func (s *FunctionArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitFunctionArgument(s)
	}
}

func (p *KSqlParser) FunctionArgument() (localctx IFunctionArgumentContext) {
	localctx = NewFunctionArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, KSqlParserRULE_functionArgument)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1004)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 131, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1002)
			p.Expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1003)
			p.WindowUnit()
		}

	}

	return localctx
}

// ITimeZoneSpecifierContext is an interface to support dynamic dispatch.
type ITimeZoneSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTimeZoneSpecifierContext differentiates from other interfaces.
	IsTimeZoneSpecifierContext()
}

type TimeZoneSpecifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTimeZoneSpecifierContext() *TimeZoneSpecifierContext {
	var p = new(TimeZoneSpecifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_timeZoneSpecifier
	return p
}

func (*TimeZoneSpecifierContext) IsTimeZoneSpecifierContext() {}

func NewTimeZoneSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TimeZoneSpecifierContext {
	var p = new(TimeZoneSpecifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_timeZoneSpecifier

	return p
}

func (s *TimeZoneSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *TimeZoneSpecifierContext) CopyFrom(ctx *TimeZoneSpecifierContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *TimeZoneSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimeZoneSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type TimeZoneStringContext struct {
	*TimeZoneSpecifierContext
}

func NewTimeZoneStringContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TimeZoneStringContext {
	var p = new(TimeZoneStringContext)

	p.TimeZoneSpecifierContext = NewEmptyTimeZoneSpecifierContext()
	p.parser = parser
	p.CopyFrom(ctx.(*TimeZoneSpecifierContext))

	return p
}

func (s *TimeZoneStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimeZoneStringContext) TIME() antlr.TerminalNode {
	return s.GetToken(KSqlParserTIME, 0)
}

func (s *TimeZoneStringContext) ZONE() antlr.TerminalNode {
	return s.GetToken(KSqlParserZONE, 0)
}

func (s *TimeZoneStringContext) STRING() antlr.TerminalNode {
	return s.GetToken(KSqlParserSTRING, 0)
}

func (s *TimeZoneStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterTimeZoneString(s)
	}
}

func (s *TimeZoneStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitTimeZoneString(s)
	}
}

func (p *KSqlParser) TimeZoneSpecifier() (localctx ITimeZoneSpecifierContext) {
	localctx = NewTimeZoneSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, KSqlParserRULE_timeZoneSpecifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	localctx = NewTimeZoneStringContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1006)
		p.Match(KSqlParserTIME)
	}
	{
		p.SetState(1007)
		p.Match(KSqlParserZONE)
	}
	{
		p.SetState(1008)
		p.Match(KSqlParserSTRING)
	}

	return localctx
}

// IComparisonOperatorContext is an interface to support dynamic dispatch.
type IComparisonOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComparisonOperatorContext differentiates from other interfaces.
	IsComparisonOperatorContext()
}

type ComparisonOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonOperatorContext() *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_comparisonOperator
	return p
}

func (*ComparisonOperatorContext) IsComparisonOperatorContext() {}

func NewComparisonOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_comparisonOperator

	return p
}

func (s *ComparisonOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonOperatorContext) EQ() antlr.TerminalNode {
	return s.GetToken(KSqlParserEQ, 0)
}

func (s *ComparisonOperatorContext) NEQ() antlr.TerminalNode {
	return s.GetToken(KSqlParserNEQ, 0)
}

func (s *ComparisonOperatorContext) LT() antlr.TerminalNode {
	return s.GetToken(KSqlParserLT, 0)
}

func (s *ComparisonOperatorContext) LTE() antlr.TerminalNode {
	return s.GetToken(KSqlParserLTE, 0)
}

func (s *ComparisonOperatorContext) GT() antlr.TerminalNode {
	return s.GetToken(KSqlParserGT, 0)
}

func (s *ComparisonOperatorContext) GTE() antlr.TerminalNode {
	return s.GetToken(KSqlParserGTE, 0)
}

func (s *ComparisonOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterComparisonOperator(s)
	}
}

func (s *ComparisonOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitComparisonOperator(s)
	}
}

func (p *KSqlParser) ComparisonOperator() (localctx IComparisonOperatorContext) {
	localctx = NewComparisonOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, KSqlParserRULE_comparisonOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1010)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-146)&-(0x1f+1)) == 0 && ((1<<uint((_la-146)))&((1<<(KSqlParserEQ-146))|(1<<(KSqlParserNEQ-146))|(1<<(KSqlParserLT-146))|(1<<(KSqlParserLTE-146))|(1<<(KSqlParserGT-146))|(1<<(KSqlParserGTE-146)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IBooleanValueContext is an interface to support dynamic dispatch.
type IBooleanValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBooleanValueContext differentiates from other interfaces.
	IsBooleanValueContext()
}

type BooleanValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanValueContext() *BooleanValueContext {
	var p = new(BooleanValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_booleanValue
	return p
}

func (*BooleanValueContext) IsBooleanValueContext() {}

func NewBooleanValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanValueContext {
	var p = new(BooleanValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_booleanValue

	return p
}

func (s *BooleanValueContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanValueContext) TRUE() antlr.TerminalNode {
	return s.GetToken(KSqlParserTRUE, 0)
}

func (s *BooleanValueContext) FALSE() antlr.TerminalNode {
	return s.GetToken(KSqlParserFALSE, 0)
}

func (s *BooleanValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BooleanValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterBooleanValue(s)
	}
}

func (s *BooleanValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitBooleanValue(s)
	}
}

func (p *KSqlParser) BooleanValue() (localctx IBooleanValueContext) {
	localctx = NewBooleanValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, KSqlParserRULE_booleanValue)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1012)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KSqlParserTRUE || _la == KSqlParserFALSE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ISqltypeContext is an interface to support dynamic dispatch.
type ISqltypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSqltypeContext differentiates from other interfaces.
	IsSqltypeContext()
}

type SqltypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySqltypeContext() *SqltypeContext {
	var p = new(SqltypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_sqltype
	return p
}

func (*SqltypeContext) IsSqltypeContext() {}

func NewSqltypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SqltypeContext {
	var p = new(SqltypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_sqltype

	return p
}

func (s *SqltypeContext) GetParser() antlr.Parser { return s.parser }

func (s *SqltypeContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(KSqlParserARRAY, 0)
}

func (s *SqltypeContext) AllSqltype() []ISqltypeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISqltypeContext)(nil)).Elem())
	var tst = make([]ISqltypeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISqltypeContext)
		}
	}

	return tst
}

func (s *SqltypeContext) Sqltype(i int) ISqltypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISqltypeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISqltypeContext)
}

func (s *SqltypeContext) MAP() antlr.TerminalNode {
	return s.GetToken(KSqlParserMAP, 0)
}

func (s *SqltypeContext) STRUCT() antlr.TerminalNode {
	return s.GetToken(KSqlParserSTRUCT, 0)
}

func (s *SqltypeContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *SqltypeContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SqltypeContext) DECIMAL() antlr.TerminalNode {
	return s.GetToken(KSqlParserDECIMAL, 0)
}

func (s *SqltypeContext) AllNumber() []INumberContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INumberContext)(nil)).Elem())
	var tst = make([]INumberContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INumberContext)
		}
	}

	return tst
}

func (s *SqltypeContext) Number(i int) INumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *SqltypeContext) BaseType() IBaseTypeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBaseTypeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBaseTypeContext)
}

func (s *SqltypeContext) AllTypeParameter() []ITypeParameterContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITypeParameterContext)(nil)).Elem())
	var tst = make([]ITypeParameterContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITypeParameterContext)
		}
	}

	return tst
}

func (s *SqltypeContext) TypeParameter(i int) ITypeParameterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITypeParameterContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITypeParameterContext)
}

func (s *SqltypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SqltypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SqltypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterSqltype(s)
	}
}

func (s *SqltypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitSqltype(s)
	}
}

func (p *KSqlParser) Sqltype() (localctx ISqltypeContext) {
	return p.sqltype(0)
}

func (p *KSqlParser) sqltype(_p int) (localctx ISqltypeContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewSqltypeContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ISqltypeContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 98
	p.EnterRecursionRule(localctx, 98, KSqlParserRULE_sqltype, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1064)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 136, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1015)
			p.Match(KSqlParserARRAY)
		}
		{
			p.SetState(1016)
			p.Match(KSqlParserLT)
		}
		{
			p.SetState(1017)
			p.sqltype(0)
		}
		{
			p.SetState(1018)
			p.Match(KSqlParserGT)
		}

	case 2:
		{
			p.SetState(1020)
			p.Match(KSqlParserMAP)
		}
		{
			p.SetState(1021)
			p.Match(KSqlParserLT)
		}
		{
			p.SetState(1022)
			p.sqltype(0)
		}
		{
			p.SetState(1023)
			p.Match(KSqlParserT__1)
		}
		{
			p.SetState(1024)
			p.sqltype(0)
		}
		{
			p.SetState(1025)
			p.Match(KSqlParserGT)
		}

	case 3:
		{
			p.SetState(1027)
			p.Match(KSqlParserSTRUCT)
		}
		{
			p.SetState(1028)
			p.Match(KSqlParserLT)
		}
		p.SetState(1040)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<KSqlParserT__7)|(1<<KSqlParserEMIT)|(1<<KSqlParserCHANGES)|(1<<KSqlParserFINAL))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(KSqlParserESCAPE-32))|(1<<(KSqlParserINTEGER-32))|(1<<(KSqlParserDATE-32))|(1<<(KSqlParserTIME-32))|(1<<(KSqlParserTIMESTAMP-32))|(1<<(KSqlParserINTERVAL-32))|(1<<(KSqlParserYEAR-32))|(1<<(KSqlParserMONTH-32))|(1<<(KSqlParserDAY-32))|(1<<(KSqlParserHOUR-32))|(1<<(KSqlParserMINUTE-32))|(1<<(KSqlParserSECOND-32))|(1<<(KSqlParserZONE-32)))) != 0) || (((_la-76)&-(0x1f+1)) == 0 && ((1<<uint((_la-76)))&((1<<(KSqlParserPARTITION-76))|(1<<(KSqlParserSTRUCT-76))|(1<<(KSqlParserEXPLAIN-76))|(1<<(KSqlParserANALYZE-76))|(1<<(KSqlParserTYPE-76))|(1<<(KSqlParserTYPES-76))|(1<<(KSqlParserSHOW-76))|(1<<(KSqlParserTABLES-76))|(1<<(KSqlParserCOLUMNS-76))|(1<<(KSqlParserCOLUMN-76))|(1<<(KSqlParserPARTITIONS-76))|(1<<(KSqlParserFUNCTIONS-76)))) != 0) || (((_la-108)&-(0x1f+1)) == 0 && ((1<<uint((_la-108)))&((1<<(KSqlParserFUNCTION-108))|(1<<(KSqlParserARRAY-108))|(1<<(KSqlParserMAP-108))|(1<<(KSqlParserSET-108))|(1<<(KSqlParserRESET-108))|(1<<(KSqlParserSESSION-108))|(1<<(KSqlParserKEY-108))|(1<<(KSqlParserSINK-108))|(1<<(KSqlParserSOURCE-108))|(1<<(KSqlParserPRIMARY-108))|(1<<(KSqlParserREPLACE-108))|(1<<(KSqlParserASSERT-108))|(1<<(KSqlParserADD-108)))) != 0) || (((_la-140)&-(0x1f+1)) == 0 && ((1<<uint((_la-140)))&((1<<(KSqlParserALTER-140))|(1<<(KSqlParserIF-140))|(1<<(KSqlParserIDENTIFIER-140))|(1<<(KSqlParserDIGIT_IDENTIFIER-140))|(1<<(KSqlParserQUOTED_IDENTIFIER-140))|(1<<(KSqlParserBACKQUOTED_IDENTIFIER-140))|(1<<(KSqlParserVARIABLE-140)))) != 0) {
			{
				p.SetState(1029)
				p.Identifier()
			}
			{
				p.SetState(1030)
				p.sqltype(0)
			}
			p.SetState(1037)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KSqlParserT__1 {
				{
					p.SetState(1031)
					p.Match(KSqlParserT__1)
				}
				{
					p.SetState(1032)
					p.Identifier()
				}
				{
					p.SetState(1033)
					p.sqltype(0)
				}

				p.SetState(1039)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(1042)
			p.Match(KSqlParserGT)
		}

	case 4:
		{
			p.SetState(1043)
			p.Match(KSqlParserDECIMAL)
		}
		{
			p.SetState(1044)
			p.Match(KSqlParserT__2)
		}
		{
			p.SetState(1045)
			p.Number()
		}
		{
			p.SetState(1046)
			p.Match(KSqlParserT__1)
		}
		{
			p.SetState(1047)
			p.Number()
		}
		{
			p.SetState(1048)
			p.Match(KSqlParserT__3)
		}

	case 5:
		{
			p.SetState(1050)
			p.BaseType()
		}
		p.SetState(1062)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 135, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1051)
				p.Match(KSqlParserT__2)
			}
			{
				p.SetState(1052)
				p.TypeParameter()
			}
			p.SetState(1057)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == KSqlParserT__1 {
				{
					p.SetState(1053)
					p.Match(KSqlParserT__1)
				}
				{
					p.SetState(1054)
					p.TypeParameter()
				}

				p.SetState(1059)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1060)
				p.Match(KSqlParserT__3)
			}

		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1070)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 137, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewSqltypeContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, KSqlParserRULE_sqltype)
			p.SetState(1066)

			if !(p.Precpred(p.GetParserRuleContext(), 6)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
			}
			{
				p.SetState(1067)
				p.Match(KSqlParserARRAY)
			}

		}
		p.SetState(1072)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 137, p.GetParserRuleContext())
	}

	return localctx
}

// ITypeParameterContext is an interface to support dynamic dispatch.
type ITypeParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeParameterContext differentiates from other interfaces.
	IsTypeParameterContext()
}

type TypeParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParameterContext() *TypeParameterContext {
	var p = new(TypeParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_typeParameter
	return p
}

func (*TypeParameterContext) IsTypeParameterContext() {}

func NewTypeParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParameterContext {
	var p = new(TypeParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_typeParameter

	return p
}

func (s *TypeParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParameterContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(KSqlParserINTEGER_VALUE, 0)
}

func (s *TypeParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterTypeParameter(s)
	}
}

func (s *TypeParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitTypeParameter(s)
	}
}

func (p *KSqlParser) TypeParameter() (localctx ITypeParameterContext) {
	localctx = NewTypeParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, KSqlParserRULE_typeParameter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1073)
		_la = p.GetTokenStream().LA(1)

		if !(_la == KSqlParserT__7 || _la == KSqlParserINTEGER_VALUE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IBaseTypeContext is an interface to support dynamic dispatch.
type IBaseTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBaseTypeContext differentiates from other interfaces.
	IsBaseTypeContext()
}

type BaseTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBaseTypeContext() *BaseTypeContext {
	var p = new(BaseTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_baseType
	return p
}

func (*BaseTypeContext) IsBaseTypeContext() {}

func NewBaseTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BaseTypeContext {
	var p = new(BaseTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_baseType

	return p
}

func (s *BaseTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *BaseTypeContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *BaseTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BaseTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BaseTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterBaseType(s)
	}
}

func (s *BaseTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitBaseType(s)
	}
}

func (p *KSqlParser) BaseType() (localctx IBaseTypeContext) {
	localctx = NewBaseTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, KSqlParserRULE_baseType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1075)
		p.Identifier()
	}

	return localctx
}

// IWhenClauseContext is an interface to support dynamic dispatch.
type IWhenClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCondition returns the condition rule contexts.
	GetCondition() IExpressionContext

	// GetResult returns the result rule contexts.
	GetResult() IExpressionContext

	// SetCondition sets the condition rule contexts.
	SetCondition(IExpressionContext)

	// SetResult sets the result rule contexts.
	SetResult(IExpressionContext)

	// IsWhenClauseContext differentiates from other interfaces.
	IsWhenClauseContext()
}

type WhenClauseContext struct {
	*antlr.BaseParserRuleContext
	parser    antlr.Parser
	condition IExpressionContext
	result    IExpressionContext
}

func NewEmptyWhenClauseContext() *WhenClauseContext {
	var p = new(WhenClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_whenClause
	return p
}

func (*WhenClauseContext) IsWhenClauseContext() {}

func NewWhenClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenClauseContext {
	var p = new(WhenClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_whenClause

	return p
}

func (s *WhenClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenClauseContext) GetCondition() IExpressionContext { return s.condition }

func (s *WhenClauseContext) GetResult() IExpressionContext { return s.result }

func (s *WhenClauseContext) SetCondition(v IExpressionContext) { s.condition = v }

func (s *WhenClauseContext) SetResult(v IExpressionContext) { s.result = v }

func (s *WhenClauseContext) WHEN() antlr.TerminalNode {
	return s.GetToken(KSqlParserWHEN, 0)
}

func (s *WhenClauseContext) THEN() antlr.TerminalNode {
	return s.GetToken(KSqlParserTHEN, 0)
}

func (s *WhenClauseContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *WhenClauseContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhenClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhenClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterWhenClause(s)
	}
}

func (s *WhenClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitWhenClause(s)
	}
}

func (p *KSqlParser) WhenClause() (localctx IWhenClauseContext) {
	localctx = NewWhenClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, KSqlParserRULE_whenClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1077)
		p.Match(KSqlParserWHEN)
	}
	{
		p.SetState(1078)

		var _x = p.Expression()

		localctx.(*WhenClauseContext).condition = _x
	}
	{
		p.SetState(1079)
		p.Match(KSqlParserTHEN)
	}
	{
		p.SetState(1080)

		var _x = p.Expression()

		localctx.(*WhenClauseContext).result = _x
	}

	return localctx
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_identifier
	return p
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) CopyFrom(ctx *IdentifierContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type VariableIdentifierContext struct {
	*IdentifierContext
}

func NewVariableIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *VariableIdentifierContext {
	var p = new(VariableIdentifierContext)

	p.IdentifierContext = NewEmptyIdentifierContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IdentifierContext))

	return p
}

func (s *VariableIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableIdentifierContext) VARIABLE() antlr.TerminalNode {
	return s.GetToken(KSqlParserVARIABLE, 0)
}

func (s *VariableIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterVariableIdentifier(s)
	}
}

func (s *VariableIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitVariableIdentifier(s)
	}
}

type BackQuotedIdentifierContext struct {
	*IdentifierContext
}

func NewBackQuotedIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BackQuotedIdentifierContext {
	var p = new(BackQuotedIdentifierContext)

	p.IdentifierContext = NewEmptyIdentifierContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IdentifierContext))

	return p
}

func (s *BackQuotedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BackQuotedIdentifierContext) BACKQUOTED_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(KSqlParserBACKQUOTED_IDENTIFIER, 0)
}

func (s *BackQuotedIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterBackQuotedIdentifier(s)
	}
}

func (s *BackQuotedIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitBackQuotedIdentifier(s)
	}
}

type QuotedIdentifierAlternativeContext struct {
	*IdentifierContext
}

func NewQuotedIdentifierAlternativeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QuotedIdentifierAlternativeContext {
	var p = new(QuotedIdentifierAlternativeContext)

	p.IdentifierContext = NewEmptyIdentifierContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IdentifierContext))

	return p
}

func (s *QuotedIdentifierAlternativeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuotedIdentifierAlternativeContext) QUOTED_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(KSqlParserQUOTED_IDENTIFIER, 0)
}

func (s *QuotedIdentifierAlternativeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterQuotedIdentifierAlternative(s)
	}
}

func (s *QuotedIdentifierAlternativeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitQuotedIdentifierAlternative(s)
	}
}

type DigitIdentifierContext struct {
	*IdentifierContext
}

func NewDigitIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DigitIdentifierContext {
	var p = new(DigitIdentifierContext)

	p.IdentifierContext = NewEmptyIdentifierContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IdentifierContext))

	return p
}

func (s *DigitIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DigitIdentifierContext) DIGIT_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(KSqlParserDIGIT_IDENTIFIER, 0)
}

func (s *DigitIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterDigitIdentifier(s)
	}
}

func (s *DigitIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitDigitIdentifier(s)
	}
}

type UnquotedIdentifierContext struct {
	*IdentifierContext
}

func NewUnquotedIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnquotedIdentifierContext {
	var p = new(UnquotedIdentifierContext)

	p.IdentifierContext = NewEmptyIdentifierContext()
	p.parser = parser
	p.CopyFrom(ctx.(*IdentifierContext))

	return p
}

func (s *UnquotedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnquotedIdentifierContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(KSqlParserIDENTIFIER, 0)
}

func (s *UnquotedIdentifierContext) NonReserved() INonReservedContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INonReservedContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INonReservedContext)
}

func (s *UnquotedIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterUnquotedIdentifier(s)
	}
}

func (s *UnquotedIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitUnquotedIdentifier(s)
	}
}

func (p *KSqlParser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, KSqlParserRULE_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1088)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KSqlParserVARIABLE:
		localctx = NewVariableIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1082)
			p.Match(KSqlParserVARIABLE)
		}

	case KSqlParserIDENTIFIER:
		localctx = NewUnquotedIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1083)
			p.Match(KSqlParserIDENTIFIER)
		}

	case KSqlParserQUOTED_IDENTIFIER:
		localctx = NewQuotedIdentifierAlternativeContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1084)
			p.Match(KSqlParserQUOTED_IDENTIFIER)
		}

	case KSqlParserT__7, KSqlParserEMIT, KSqlParserCHANGES, KSqlParserFINAL, KSqlParserESCAPE, KSqlParserINTEGER, KSqlParserDATE, KSqlParserTIME, KSqlParserTIMESTAMP, KSqlParserINTERVAL, KSqlParserYEAR, KSqlParserMONTH, KSqlParserDAY, KSqlParserHOUR, KSqlParserMINUTE, KSqlParserSECOND, KSqlParserZONE, KSqlParserPARTITION, KSqlParserSTRUCT, KSqlParserEXPLAIN, KSqlParserANALYZE, KSqlParserTYPE, KSqlParserTYPES, KSqlParserSHOW, KSqlParserTABLES, KSqlParserCOLUMNS, KSqlParserCOLUMN, KSqlParserPARTITIONS, KSqlParserFUNCTIONS, KSqlParserFUNCTION, KSqlParserARRAY, KSqlParserMAP, KSqlParserSET, KSqlParserRESET, KSqlParserSESSION, KSqlParserKEY, KSqlParserSINK, KSqlParserSOURCE, KSqlParserPRIMARY, KSqlParserREPLACE, KSqlParserASSERT, KSqlParserADD, KSqlParserALTER, KSqlParserIF:
		localctx = NewUnquotedIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1085)
			p.NonReserved()
		}

	case KSqlParserBACKQUOTED_IDENTIFIER:
		localctx = NewBackQuotedIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1086)
			p.Match(KSqlParserBACKQUOTED_IDENTIFIER)
		}

	case KSqlParserDIGIT_IDENTIFIER:
		localctx = NewDigitIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1087)
			p.Match(KSqlParserDIGIT_IDENTIFIER)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILambdaFunctionContext is an interface to support dynamic dispatch.
type ILambdaFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLambdaFunctionContext differentiates from other interfaces.
	IsLambdaFunctionContext()
}

type LambdaFunctionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaFunctionContext() *LambdaFunctionContext {
	var p = new(LambdaFunctionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_lambdaFunction
	return p
}

func (*LambdaFunctionContext) IsLambdaFunctionContext() {}

func NewLambdaFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaFunctionContext {
	var p = new(LambdaFunctionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_lambdaFunction

	return p
}

func (s *LambdaFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaFunctionContext) CopyFrom(ctx *LambdaFunctionContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *LambdaFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type LambdaContext struct {
	*LambdaFunctionContext
}

func NewLambdaContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LambdaContext {
	var p = new(LambdaContext)

	p.LambdaFunctionContext = NewEmptyLambdaFunctionContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LambdaFunctionContext))

	return p
}

func (s *LambdaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaContext) AllIdentifier() []IIdentifierContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifierContext)(nil)).Elem())
	var tst = make([]IIdentifierContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifierContext)
		}
	}

	return tst
}

func (s *LambdaContext) Identifier(i int) IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LambdaContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LambdaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterLambda(s)
	}
}

func (s *LambdaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitLambda(s)
	}
}

func (p *KSqlParser) LambdaFunction() (localctx ILambdaFunctionContext) {
	localctx = NewLambdaFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, KSqlParserRULE_lambdaFunction)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1107)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KSqlParserT__7, KSqlParserEMIT, KSqlParserCHANGES, KSqlParserFINAL, KSqlParserESCAPE, KSqlParserINTEGER, KSqlParserDATE, KSqlParserTIME, KSqlParserTIMESTAMP, KSqlParserINTERVAL, KSqlParserYEAR, KSqlParserMONTH, KSqlParserDAY, KSqlParserHOUR, KSqlParserMINUTE, KSqlParserSECOND, KSqlParserZONE, KSqlParserPARTITION, KSqlParserSTRUCT, KSqlParserEXPLAIN, KSqlParserANALYZE, KSqlParserTYPE, KSqlParserTYPES, KSqlParserSHOW, KSqlParserTABLES, KSqlParserCOLUMNS, KSqlParserCOLUMN, KSqlParserPARTITIONS, KSqlParserFUNCTIONS, KSqlParserFUNCTION, KSqlParserARRAY, KSqlParserMAP, KSqlParserSET, KSqlParserRESET, KSqlParserSESSION, KSqlParserKEY, KSqlParserSINK, KSqlParserSOURCE, KSqlParserPRIMARY, KSqlParserREPLACE, KSqlParserASSERT, KSqlParserADD, KSqlParserALTER, KSqlParserIF, KSqlParserIDENTIFIER, KSqlParserDIGIT_IDENTIFIER, KSqlParserQUOTED_IDENTIFIER, KSqlParserBACKQUOTED_IDENTIFIER, KSqlParserVARIABLE:
		localctx = NewLambdaContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1090)
			p.Identifier()
		}
		{
			p.SetState(1091)
			p.Match(KSqlParserLAMBDA_EXPRESSION)
		}
		{
			p.SetState(1092)
			p.Expression()
		}

	case KSqlParserT__2:
		localctx = NewLambdaContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1094)
			p.Match(KSqlParserT__2)
		}
		{
			p.SetState(1095)
			p.Identifier()
		}
		p.SetState(1100)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == KSqlParserT__1 {
			{
				p.SetState(1096)
				p.Match(KSqlParserT__1)
			}
			{
				p.SetState(1097)
				p.Identifier()
			}

			p.SetState(1102)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1103)
			p.Match(KSqlParserT__3)
		}
		{
			p.SetState(1104)
			p.Match(KSqlParserLAMBDA_EXPRESSION)
		}
		{
			p.SetState(1105)
			p.Expression()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IVariableNameContext is an interface to support dynamic dispatch.
type IVariableNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableNameContext differentiates from other interfaces.
	IsVariableNameContext()
}

type VariableNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableNameContext() *VariableNameContext {
	var p = new(VariableNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_variableName
	return p
}

func (*VariableNameContext) IsVariableNameContext() {}

func NewVariableNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableNameContext {
	var p = new(VariableNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_variableName

	return p
}

func (s *VariableNameContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableNameContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(KSqlParserIDENTIFIER, 0)
}

func (s *VariableNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterVariableName(s)
	}
}

func (s *VariableNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitVariableName(s)
	}
}

func (p *KSqlParser) VariableName() (localctx IVariableNameContext) {
	localctx = NewVariableNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, KSqlParserRULE_variableName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1109)
		p.Match(KSqlParserIDENTIFIER)
	}

	return localctx
}

// IVariableValueContext is an interface to support dynamic dispatch.
type IVariableValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariableValueContext differentiates from other interfaces.
	IsVariableValueContext()
}

type VariableValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableValueContext() *VariableValueContext {
	var p = new(VariableValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_variableValue
	return p
}

func (*VariableValueContext) IsVariableValueContext() {}

func NewVariableValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableValueContext {
	var p = new(VariableValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_variableValue

	return p
}

func (s *VariableValueContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableValueContext) STRING() antlr.TerminalNode {
	return s.GetToken(KSqlParserSTRING, 0)
}

func (s *VariableValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterVariableValue(s)
	}
}

func (s *VariableValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitVariableValue(s)
	}
}

func (p *KSqlParser) VariableValue() (localctx IVariableValueContext) {
	localctx = NewVariableValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, KSqlParserRULE_variableValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1111)
		p.Match(KSqlParserSTRING)
	}

	return localctx
}

// ISourceNameContext is an interface to support dynamic dispatch.
type ISourceNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSourceNameContext differentiates from other interfaces.
	IsSourceNameContext()
}

type SourceNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySourceNameContext() *SourceNameContext {
	var p = new(SourceNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_sourceName
	return p
}

func (*SourceNameContext) IsSourceNameContext() {}

func NewSourceNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SourceNameContext {
	var p = new(SourceNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_sourceName

	return p
}

func (s *SourceNameContext) GetParser() antlr.Parser { return s.parser }

func (s *SourceNameContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SourceNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SourceNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SourceNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterSourceName(s)
	}
}

func (s *SourceNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitSourceName(s)
	}
}

func (p *KSqlParser) SourceName() (localctx ISourceNameContext) {
	localctx = NewSourceNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, KSqlParserRULE_sourceName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1113)
		p.Identifier()
	}

	return localctx
}

// INumberContext is an interface to support dynamic dispatch.
type INumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNumberContext differentiates from other interfaces.
	IsNumberContext()
}

type NumberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumberContext() *NumberContext {
	var p = new(NumberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_number
	return p
}

func (*NumberContext) IsNumberContext() {}

func NewNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumberContext {
	var p = new(NumberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_number

	return p
}

func (s *NumberContext) GetParser() antlr.Parser { return s.parser }

func (s *NumberContext) CopyFrom(ctx *NumberContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *NumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DecimalLiteralContext struct {
	*NumberContext
}

func NewDecimalLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DecimalLiteralContext {
	var p = new(DecimalLiteralContext)

	p.NumberContext = NewEmptyNumberContext()
	p.parser = parser
	p.CopyFrom(ctx.(*NumberContext))

	return p
}

func (s *DecimalLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecimalLiteralContext) DECIMAL_VALUE() antlr.TerminalNode {
	return s.GetToken(KSqlParserDECIMAL_VALUE, 0)
}

func (s *DecimalLiteralContext) MINUS() antlr.TerminalNode {
	return s.GetToken(KSqlParserMINUS, 0)
}

func (s *DecimalLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterDecimalLiteral(s)
	}
}

func (s *DecimalLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitDecimalLiteral(s)
	}
}

type FloatLiteralContext struct {
	*NumberContext
}

func NewFloatLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FloatLiteralContext {
	var p = new(FloatLiteralContext)

	p.NumberContext = NewEmptyNumberContext()
	p.parser = parser
	p.CopyFrom(ctx.(*NumberContext))

	return p
}

func (s *FloatLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FloatLiteralContext) FLOATING_POINT_VALUE() antlr.TerminalNode {
	return s.GetToken(KSqlParserFLOATING_POINT_VALUE, 0)
}

func (s *FloatLiteralContext) MINUS() antlr.TerminalNode {
	return s.GetToken(KSqlParserMINUS, 0)
}

func (s *FloatLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterFloatLiteral(s)
	}
}

func (s *FloatLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitFloatLiteral(s)
	}
}

type IntegerLiteralContext struct {
	*NumberContext
}

func NewIntegerLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntegerLiteralContext {
	var p = new(IntegerLiteralContext)

	p.NumberContext = NewEmptyNumberContext()
	p.parser = parser
	p.CopyFrom(ctx.(*NumberContext))

	return p
}

func (s *IntegerLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerLiteralContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(KSqlParserINTEGER_VALUE, 0)
}

func (s *IntegerLiteralContext) MINUS() antlr.TerminalNode {
	return s.GetToken(KSqlParserMINUS, 0)
}

func (s *IntegerLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterIntegerLiteral(s)
	}
}

func (s *IntegerLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitIntegerLiteral(s)
	}
}

func (p *KSqlParser) Number() (localctx INumberContext) {
	localctx = NewNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, KSqlParserRULE_number)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1127)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 144, p.GetParserRuleContext()) {
	case 1:
		localctx = NewDecimalLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1116)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserMINUS {
			{
				p.SetState(1115)
				p.Match(KSqlParserMINUS)
			}

		}
		{
			p.SetState(1118)
			p.Match(KSqlParserDECIMAL_VALUE)
		}

	case 2:
		localctx = NewFloatLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1120)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserMINUS {
			{
				p.SetState(1119)
				p.Match(KSqlParserMINUS)
			}

		}
		{
			p.SetState(1122)
			p.Match(KSqlParserFLOATING_POINT_VALUE)
		}

	case 3:
		localctx = NewIntegerLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1124)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == KSqlParserMINUS {
			{
				p.SetState(1123)
				p.Match(KSqlParserMINUS)
			}

		}
		{
			p.SetState(1126)
			p.Match(KSqlParserINTEGER_VALUE)
		}

	}

	return localctx
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_literal
	return p
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) CopyFrom(ctx *LiteralContext) {
	s.BaseParserRuleContext.CopyFrom(ctx.BaseParserRuleContext)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type NullLiteralContext struct {
	*LiteralContext
}

func NewNullLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NullLiteralContext {
	var p = new(NullLiteralContext)

	p.LiteralContext = NewEmptyLiteralContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LiteralContext))

	return p
}

func (s *NullLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullLiteralContext) NULL() antlr.TerminalNode {
	return s.GetToken(KSqlParserNULL, 0)
}

func (s *NullLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterNullLiteral(s)
	}
}

func (s *NullLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitNullLiteral(s)
	}
}

type StringLiteralContext struct {
	*LiteralContext
}

func NewStringLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StringLiteralContext {
	var p = new(StringLiteralContext)

	p.LiteralContext = NewEmptyLiteralContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LiteralContext))

	return p
}

func (s *StringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralContext) STRING() antlr.TerminalNode {
	return s.GetToken(KSqlParserSTRING, 0)
}

func (s *StringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterStringLiteral(s)
	}
}

func (s *StringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitStringLiteral(s)
	}
}

type VariableLiteralContext struct {
	*LiteralContext
}

func NewVariableLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *VariableLiteralContext {
	var p = new(VariableLiteralContext)

	p.LiteralContext = NewEmptyLiteralContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LiteralContext))

	return p
}

func (s *VariableLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableLiteralContext) VARIABLE() antlr.TerminalNode {
	return s.GetToken(KSqlParserVARIABLE, 0)
}

func (s *VariableLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterVariableLiteral(s)
	}
}

func (s *VariableLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitVariableLiteral(s)
	}
}

type NumericLiteralContext struct {
	*LiteralContext
}

func NewNumericLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NumericLiteralContext {
	var p = new(NumericLiteralContext)

	p.LiteralContext = NewEmptyLiteralContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LiteralContext))

	return p
}

func (s *NumericLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumericLiteralContext) Number() INumberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *NumericLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterNumericLiteral(s)
	}
}

func (s *NumericLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitNumericLiteral(s)
	}
}

type BooleanLiteralContext struct {
	*LiteralContext
}

func NewBooleanLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)

	p.LiteralContext = NewEmptyLiteralContext()
	p.parser = parser
	p.CopyFrom(ctx.(*LiteralContext))

	return p
}

func (s *BooleanLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanLiteralContext) BooleanValue() IBooleanValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBooleanValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBooleanValueContext)
}

func (s *BooleanLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterBooleanLiteral(s)
	}
}

func (s *BooleanLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitBooleanLiteral(s)
	}
}

func (p *KSqlParser) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, KSqlParserRULE_literal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1134)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case KSqlParserNULL:
		localctx = NewNullLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1129)
			p.Match(KSqlParserNULL)
		}

	case KSqlParserMINUS, KSqlParserINTEGER_VALUE, KSqlParserDECIMAL_VALUE, KSqlParserFLOATING_POINT_VALUE:
		localctx = NewNumericLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1130)
			p.Number()
		}

	case KSqlParserTRUE, KSqlParserFALSE:
		localctx = NewBooleanLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1131)
			p.BooleanValue()
		}

	case KSqlParserSTRING:
		localctx = NewStringLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1132)
			p.Match(KSqlParserSTRING)
		}

	case KSqlParserVARIABLE:
		localctx = NewVariableLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1133)
			p.Match(KSqlParserVARIABLE)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// INonReservedContext is an interface to support dynamic dispatch.
type INonReservedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNonReservedContext differentiates from other interfaces.
	IsNonReservedContext()
}

type NonReservedContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNonReservedContext() *NonReservedContext {
	var p = new(NonReservedContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = KSqlParserRULE_nonReserved
	return p
}

func (*NonReservedContext) IsNonReservedContext() {}

func NewNonReservedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NonReservedContext {
	var p = new(NonReservedContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = KSqlParserRULE_nonReserved

	return p
}

func (s *NonReservedContext) GetParser() antlr.Parser { return s.parser }

func (s *NonReservedContext) SHOW() antlr.TerminalNode {
	return s.GetToken(KSqlParserSHOW, 0)
}

func (s *NonReservedContext) TABLES() antlr.TerminalNode {
	return s.GetToken(KSqlParserTABLES, 0)
}

func (s *NonReservedContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(KSqlParserCOLUMNS, 0)
}

func (s *NonReservedContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(KSqlParserCOLUMN, 0)
}

func (s *NonReservedContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(KSqlParserPARTITIONS, 0)
}

func (s *NonReservedContext) FUNCTIONS() antlr.TerminalNode {
	return s.GetToken(KSqlParserFUNCTIONS, 0)
}

func (s *NonReservedContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(KSqlParserFUNCTION, 0)
}

func (s *NonReservedContext) SESSION() antlr.TerminalNode {
	return s.GetToken(KSqlParserSESSION, 0)
}

func (s *NonReservedContext) STRUCT() antlr.TerminalNode {
	return s.GetToken(KSqlParserSTRUCT, 0)
}

func (s *NonReservedContext) MAP() antlr.TerminalNode {
	return s.GetToken(KSqlParserMAP, 0)
}

func (s *NonReservedContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(KSqlParserARRAY, 0)
}

func (s *NonReservedContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(KSqlParserPARTITION, 0)
}

func (s *NonReservedContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(KSqlParserINTEGER, 0)
}

func (s *NonReservedContext) DATE() antlr.TerminalNode {
	return s.GetToken(KSqlParserDATE, 0)
}

func (s *NonReservedContext) TIME() antlr.TerminalNode {
	return s.GetToken(KSqlParserTIME, 0)
}

func (s *NonReservedContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(KSqlParserTIMESTAMP, 0)
}

func (s *NonReservedContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(KSqlParserINTERVAL, 0)
}

func (s *NonReservedContext) ZONE() antlr.TerminalNode {
	return s.GetToken(KSqlParserZONE, 0)
}

func (s *NonReservedContext) YEAR() antlr.TerminalNode {
	return s.GetToken(KSqlParserYEAR, 0)
}

func (s *NonReservedContext) MONTH() antlr.TerminalNode {
	return s.GetToken(KSqlParserMONTH, 0)
}

func (s *NonReservedContext) DAY() antlr.TerminalNode {
	return s.GetToken(KSqlParserDAY, 0)
}

func (s *NonReservedContext) HOUR() antlr.TerminalNode {
	return s.GetToken(KSqlParserHOUR, 0)
}

func (s *NonReservedContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(KSqlParserMINUTE, 0)
}

func (s *NonReservedContext) SECOND() antlr.TerminalNode {
	return s.GetToken(KSqlParserSECOND, 0)
}

func (s *NonReservedContext) EXPLAIN() antlr.TerminalNode {
	return s.GetToken(KSqlParserEXPLAIN, 0)
}

func (s *NonReservedContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(KSqlParserANALYZE, 0)
}

func (s *NonReservedContext) TYPE() antlr.TerminalNode {
	return s.GetToken(KSqlParserTYPE, 0)
}

func (s *NonReservedContext) TYPES() antlr.TerminalNode {
	return s.GetToken(KSqlParserTYPES, 0)
}

func (s *NonReservedContext) SET() antlr.TerminalNode {
	return s.GetToken(KSqlParserSET, 0)
}

func (s *NonReservedContext) RESET() antlr.TerminalNode {
	return s.GetToken(KSqlParserRESET, 0)
}

func (s *NonReservedContext) IF() antlr.TerminalNode {
	return s.GetToken(KSqlParserIF, 0)
}

func (s *NonReservedContext) SOURCE() antlr.TerminalNode {
	return s.GetToken(KSqlParserSOURCE, 0)
}

func (s *NonReservedContext) SINK() antlr.TerminalNode {
	return s.GetToken(KSqlParserSINK, 0)
}

func (s *NonReservedContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(KSqlParserPRIMARY, 0)
}

func (s *NonReservedContext) KEY() antlr.TerminalNode {
	return s.GetToken(KSqlParserKEY, 0)
}

func (s *NonReservedContext) EMIT() antlr.TerminalNode {
	return s.GetToken(KSqlParserEMIT, 0)
}

func (s *NonReservedContext) CHANGES() antlr.TerminalNode {
	return s.GetToken(KSqlParserCHANGES, 0)
}

func (s *NonReservedContext) FINAL() antlr.TerminalNode {
	return s.GetToken(KSqlParserFINAL, 0)
}

func (s *NonReservedContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(KSqlParserESCAPE, 0)
}

func (s *NonReservedContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(KSqlParserREPLACE, 0)
}

func (s *NonReservedContext) ASSERT() antlr.TerminalNode {
	return s.GetToken(KSqlParserASSERT, 0)
}

func (s *NonReservedContext) ALTER() antlr.TerminalNode {
	return s.GetToken(KSqlParserALTER, 0)
}

func (s *NonReservedContext) ADD() antlr.TerminalNode {
	return s.GetToken(KSqlParserADD, 0)
}

func (s *NonReservedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NonReservedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NonReservedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.EnterNonReserved(s)
	}
}

func (s *NonReservedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(KSqlListener); ok {
		listenerT.ExitNonReserved(s)
	}
}

func (p *KSqlParser) NonReserved() (localctx INonReservedContext) {
	localctx = NewNonReservedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, KSqlParserRULE_nonReserved)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1136)
		_la = p.GetTokenStream().LA(1)

		if !((((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<KSqlParserT__7)|(1<<KSqlParserEMIT)|(1<<KSqlParserCHANGES)|(1<<KSqlParserFINAL))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(KSqlParserESCAPE-32))|(1<<(KSqlParserINTEGER-32))|(1<<(KSqlParserDATE-32))|(1<<(KSqlParserTIME-32))|(1<<(KSqlParserTIMESTAMP-32))|(1<<(KSqlParserINTERVAL-32))|(1<<(KSqlParserYEAR-32))|(1<<(KSqlParserMONTH-32))|(1<<(KSqlParserDAY-32))|(1<<(KSqlParserHOUR-32))|(1<<(KSqlParserMINUTE-32))|(1<<(KSqlParserSECOND-32))|(1<<(KSqlParserZONE-32)))) != 0) || (((_la-76)&-(0x1f+1)) == 0 && ((1<<uint((_la-76)))&((1<<(KSqlParserPARTITION-76))|(1<<(KSqlParserSTRUCT-76))|(1<<(KSqlParserEXPLAIN-76))|(1<<(KSqlParserANALYZE-76))|(1<<(KSqlParserTYPE-76))|(1<<(KSqlParserTYPES-76))|(1<<(KSqlParserSHOW-76))|(1<<(KSqlParserTABLES-76))|(1<<(KSqlParserCOLUMNS-76))|(1<<(KSqlParserCOLUMN-76))|(1<<(KSqlParserPARTITIONS-76))|(1<<(KSqlParserFUNCTIONS-76)))) != 0) || (((_la-108)&-(0x1f+1)) == 0 && ((1<<uint((_la-108)))&((1<<(KSqlParserFUNCTION-108))|(1<<(KSqlParserARRAY-108))|(1<<(KSqlParserMAP-108))|(1<<(KSqlParserSET-108))|(1<<(KSqlParserRESET-108))|(1<<(KSqlParserSESSION-108))|(1<<(KSqlParserKEY-108))|(1<<(KSqlParserSINK-108))|(1<<(KSqlParserSOURCE-108))|(1<<(KSqlParserPRIMARY-108))|(1<<(KSqlParserREPLACE-108))|(1<<(KSqlParserASSERT-108))|(1<<(KSqlParserADD-108)))) != 0) || _la == KSqlParserALTER || _la == KSqlParserIF) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

func (p *KSqlParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 40:
		var t *BooleanExpressionContext = nil
		if localctx != nil {
			t = localctx.(*BooleanExpressionContext)
		}
		return p.BooleanExpression_Sempred(t, predIndex)

	case 43:
		var t *ValueExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ValueExpressionContext)
		}
		return p.ValueExpression_Sempred(t, predIndex)

	case 44:
		var t *PrimaryExpressionContext = nil
		if localctx != nil {
			t = localctx.(*PrimaryExpressionContext)
		}
		return p.PrimaryExpression_Sempred(t, predIndex)

	case 49:
		var t *SqltypeContext = nil
		if localctx != nil {
			t = localctx.(*SqltypeContext)
		}
		return p.Sqltype_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *KSqlParser) BooleanExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 1:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *KSqlParser) ValueExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 2:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 3:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 4:
		return p.Precpred(p.GetParserRuleContext(), 1)

	case 5:
		return p.Precpred(p.GetParserRuleContext(), 5)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *KSqlParser) PrimaryExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 6:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 7:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *KSqlParser) Sqltype_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 8:
		return p.Precpred(p.GetParserRuleContext(), 6)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
